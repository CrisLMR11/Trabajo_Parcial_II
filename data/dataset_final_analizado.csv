repo,id_referencia,tipo_origen,tipo_mensaje,texto,texto_limpio,sentimiento_etiqueta,tema_grupo
flask,5910,Pull Request,Titulo,ü§ñ Automated code quality improvements (5 fixes),automated code quality improvement fix,Positivo,2
flask,5910,Pull Request,Descripcion,"## ü§ñ Automated Code Quality Improvements

This PR contains automated fixes for code quality issues detected in the repository.

### üìä Summary of Fixes

| Category | Count |
|----------|-------|
| Syntax Errors/Bugs | 42 |
| Security Vulnerabilities | 62 |
| Code Style Violations | 1126 |
| Performance Issues | 0 |
| Unused Code | 164 |
| Code Duplication | 1 |
| Error Handling | 0 |
| **Total** | **1395** |

### üîß Fixes Applied

1. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_basic.py:1365` - Using variable 'error' before assignment
2. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_config.py:129` - Too many positional arguments for method call
3. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_cli.py:54` - class already defined line 49
4. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_cli.py:59` - class already defined line 49
5. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_cli.py:64` - class already defined line 49

### ‚úÖ Verification

All fixes have been automatically applied and tested. Please review the changes and merge if appropriate.

---
*Generated by GitHub Code Fixer*
",automated code quality improvement contains automated fix code quality issue detected repository summary fix category count syntax errorsbugs security vulnerability code style violation performance issue unused code code duplication error handling total fix applied bug tmpcodefixerteststestbasicpy using variable error assignment bug tmpcodefixerteststestconfigpy many positional argument method call bug tmpcodefixerteststestclipy class already defined line bug tmpcodefixerteststestclipy class already defined line bug tmpcodefixerteststestclipy class already defined line verification fix automatically applied tested please review change merge appropriate generated github code fixer,Negativo,2
flask,5910,Pull Request,Comentario,"Closing this PR - it was a test of my automated code quality improvement tool. 
   Thank you for the opportunity to test on Flask! üôè",closing test automated code quality improvement tool thank opportunity test flask,Positivo,2
flask,5910,Pull Request,Comentario,"please create test prs against own repos, they waste attention and time of maintainers",please create test pr repos waste attention time maintainer,Positivo,2
flask,5891,Pull Request,Titulo,docs: clarify 415 vs 400 errors for Request.json,doc clarify error requestjson,Negativo,1
flask,5891,Pull Request,Descripcion,"Fixes #5825

## Summary
Clarified the documentation for `Request.json` to distinguish between the two error cases:
- **415 Unsupported Media Type**: Raised when the `Content-Type` header is not set to `application/json`
- **400 Bad Request**: Raised when the body is not valid JSON

## Changes
Updated `docs/patterns/javascript.rst` in the ""Receiving JSON in Views"" section to accurately reflect these two distinct error codes, making it consistent with the API reference documentation.

## Test Plan
- [x] Verified the change matches the Flask API documentation behavior
- [x] Confirmed the reStructuredText syntax is correct
- [x] Checked that both error conditions are now clearly documented

---
ü§ñ Generated with [Solari AGI](https://github.com/SolariSystems)",fix summary clarified documentation requestjson distinguish two error case unsupported medium type raised contenttype header set applicationjson bad request raised body valid json change updated docspatternsjavascriptrst receiving json view section accurately reflect two distinct error code making consistent api reference documentation test plan verified change match flask api documentation behavior confirmed restructuredtext syntax correct checked error condition clearly documented generated solari agi,Negativo,1
flask,5892,Pull Request,Titulo,docs: improve wording in appdispatch,doc improve wording appdispatch,Positivo,2
flask,5892,Pull Request,Descripcion,"- Clarify wording in Application Dispatching docs (docs/patterns/appdispatch.rst).
- No functional changes.
",clarify wording application dispatching doc docspatternsappdispatchrst functional change,Negativo,2
flask,5892,Pull Request,Comentario,Hi! This PR improves wording in the Application Dispatching documentation for clarity. Thanks!,improves wording application dispatching documentation clarity thanks,Positivo,4
flask,5893,Pull Request,Titulo,fix: Clarify Request.json error handling,fix clarify requestjson error handling,Negativo,1
flask,5893,Pull Request,Descripcion,"Fixes #5825

## Summary
Clarify Request.json error handling

## Changes Made
Modified files to address the issue requirements as described in #5825.

## Testing
Validation passed for these changes.
",fix summary clarify requestjson error handling change made modified file address issue requirement described testing validation passed change,Negativo,2
flask,5890,Pull Request,Titulo,Improve templating documentation for clarity and readability,improve templating documentation clarity readability,Positivo,2
flask,5890,Pull Request,Descripcion,"This PR updates the templating documentation to improve clarity for new
readers while maintaining technical accuracy.

Changes include:
- Rephrased sections describing autoescaping behavior
- Added structured explanation of template streaming
- Reformatted code examples for consistency
- Added contextual notes for template utility functions
- Improved explanation of `url_for` with example usage

These revisions aim to make the documentation more beginner-friendly and
easier to follow without reducing detail.

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",update templating documentation improve clarity new reader maintaining technical accuracy change include rephrased section describing autoescaping behavior added structured explanation template streaming reformatted code example consistency added contextual note template utility function improved explanation urlfor example usage revision aim make documentation beginnerfriendly easier follow without reducing detail opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Positivo,0
flask,5902,Issue,Titulo,Improve alt text for Debug Mode interactive debugger image (accessibility),improve alt text debug mode interactive debugger image accessibility,Positivo,2
flask,5902,Issue,Descripcion,"
In the Flask documentation section [‚ÄúDebug Mode‚Äù](https://flask.palletsprojects.com/en/stable/quickstart/#debug-mode), there is an image demonstrating the interactive debugger with the following markup:
```
<img alt=""The interactive debugger in action.""
     class=""screenshot align-center""
     src=""../_images/debugger.png"">  
```
The alt text is very generic and does not clearly describe the content or purpose of the image.
For users who rely on screen readers, the current alt text does not convey that this is a Flask error page shown in the browser
This makes the documentation less accessible for users with visual impairments and does not fully meet the intent of WCAG 1.1.1 (Non-text Content)

**Suggested improvement**
Replace the existing alt text with something more descriptive, for example:
‚ÄúFlask debug mode error page showing a Python traceback and an interactive debugger panel in the browser",flask documentation section debug mode image demonstrating interactive debugger following markup img altthe interactive debugger action classscreenshot aligncenter srcimagesdebuggerpng alt text generic clearly describe content purpose image user rely screen reader current alt text convey flask error page shown browser make documentation less accessible user visual impairment fully meet intent wcag nontext content suggested improvement replace existing alt text something descriptive example flask debug mode error page showing python traceback interactive debugger panel browser,Negativo,2
flask,5902,Issue,Comentario,"Hello @davidism,
Thank you for taking the time to review the issue,  I understand that maintaining the project involves careful prioritization.

I wanted to briefly highlight that this suggestion is motivated by accessibility considerations. There are developers who rely on assistive technologies such as screen readers or alternative navigation methods to work effectively. For them, even small accessibility-related details can have a significant impact on usability and inclusion.

From that perspective, accessibility improvements aren‚Äôt just cosmetic; they help ensure that the project remains usable by a broader and more diverse developer community. This also aligns with long-term project quality and inclusiveness.

I‚Äôm personally very interested in accessibility and would be happy to contribute if there‚Äôs a preferred approach or scope for such improvements within the project. Any guidance would be greatly appreciated.

Thank you again for your work on the project and for considering this perspective.",hello thank taking time review issue understand maintaining project involves careful prioritization wanted briefly highlight suggestion motivated accessibility consideration developer rely assistive technology screen reader alternative navigation method work effectively even small accessibilityrelated detail significant impact usability inclusion perspective accessibility improvement arent cosmetic help ensure project remains usable broader diverse developer community also aligns longterm project quality inclusiveness personally interested accessibility would happy contribute there preferred approach scope improvement within project guidance would greatly appreciated thank work project considering perspective,Positivo,2
flask,5889,Pull Request,Titulo,Revise Jinja templating documentation for clarity and readability,revise jinja templating documentation clarity readability,Positivo,2
flask,5889,Pull Request,Descripcion,"This PR updates the templating documentation to improve clarity for new
readers while maintaining technical accuracy.

Changes include:
- Rephrased sections describing autoescaping behavior
- Added structured explanation of template streaming
- Reformatted code examples for consistency
- Added contextual notes for template utility functions
- Improved explanation of `url_for` with example usage

These revisions aim to make the documentation more beginner-friendly and
easier to follow without reducing detail.

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",update templating documentation improve clarity new reader maintaining technical accuracy change include rephrased section describing autoescaping behavior added structured explanation template streaming reformatted code example consistency added contextual note template utility function improved explanation urlfor example usage revision aim make documentation beginnerfriendly easier follow without reducing detail opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Positivo,0
flask,5908,Pull Request,Titulo,style: format response tuple unpacking (extract helper),style format response tuple unpacking extract helper,Neutral,2
flask,5908,Pull Request,Descripcion,"## Summary

Refactors the response tuple unpacking logic in `make_response` into a small
private helper method to improve readability and maintainability.

No behavior changes are intended.

##Fixes #5907 
## Details

The existing tuple-unpacking logic inside `make_response` was moved into a
dedicated private helper method. This keeps the method shorter and easier to
reason about, without changing any runtime behavior.

## Testing

- All existing tests pass.
- No new tests were added, as this change does not affect behavior.

## Notes

This is an internal refactor only. No public API or documented behavior is
changed.
",summary refactors response tuple unpacking logic makeresponse small private helper method improve readability maintainability behavior change intended fix detail existing tupleunpacking logic inside makeresponse moved dedicated private helper method keep method shorter easier reason without changing runtime behavior testing existing test pas new test added change affect behavior note internal refactor public api documented behavior changed,Positivo,2
flask,5907,Issue,Titulo,Internal refactor: simplify response tuple unpacking in make_response in app.py,internal refactor simplify response tuple unpacking makeresponse apppy,Neutral,2
flask,5907,Issue,Descripcion,"This is an internal, non-user-facing refactor.

The `make_response` method currently contains inline logic to unpack
response tuples with different valid shapes. While this logic is correct,
it is dense and increases cognitive load in an already large method.

Refactoring this logic into a small private helper would improve
readability and long-term maintainability without changing behavior.

The current tuple unpacking logic handles multiple valid forms
((body, status, headers), (body, status), (body, headers)) inline inside
`make_response`. This makes the control flow harder to follow and
duplicates validation responsibilities within the method.

This is not easily improved via subclassing or extensions, as the logic
is internal to Flask's response handling. A small internal refactor would
isolate this responsibility and make future maintenance safer.
",internal nonuserfacing refactor makeresponse method currently contains inline logic unpack response tuples different valid shape logic correct dense increase cognitive load already large method refactoring logic small private helper would improve readability longterm maintainability without changing behavior current tuple unpacking logic handle multiple valid form body status header body status body header inline inside makeresponse make control flow harder follow duplicate validation responsibility within method easily improved via subclassing extension logic internal flask response handling small internal refactor would isolate responsibility make future maintenance safer,Positivo,2
flask,5906,Pull Request,Titulo,Added a return type annotation to an internal utility function in the Requests library to improve code readability and static analysis without affecting behavior.,added return type annotation internal utility function request library improve code readability static analysis without affecting behavior,Positivo,2
flask,5906,Pull Request,Descripcion,"Improved Flask documentation by clarifying JSON request requirements,
helping new users avoid common request-handling issues.",improved flask documentation clarifying json request requirement helping new user avoid common requesthandling issue,Positivo,1
flask,5888,Pull Request,Titulo,Docs: add context to Incoming Request Data section,doc add context incoming request data section,Neutral,2
flask,5888,Pull Request,Descripcion,":wq

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5888,Pull Request,Comentario,"Thanks for the thoughtful review!

You‚Äôre right about the consistency across sections. My intention here was to
improve clarity for readers in a section that jumps directly into the API
reference, similar to how the Sessions and Application Globals sections
provide
brief context.

I wanted to keep the scope of this PR minimal as a first contribution, but
I‚Äôm
happy to adjust the wording to better match the existing style, or extend
similar
introductory context to other major sections if that‚Äôs preferred.

Please let me know what approach you‚Äôd recommend.

On Fri, Jan 16, 2026 at 3:05‚ÄØAM Copilot ***@***.***> wrote:

> ***@***.**** commented on this pull request.
> Pull request overview
>
> This PR adds introductory context to the ""Incoming Request Data"" section
> in the Flask API documentation. The changes aim to help developers better
> understand what the section covers and the purpose of the request proxy
> object before diving into the detailed API reference.
>
> *Changes:*
>
>    - Added an introductory paragraph to the ""Incoming Request Data""
>    section explaining its purpose
>    - Enhanced the request proxy documentation with a clarifying sentence
>    about its role in view functions
>
> ------------------------------
>
> üí° Add Copilot custom instructions
> <http:///pallets/flask/new/main/.github/instructions?filename=*.instructions.md>
> for smarter, more guided reviews. Learn how to get started
> <https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot>
> .
> ------------------------------
>
> In docs/api.rst
> <https://github.com/pallets/flask/pull/5888#discussion_r2696041318>:
>
> > +This section describes how to access data sent by the client in an HTTP
> +request, such as query parameters, form data, JSON payloads, and headers.
>
> Consider adding consistency with other sections. The 'Sessions' section
> (lines 59-67) and 'Application Globals' section (lines 151-156) also have
> introductory paragraphs. However, 'Application Object', 'Blueprint
> Objects', and 'Response Objects' sections do not. While this addition is
> helpful, it creates inconsistency. Consider either adding similar
> introductions to other major sections or ensuring the current style aligns
> with the documentation's overall approach.
>
> ‚Äî
> Reply to this email directly, view it on GitHub
> <https://github.com/pallets/flask/pull/5888#pullrequestreview-3667685341>,
> or unsubscribe
> <https://github.com/notifications/unsubscribe-auth/BZY6ACYOVMCD6YE7YVTP7JT4HABZ3AVCNFSM6AAAAACR264P3WVHI2DSMVQWIX3LMV43YUDVNRWFEZLROVSXG5CSMV3GSZLXHMZTMNRXGY4DKMZUGE>
> .
> You are receiving this because you authored the thread.Message ID:
> ***@***.***>
>
",thanks thoughtful review youre right consistency across section intention improve clarity reader section jump directly api reference similar session application globals section provide brief context wanted keep scope minimal first contribution happy adjust wording better match existing style extend similar introductory context major section thats preferred please let know approach youd recommend fri jan copilot wrote commented pull request pull request overview add introductory context incoming request data section flask api documentation change aim help developer better understand section cover purpose request proxy object diving detailed api reference change added introductory paragraph incoming request data section explaining purpose enhanced request proxy documentation clarifying sentence role view function add copilot custom instruction smarter guided review learn get started docsapirst section describes access data sent client http request query parameter form data json payload header consider adding consistency section session section line application globals section line also introductory paragraph however application object blueprint object response object section addition helpful creates inconsistency consider either adding similar introduction major section ensuring current style aligns documentation overall approach reply email directly view github unsubscribe receiving authored threadmessage,Positivo,2
flask,5903,Pull Request,Titulo,Abort if the instance folder cannot be created,abort instance folder cannot created,Negativo,2
flask,5903,Pull Request,Descripcion,"According to the comment, the instance folder should exist in any case. But a PermissionError was ignored silently.

Since Python 3.9 is the minimum required version, it is safe to use ""exist_ok"" added in Python 3.2 and avoid exception handling.",according comment instance folder exist case permissionerror ignored silently since python minimum required version safe use existok added python avoid exception handling,Negativo,2
flask,5903,Pull Request,Comentario,"Make sure you update the code in the `examples` dir as well. Does any surrounding text need to be updated? Docs changes should be targetted at stable, so that they're available in the current docs.",make sure update code example dir well surrounding text need updated doc change targetted stable theyre available current doc,Positivo,2
flask,5903,Pull Request,Comentario,"My branch was already based on `stable`, but it got wrong in the PR. I fixed that.

Code in `examples/` had already been updated, no further surrounding text needs changes, even the `os.makedirs` description further below fits better than before.

The surrounding code in `examples/` already wasn't in sync with the docs, though.",branch already based stable got wrong fixed code example already updated surrounding text need change even osmakedirs description fit better surrounding code example already wasnt sync doc though,Negativo,2
flask,5887,Issue,Titulo,Add explicit support for async teardown_request handlers,add explicit support async teardownrequest handler,Positivo,3
flask,5887,Issue,Descripcion,"### Summary

At the moment, `teardown_request` handlers in Flask are synchronous and cannot be defined as async functions. This makes it harder for apps that depend on async cleanup logic (e.g., closing async DB connections or awaiting async tasks) to integrate cleanly with Flask‚Äôs request lifecycle.

### Problem

When users attempt to define an async teardown handler like:

```python
@app.teardown_request
async def cleanup_async_resources(response):
    await close_async_connections()
```

Flask does not await it and treats it as a regular function, leading to unawaited coroutine warnings and the async cleanup not running as intended.

### Proposed Solution
Make teardown handlers awaitable - if a handler is declared async, Flask should await it during the teardown phase.

### Example
```python
@app.teardown_request
async def cleanup_async_resources(response):
    await some_async_cleanup()  # should be awaited before response is finalized
```

### Motivation
Better async integration support as more frameworks and applications adopt async patterns. This would make Flask‚Äôs async support more complete and intuitive.

### Environment

```python
Flask version: (e.g., 3.2.x)
Python version: 3.9+
```

Async libs used: Any

### Thanks!",summary moment teardownrequest handler flask synchronous cannot defined async function make harder apps depend async cleanup logic closing async connection awaiting async task integrate cleanly flask request lifecycle problem user attempt define async teardown handler like python teardownrequest async def cleanupasyncresourcesresponse await closeasyncconnections flask await treat regular function leading unawaited coroutine warning async cleanup running intended proposed solution make teardown handler awaitable handler declared async flask await teardown phase example python teardownrequest async def cleanupasyncresourcesresponse await someasynccleanup awaited response finalized motivation better async integration support framework application adopt async pattern would make flask async support complete intuitive environment python flask version python version async libs used thanks,Positivo,3
flask,5887,Issue,Comentario,"This already works. https://flask.palletsprojects.com/en/stable/async-await/

Do not use LLM tools to generate issues on your behalf.",already work use llm tool generate issue behalf,Neutral,2
flask,5897,Issue,Titulo,package detection fails with namespace package in editable mode,package detection fails namespace package editable mode,Negativo,2
flask,5897,Issue,Descripcion,"Given a package which uses namespace packaging and has been installed using ""editable installs"", Flask's scaffold (specifically `_find_package_path`) will error if the name passed to `Flask(...)` is the package name rather than a sub-module.

This affects cases where the name is the name of the package (and thus potentially not actually the `__name__`) though also happens when using `__name__` and the app is defined within a `__init__.py` in the root of the namespaced package.

Notably the issue only appears when importing the app elsewhere -- running from a python process launched at the parent of the namespace package tree hides this.

Example project:
```
‚îú‚îÄ‚îÄ flask-app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ setup.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ sr
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ comp
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ http
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ __init__.pyi
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ __init__.pyi
‚îî‚îÄ‚îÄ run.py
```
The `__init__.pyi` files are empty and shouldn't be needed, however are present in my original project as typing markers.

```python
# run.py
print("""")
print(""run.py"")
print("""")

from sr.comp.http import app

print("""")
print(""/run.py"")
print("""")
```
```python
# flask-app/sr/comp/http/__init__.py
from flask import Flask

print(""app = Flask(__name__)"")
app = Flask(__name__)  # reproduces when defined in __init__.py

print(""app = Flask('sr.comp.http')"")
app = Flask(""sr.comp.http"")  # reproduces when defined in e.g: server.py and `app` is re-exported via __init__.py
# this latter case was my original case

@app.route(""/"")
def hello():
    return ""Hello, World!""
```

<details>
<summary><code>flask-app/setup.py</code></summary>

``` python
# flask-app/setup.py
from setuptools import find_namespace_packages, setup

setup(
    name='sr.comp.http',
    packages=find_namespace_packages(include=['sr.*']),
    namespace_packages=['sr', 'sr.comp'],
    install_requires=[
        'Flask >=2.2',
    ],
)
```

</details>

The error is:
```
Traceback (most recent call last):
  File ""/home/peter/play/flask-play/run.py"", line 6, in <module>
    from sr.comp.http import app
  File ""/home/peter/play/flask-play/flask-app/sr/comp/http/__init__.py"", line 5, in <module>
    app = Flask(__name__)
          ^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/app.py"", line 239, in __init__
    super().__init__(
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 304, in __init__
    instance_path = self.auto_find_instance_path()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 518, in auto_find_instance_path
    prefix, package_path = find_package(self.import_name)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 783, in find_package
    package_path = _find_package_path(import_name)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 748, in _find_package_path
    search_location = next(
                      ^^^^^
StopIteration
```

I've been testing this by running the following to compare against a non-editable install:
``` shell
pip install flask-app/ && python run.py && pip install -e flask-app/ && python run.py
```

I've also made some modifications to `flask/sansio/scaffold.py` to debug, which provides some insight. It looks like the issue is to do with whether or not the `package_path` is found to be relative to the `package_spec.submodule_search_locations`.

<details>
<summary><code>scaffold.py</code> diff</summary>

```diff
@@ -708,7 +708,10 @@
 
 def _find_package_path(import_name: str) -> str:
     """"""Find the path that contains the package or module.""""""
+    print()
+    print(f""_find_package_path({import_name=})"")
     root_mod_name, _, _ = import_name.partition(""."")
+    print(f""_find_package_path: {root_mod_name=}"")
 
     try:
         root_spec = importlib.util.find_spec(root_mod_name)
@@ -721,18 +724,27 @@
         #    - the module name was invalid
         #    - the module name is __main__
         #    - we raised `ValueError` due to `root_spec` being `None`
+        print(""CWD"")
         return os.getcwd()
 
     if root_spec.submodule_search_locations:
         if root_spec.origin is None or root_spec.origin == ""namespace"":
             # namespace package
             package_spec = importlib.util.find_spec(import_name)
+            print(f""{package_spec=}"")
 
             if package_spec is not None and package_spec.submodule_search_locations:
                 # Pick the path in the namespace that contains the submodule.
                 package_path = pathlib.Path(
                     os.path.commonpath(package_spec.submodule_search_locations)
                 )
+                print(f""{package_path=}"")
+                search_locations=[
+                    location
+                    for location in root_spec.submodule_search_locations
+                    if package_path.is_relative_to(location)
+                ]
+                print(f""{search_locations=}"")
                 search_location = next(
                     location
                     for location in root_spec.submodule_search_locations
@@ -740,14 +752,18 @@
                 )
             else:
                 # Pick the first path.
+                print(""Picking the first path"")
                 search_location = root_spec.submodule_search_locations[0]
 
+            print(f""{os.path.dirname(search_location)=}"")
             return os.path.dirname(search_location)
         else:
             # package with __init__.py
+            print(f""package with __init__.py: {os.path.dirname(os.path.dirname(root_spec.origin))=}"")
             return os.path.dirname(os.path.dirname(root_spec.origin))
     else:
         # module
+        print(f""module: {os.path.dirname(root_spec.origin)=}"")
         return os.path.dirname(root_spec.origin)  # type: ignore[type-var, return-value]
 
 
```

</details>

<details>
<summary>Full output (with scaffold printing)</summary>

```
Processing ./flask-app
  Installing build dependencies ... done
  Getting requirements to build wheel ... done
  Preparing metadata (pyproject.toml) ... done
Requirement already satisfied: Flask>=2.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from sr.comp.http==0.0.0) (3.1.2)
Requirement already satisfied: blinker>=1.9.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (1.9.0)
Requirement already satisfied: click>=8.1.3 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (8.3.1)
Requirement already satisfied: itsdangerous>=2.2.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (2.2.0)
Requirement already satisfied: jinja2>=3.1.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.6)
Requirement already satisfied: markupsafe>=2.1.1 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.0.3)
Requirement already satisfied: werkzeug>=3.1.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.5)
Building wheels for collected packages: sr.comp.http
  Building wheel for sr.comp.http (pyproject.toml) ... done
  Created wheel for sr.comp.http: filename=sr_comp_http-0.0.0-py3-none-any.whl size=2244 sha256=3f8b9ef6c2be19dfe215b2c753e08eba17f1d351d8990a453ee57f25b6554bad
  Stored in directory: /home/peter/.cache/pip/wheels/cd/9c/02/1c78322e6692d753ef839820d853e11679311f30eec26b3432
Successfully built sr.comp.http
Installing collected packages: sr.comp.http
  Attempting uninstall: sr.comp.http
    Found existing installation: sr.comp.http 0.0.0
    Uninstalling sr.comp.http-0.0.0:
      Successfully uninstalled sr.comp.http-0.0.0
Successfully installed sr.comp.http-0.0.0

run.py

app = Flask(__name__)

_find_package_path(import_name='sr.comp.http')
_find_package_path: root_mod_name='sr'
package_spec=ModuleSpec(name='sr.comp.http', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7b2244ea6c50>, origin='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http/__init__.py', submodule_search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http'])
package_path=PosixPath('/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http')
search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr']
os.path.dirname(search_location)='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages'
app = Flask('sr.comp.http')

_find_package_path(import_name='sr.comp.http')
_find_package_path: root_mod_name='sr'
package_spec=ModuleSpec(name='sr.comp.http', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7b2244ea6c50>, origin='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http/__init__.py', submodule_search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http'])
package_path=PosixPath('/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http')
search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr']
os.path.dirname(search_location)='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages'

/run.py

Obtaining file:///home/peter/play/flask-play/flask-app
  Installing build dependencies ... done
  Checking if build backend supports build_editable ... done
  Getting requirements to build editable ... done
  Preparing editable metadata (pyproject.toml) ... done
Requirement already satisfied: Flask>=2.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from sr.comp.http==0.0.0) (3.1.2)
Requirement already satisfied: blinker>=1.9.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (1.9.0)
Requirement already satisfied: click>=8.1.3 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (8.3.1)
Requirement already satisfied: itsdangerous>=2.2.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (2.2.0)
Requirement already satisfied: jinja2>=3.1.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.6)
Requirement already satisfied: markupsafe>=2.1.1 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.0.3)
Requirement already satisfied: werkzeug>=3.1.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.5)
Building wheels for collected packages: sr.comp.http
  Building editable for sr.comp.http (pyproject.toml) ... done
  Created wheel for sr.comp.http: filename=sr_comp_http-0.0.0-0.editable-py3-none-any.whl size=3459 sha256=a216bf634bddcae47327c746fe989a8a4115384810f305d565bb098311dbaeaa
  Stored in directory: /tmp/pip-ephem-wheel-cache-6dk2qx5_/wheels/cd/9c/02/1c78322e6692d753ef839820d853e11679311f30eec26b3432
Successfully built sr.comp.http
Installing collected packages: sr.comp.http
  Attempting uninstall: sr.comp.http
    Found existing installation: sr.comp.http 0.0.0
    Uninstalling sr.comp.http-0.0.0:
      Successfully uninstalled sr.comp.http-0.0.0
Successfully installed sr.comp.http-0.0.0

run.py

app = Flask(__name__)

_find_package_path(import_name='sr.comp.http')
_find_package_path: root_mod_name='sr'
package_spec=ModuleSpec(name='sr.comp.http', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7e0760a89f90>, origin='/home/peter/play/flask-play/flask-app/sr/comp/http/__init__.py', submodule_search_locations=['/home/peter/play/flask-play/flask-app/sr/comp/http'])
package_path=PosixPath('/home/peter/play/flask-play/flask-app/sr/comp/http')
search_locations=[]
Traceback (most recent call last):
  File ""/home/peter/play/flask-play/run.py"", line 6, in <module>
    from sr.comp.http import app
  File ""/home/peter/play/flask-play/flask-app/sr/comp/http/__init__.py"", line 5, in <module>
    app = Flask(__name__)
          ^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/app.py"", line 239, in __init__
    super().__init__(
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 304, in __init__
    instance_path = self.auto_find_instance_path()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 518, in auto_find_instance_path
    prefix, package_path = find_package(self.import_name)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 783, in find_package
    package_path = _find_package_path(import_name)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 748, in _find_package_path
    search_location = next(
                      ^^^^^
StopIteration

```

</details>


Environment:

- Python version: 3.11 (and others)
- Flask version: 3.1.2, also 2.x
",given package us namespace packaging installed using editable installs flask scaffold specifically findpackagepath error name passed flask package name rather submodule affect case name name package thus potentially actually name though also happens using name app defined within initpy root namespaced package notably issue appears importing app elsewhere running python process launched parent namespace package tree hide example project flaskapp setuppy comp http initpy initpyi initpyi runpy initpyi file empty shouldnt needed however present original project typing marker python runpy print printrunpy print srcomphttp import app print printrunpy print python flaskappsrcomp flask import flask printapp flaskname app flaskname reproduces defined initpy printapp flasksrcomp app flasksrcomp reproduces defined serverpy app reexported via initpy latter case original case route def hello return hello world detail summarycodeflaskappsetuppycodesummary python flaskappsetuppy setuptools import findnamespacepackages setup setup namesrcomp packagesfindnamespacepackagesincludesr namespacepackagessr srcomp installrequires flask detail error traceback recent call last file homepeterplayflaskplayrunpy line module srcomphttp import app file homepeterplayflaskplayflaskappsrcomp line module app flaskname file homepetervirtualenvsflaskplaylibpythonsitepackagesflaskapppy line init superinit file homepetervirtualenvsflaskplaylibpythonsitepackagesflasksansioapppy line init instancepath selfautofindinstancepath file homepetervirtualenvsflaskplaylibpythonsitepackagesflasksansioapppy line autofindinstancepath prefix packagepath findpackageselfimportname file homepetervirtualenvsflaskplaylibpythonsitepackagesflasksansioscaffoldpy line findpackage packagepath findpackagepathimportname file homepetervirtualenvsflaskplaylibpythonsitepackagesflasksansioscaffoldpy line findpackagepath searchlocation next stopiteration ive testing running following compare noneditable install shell pip install flaskapp python runpy pip install flaskapp python runpy ive also made modification flasksansioscaffoldpy debug provides insight look like issue whether packagepath found relative packagespecsubmodulesearchlocations detail summarycodescaffoldpycode diffsummary diff def findpackagepathimportname str str find path contains package module print printffindpackagepathimportname rootmodname importnamepartition printffindpackagepath rootmodname try rootspec importlibutilfindspecrootmodname module name invalid module name main raised valueerror due rootspec none printcwd return osgetcwd rootspecsubmodulesearchlocations rootspecorigin none rootspecorigin namespace namespace package packagespec importlibutilfindspecimportname printfpackagespec packagespec none packagespecsubmodulesearchlocations pick path namespace contains submodule packagepath pathlibpath ospathcommonpathpackagespecsubmodulesearchlocations printfpackagepath searchlocations location location rootspecsubmodulesearchlocations packagepathisrelativetolocation printfsearchlocations searchlocation next location location rootspecsubmodulesearchlocations else pick first path printpicking first path searchlocation rootspecsubmodulesearchlocations printfospathdirnamesearchlocation return ospathdirnamesearchlocation else package initpy printfpackage initpy ospathdirnameospathdirnamerootspecorigin return ospathdirnameospathdirnamerootspecorigin else module printfmodule ospathdirnamerootspecorigin return ospathdirnamerootspecorigin type ignoretypevar returnvalue detail detail summaryfull output scaffold printingsummary processing flaskapp installing build dependency done getting requirement build wheel done preparing metadata pyprojecttoml done requirement already satisfied flask homepetervirtualenvsflaskplaylibpythonsitepackages srcomp requirement already satisfied blinker homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied click homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied itsdangerous homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied jinja homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied markupsafe homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied werkzeug homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp building wheel collected package srcomphttp building wheel srcomphttp pyprojecttoml done created wheel srcomp filenamesrcomp size shafbefcbedfebceebafddaeefbbad stored directory homepetercachepipwheelscdccedefdefeecb successfully built srcomphttp installing collected package srcomphttp attempting uninstall srcomphttp found existing installation srcomphttp uninstalling srcomp successfully uninstalled srcomp successfully installed srcomp runpy app flaskname findpackagepathimportnamesrcomp findpackagepath rootmodnamesr packagespecmodulespecnamesrcomp loaderfrozenimportlibexternalsourcefileloader object xbeac originhomepetervirtualenvsflaskplaylibpythonsitepackagessrcomp submodulesearchlocationshomepetervirtualenvsflaskplaylibpythonsitepackagessrcomp packagepathposixpathhomepetervirtualenvsflaskplaylibpythonsitepackagessrcomp searchlocationshomepetervirtualenvsflaskplaylibpythonsitepackagessr ospathdirnamesearchlocationhomepetervirtualenvsflaskplaylibpythonsitepackages app flasksrcomp findpackagepathimportnamesrcomp findpackagepath rootmodnamesr packagespecmodulespecnamesrcomp loaderfrozenimportlibexternalsourcefileloader object xbeac originhomepetervirtualenvsflaskplaylibpythonsitepackagessrcomp submodulesearchlocationshomepetervirtualenvsflaskplaylibpythonsitepackagessrcomp packagepathposixpathhomepetervirtualenvsflaskplaylibpythonsitepackagessrcomp searchlocationshomepetervirtualenvsflaskplaylibpythonsitepackagessr ospathdirnamesearchlocationhomepetervirtualenvsflaskplaylibpythonsitepackages runpy obtaining filehomepeterplayflaskplayflaskapp installing build dependency done checking build backend support buildeditable done getting requirement build editable done preparing editable metadata pyprojecttoml done requirement already satisfied flask homepetervirtualenvsflaskplaylibpythonsitepackages srcomp requirement already satisfied blinker homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied click homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied itsdangerous homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied jinja homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied markupsafe homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp requirement already satisfied werkzeug homepetervirtualenvsflaskplaylibpythonsitepackages flasksrcomp building wheel collected package srcomphttp building editable srcomphttp pyprojecttoml done created wheel srcomp filenamesrcomp size shaabfbddcaecfeaafdbbdbaeaa stored directory tmppipephemwheelcachedkqxwheelscdccedefdefeecb successfully built srcomphttp installing collected package srcomphttp attempting uninstall srcomphttp found existing installation srcomphttp uninstalling srcomp successfully uninstalled srcomp successfully installed srcomp runpy app flaskname findpackagepathimportnamesrcomp findpackagepath rootmodnamesr packagespecmodulespecnamesrcomp loaderfrozenimportlibexternalsourcefileloader object xeaf originhomepeterplayflaskplayflaskappsrcomp submodulesearchlocationshomepeterplayflaskplayflaskappsrcomp packagepathposixpathhomepeterplayflaskplayflaskappsrcomp searchlocations traceback recent call last file homepeterplayflaskplayrunpy line module srcomphttp import app file homepeterplayflaskplayflaskappsrcomp line module app flaskname file homepetervirtualenvsflaskplaylibpythonsitepackagesflaskapppy line init superinit file homepetervirtualenvsflaskplaylibpythonsitepackagesflasksansioapppy line init instancepath selfautofindinstancepath file homepetervirtualenvsflaskplaylibpythonsitepackagesflasksansioapppy line autofindinstancepath prefix packagepath findpackageselfimportname file homepetervirtualenvsflaskplaylibpythonsitepackagesflasksansioscaffoldpy line findpackage packagepath findpackagepathimportname file homepetervirtualenvsflaskplaylibpythonsitepackagesflasksansioscaffoldpy line findpackagepath searchlocation next stopiteration detail environment python version others flask version also,Positivo,2
flask,5897,Issue,Comentario,"I can't reproduce this with the information provided. Thanks for providing a minimal example, but it's still a bit all over the place.

You're still using the old `setup.py` pattern, rather than using `pyproject.toml` with a `[build-system]` section. You're also using `namespace_packages`, which is the legacy pkg_resources pattern, and you're not calling the required legacy setup code in the init files, so installing your example gives an error `error in sr.comp.http setup command: Distribution contains no modules or packages for namespace package 'sr'`. You've also got an unsupported version of Flask listed, although it's just a lower bound, so the latest version gets installed.

Ignoring `namespace_packages` and just using `packages` (still with namespaces), both apps `__init__` and `server` work for me from `run.py` and with `flask run`. I think the problem is in your project configuration. Here's a modern update of your example that works:

<details>

```
example
‚îî‚îÄ‚îÄ run.py
‚îî‚îÄ‚îÄ app
    ‚îî‚îÄ‚îÄ pyproject.toml
    ‚îî‚îÄ‚îÄ src
        ‚îî‚îÄ‚îÄ sr
            ‚îî‚îÄ‚îÄ comp
                ‚îî‚îÄ‚îÄ http
                    ‚îî‚îÄ‚îÄ server.py
                    ‚îî‚îÄ‚îÄ __init__.py
```

`app/pyproject.toml`

```toml
[project]
name = ""sr.comp.http""
version = ""0.1.0""
description = """"
requires-python = "">=3.14""
dependencies = [
    ""flask"",
]

[build-system]
requires = [""uv_build>=0.9.26,<0.10.0""]
build-backend = ""uv_build""

[tool.uv.build-backend]
module-name = ""sr.comp.http""
```

`app/src/sr/comp/http/__init__.py`

```python
from flask import Flask

app = Flask(__name__)
```

`app/src/sr/comp/http/server.py`

```python
from flask import Flask

app = Flask(""sr.cmp.http"")
```

`run.py`

```python
from sr.comp.http import app

print(app.import_name)
```

```
uv venv
. ./.venv/bin/activate
uv pip install ./app
python run.py
```

You can examine `app/.venv/lib/python3.14/site-packages/sr` to confirm that it was installed as a namespace.

</details>",cant reproduce information provided thanks providing minimal example still bit place youre still using old setuppy pattern rather using pyprojecttoml buildsystem section youre also using namespacepackages legacy pkgresources pattern youre calling required legacy setup code init file installing example give error error srcomphttp setup command distribution contains module package namespace package youve also got unsupported version flask listed although lower bound latest version get installed ignoring namespacepackages using package still namespaces apps init server work runpy flask run think problem project configuration here modern update example work detail example runpy app pyprojecttoml src comp http serverpy initpy apppyprojecttoml toml project name srcomp version description requirespython dependency flask buildsystem requires uvbuild buildbackend uvbuild tooluvbuildbackend modulename srcomp appsrcsrcomp python flask import flask app flaskname appsrcsrcomp python flask import flask app flasksrcmp runpy python srcomphttp import app printappimportname venv venvbinactivate pip install app python runpy examine appvenvlibpythonsitepackagessr confirm installed namespace detail,Negativo,2
flask,5897,Issue,Comentario,@davidism thanks for looking at this and apologies if the cut-down wasn't clear. Just to check -- does your example still not reproduce the issue if the package is installed in editable mode? (i.e: `pip install -e ./app`) For me the issue only reproduces when the package is installed in editable mode.,thanks looking apology cutdown wasnt clear check example still reproduce issue package installed editable mode pip install app issue reproduces package installed editable mode,Positivo,2
flask,5897,Issue,Comentario,Still works.,still work,Neutral,3
flask,5897,Issue,Comentario,"Hrm, it turns out my original case also required a ""flat layout"" (rather than a ""src layout"") though that doesn't change anything when using a `pyproject.toml` based install. I think the conclusion here is that something about the newer style editable install sets up the paths differently, which lets the code work.

I'm not sure why you were unable to reproduce the issue, though I'm happy to accept that I need to bite the bullet and change the build system in use. Thanks for investigating.",hrm turn original case also required flat layout rather src layout though doesnt change anything using pyprojecttoml based install think conclusion something newer style editable install set path differently let code work sure unable reproduce issue though happy accept need bite bullet change build system use thanks investigating,Positivo,4
flask,5897,Issue,Comentario,"Without src works for me also. Your exact example works fine, minus the legacy config I mentioned. My example was just to show what I'd do now, since there were a lot of other legacy patterns being used. ",without src work also exact example work fine minus legacy config mentioned example show since lot legacy pattern used,Positivo,3
flask,5904,Pull Request,Titulo,Clarify data correctness explanation in quickstart,clarify data correctness explanation quickstart,Neutral,2
flask,5904,Pull Request,Descripcion,"Improved sentence clarity in the logging documentation without changing its meaning.
",improved sentence clarity logging documentation without changing meaning,Positivo,2
flask,5865,Pull Request,Titulo,Increase required flit_core version to 3.11,increase required flitcore version,Positivo,2
flask,5865,Pull Request,Descripcion,"Needed since Flask 3.1.1 after having set the ""license"" keyword to an SPDX license expression. Avoids this possible build error:

  flit_core.config.ConfigError: license field should be <class 'dict'>, not <class 'str'>

Fixes: 0109e496f (""use uv"").

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",needed since flask set license keyword spdx license expression avoids possible build error flitcoreconfigconfigerror license field class dict class str fix use opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5427,Issue,Titulo,Keep code running after response has been sent. (To respond with HTTP requests to other servers) ,keep code running response sent respond http request server,Neutral,2
flask,5427,Issue,Descripcion,"Ability to send a response but continue execution.

An example of this problem is a backend Flask server which receives requests from another backend server, and returns one or more responses at different points in time. One such example is Telegram API.

https://core.telegram.org/bots/faq#how-can-i-make-requests-in-response-to-updates

While it is possible to simply send data back as an HTTP response, it is sometimes desirable to close the HTTP connection with a 200 to acknowledge the message has been received, and reopen a new connection for each response.

Here are some scenarios where this technique might be useful:

- Multiple messages are sent in a progressively more detailed nature, to ensure that errors in complex responses don't compromise simple responses. For example Response(""Hello"") Response (""Error"") Response(""Error 194:blablabla"")
- Separating messages carry a semantic meaning. For example: Response(""Ok so here's the plan\n We leave at 9 am \n ..."") != Response(""Ok so here's the plan"") Response(""We leave at 9 am"") Response(""..."")
- Responses may be scheduled for the future, well after the http connection closes by timeout.

Can we solve this without a builtin? Yeah sure, we can use threading or multiprocessing or libraries like celery. 

I think that the ideal solution is to integrate the multi threading into existing flask multithreading (Main server loop), and ideally integrating it into production one worker process per hardware core configurations to avoid both GIL issues and one process per request overheads.


",ability send response continue execution example problem backend flask server receives request another backend server return one response different point time one example telegram api possible simply send data back http response sometimes desirable close http connection acknowledge message received reopen new connection response scenario technique might useful multiple message sent progressively detailed nature ensure error complex response dont compromise simple response example responsehello response error responseerror blablabla separating message carry semantic meaning example responseok here plann leave responseok here plan responsewe leave response response may scheduled future well http connection close timeout solve without builtin yeah sure use threading multiprocessing library like celery think ideal solution integrate multi threading existing flask multithreading main server loop ideally integrating production one worker process per hardware core configuration avoid gil issue one process per request overhead,Positivo,2
flask,5427,Issue,Comentario,"That's now how HTTP works. There's one response (status code / headers). Of course you can send/stream whatever you want in the body, but it doesn't sound like you want to do that...",thats http work there one response status code header course sendstream whatever want body doesnt sound like want,Negativo,2
flask,5427,Issue,Comentario,"Thanks for the response Adrian. 

I understand that each Request can only have one response. Not sure what would even happen if two responses are sent in response to one request, don't care.

What this thread is about is, recognizing that limitation, many server-to-server servers that need to send more than one response per request, effectively send nothing on the corresponding http response, but send new HTTP requests altogether, in all likelihood the responses of these second requests is ignored as well.

This image from the docs linked above should clarify

![image](https://github.com/pallets/flask/assets/153238260/fc0da526-2d31-4164-b2b3-f32b49306a28)

As you can see the traditional approach is diagrammed in 2. But the approach I'm referring to is diagrammed in 1. This allows multiple replies (Outgoing Request) per incoming request to the Flask server.
",thanks response adrian understand request one response sure would even happen two response sent response one request dont care thread recognizing limitation many servertoserver server need send one response per request effectively send nothing corresponding http response send new http request altogether likelihood response second request ignored well image doc linked clarify image see traditional approach diagrammed approach referring diagrammed allows multiple reply outgoing request per incoming request flask server,Negativo,2
flask,5427,Issue,Comentario,"This may be out of scope for flask, I will take a look into using Werkzeug directly, which may have a more native approach towards this, that may not even need threading, in essence we just want to (send a response/do stuff) without closing the inbound-request-thread.

It's just that in Flask sending an HTTP response and closing the request-thread seem to be tightly coupled.  Perhaps there is a way and I'm just ignorant of it. I typically send an http response returning from a function marked as a route, maybe there's something like flask.respond(200,""Hello"")

If not, that would be the ideal API flask.respond(status_code,body), function may be called respondAndContinue if you want to avoid confusion.",may scope flask take look using werkzeug directly may native approach towards may even need threading essence want send responsedo stuff without closing inboundrequestthread flask sending http response closing requestthread seem tightly coupled perhaps way ignorant typically send http response returning function marked route maybe there something like flaskrespondhello would ideal api flaskrespondstatuscodebody function may called respondandcontinue want avoid confusion,Positivo,2
flask,5427,Issue,Comentario,You're looking for a background task queue. https://flask.palletsprojects.com/en/3.0.x/patterns/celery/,youre looking background task queue,Neutral,2
flask,5427,Issue,Comentario,"I suppose one could import thousands of lines of code and add yet another layer of scheduling abstraction.

But I'd rather remove than add

",suppose one could import thousand line code add yet another layer scheduling abstraction rather remove add,Neutral,2
flask,5427,Issue,Comentario,This is a good use case for Quart and the background tasks.,good use case quart background task,Positivo,2
flask,5901,Issue,Titulo,Flask's blueprint's render templates rendering another blueprint's folder's html file !!!,flask blueprint render template rendering another blueprint folder html file,Neutral,2
flask,5901,Issue,Descripcion,"I was learning Flask & Web Application making.
I am getting the problem when i am return the render templates of a html file  in blueprint i am getting another blueprint's html file. 
I am sharing the screenshots here below and say what is the problem here.

<img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/1eeb056a-b53a-434b-ae46-e7e7712a448f"" />
See here in the render template at line 33, i wish it will render the `checking.html` file which is present in the `general_bp`'s folder.

<img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/f5e491bc-b5b0-43f5-aa9a-0517197f2e79"" />

<img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/1dd4ac18-26d5-4f9f-b587-a6f7256c60a1"" />

See here is the two `checking.html` file in different folder, but as i send the first image which should render the checking.html in the `general` folder it is rendering the `auth/checking.html` file.

<img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/ad73f9b2-7e6e-4a9f-859d-6ead96b846eb"" />
As you see when i open the `/checking` route it is always giving the `auth>checking.html` file.

I am not understanding why this is happening. is this any problem or i make any mistake here which cause the problem. Or anything i am doing wrong when i am in the `routes.py` file

what the wrong, maybe in different blueprint's folder i have same file name so why it is taking another file üò¢

what you can see any problem here?

Please try to give a solution to this.


Environment:
Linux > Ubuntu(Xubuntu)

UV Python 3.14.0

<img width=""587"" height=""475"" alt=""Image"" src=""https://github.com/user-attachments/assets/17f49e54-707d-4c36-8616-b31e897a51ca"" />",learning flask web application making getting problem return render template html file blueprint getting another blueprint html file sharing screenshots say problem img width height altimage src see render template line wish render checkinghtml file present generalbps folder img width height altimage src img width height altimage src see two checkinghtml file different folder send first image render checkinghtml general folder rendering authcheckinghtml file img width height altimage src see open checking route always giving authcheckinghtml file understanding happening problem make mistake cause problem anything wrong routespy file wrong maybe different blueprint folder file name taking another file see problem please try give solution environment linux ubuntuxubuntu python img width height altimage src,Negativo,2
flask,5901,Issue,Comentario,"https://flask.palletsprojects.com/en/stable/blueprints/#templates

Duplicate of #3747 and others",duplicate others,Neutral,2
flask,5901,Issue,Comentario,"I am attaching the current source code of the my repo's which was i just learning here.

This is the commit when i am seeing this problem the exact repo at the moment is below:

Please try to solve this issue

https://github.com/RanaUniverse/wishlist_web_app/tree/96db2bdc2bba5daed23277095d9be21ce5272275",attaching current source code repos learning commit seeing problem exact repo moment please try solve issue,Positivo,4
flask,5817,Issue,Titulo,asyncio is not compatible with gevent,asyncio compatible gevent,Neutral,3
flask,5817,Issue,Descripcion,"See #5256

async-await: <https://flask.palletsprojects.com/en/stable/async-await/>

> Using async with greenlet
> When using gevent or eventlet to serve an application or patch the runtime, greenlet>=1.0 is required. When using PyPy, PyPy>=7.3.7 is required.

Flask uses asgiref, which is not compatible with gevent: <https://github.com/django/asgiref/issues/443>


BTW:
ASGI: <https://flask.palletsprojects.com/en/stable/deploying/asgi/>

> The asgiref [WsgiToAsgi](https://github.com/django/asgiref#wsgi-to-asgi-adapter) adapter is recommended as it integrates with the event loop used for Flask‚Äôs [Using async and await](https://flask.palletsprojects.com/en/stable/async-await/#async-await) support.

This makes it seem like the event loop integration means a single worker could process multiple requests concurently, which it can't, the worker will block on `await`.

---

I'm not the only one that found this the hard way: [Flask, Gunicorn, Gevent and Asyncio Don't Mix](https://github.com/moogah/flask-gunicorn-gevent-asyncio/blob/29be08051cd663fa68d982f27232d2a5215a399c/README.md)
",see asyncawait using async greenlet using gevent eventlet serve application patch runtime greenlet required using pypy pypy required flask us asgiref compatible gevent btw asgi asgiref wsgitoasgi adapter recommended integrates event loop used flask using async await support make seem like event loop integration mean single worker could process multiple request concurently cant worker block await one found hard way flask gunicorn gevent asyncio dont mix,Positivo,3
flask,5817,Issue,Comentario,"~~Oh no, it actually works with uwsgi.~~
It doesn't work either with uwsgi
```
RuntimeError: You cannot use AsyncToSync in the same thread as an async event loop - just await the async function directly.
```",actually work uwsgi doesnt work either uwsgi runtimeerror cannot use asynctosync thread async event loop await async function directly,Negativo,3
flask,5817,Issue,Comentario,It would be helpful if you showed a minimal example of what you are using using that causes issues.,would helpful showed minimal example using using cause issue,Positivo,2
flask,5817,Issue,Comentario,"Look at the linked [flask-gunicorn-gevent-asyncio](https://github.com/moogah/flask-gunicorn-gevent-asyncio) repo.
Also check the attached reproducer in https://github.com/benoitc/gunicorn/issues/3070.",look linked flaskgunicorngeventasyncio repo also check attached reproducer,Neutral,2
flask,5817,Issue,Comentario,"Please include the example and relevant details here. A whole Docker container is not a minimal example. I also can't tell if you're talking about gevent alone, or uwsgi, or gunicorn, or something else. Please be specific about the exact issue you are reporting.",please include example relevant detail whole docker container minimal example also cant tell youre talking gevent alone uwsgi gunicorn something else please specific exact issue reporting,Positivo,3
flask,5817,Issue,Comentario,"> Please include the example [...] A whole Docker container is not a minimal example.

The dockerfile is completely optional, you just need python and pip to run the example in [flask-gunicorn-gevent-asyncio](https://github.com/moogah/flask-gunicorn-gevent-asyncio).

Here is the zip From the gunicorn issue: https://github.com/benoitc/gunicorn/files/12614245/reproduction.zip
It contains:
```
app.py
__init__.py
lots-of-curls.sh
requirements.txt
```

> I also can't tell if you're talking about gevent alone, or uwsgi, or gunicorn, or something else.

I'm talking about `gevent` + `asgiref` (`flask`'s async-await implementation).

`asgiref` does not support `gevent` ([ref](https://github.com/django/asgiref/issues/443)), so `flask[async]` cannot support `gevent`.
Which is fine, but then I have an issue with the docs having a ""Using async with greenlet"" section.",please include example whole docker container minimal example dockerfile completely optional need python pip run example flaskgunicorngeventasyncio zip gunicorn issue contains apppy initpy lotsofcurlssh requirementstxt also cant tell youre talking gevent alone uwsgi gunicorn something else talking gevent asgiref flask asyncawait implementation asgiref support gevent ref flaskasync cannot support gevent fine issue doc using async greenlet section,Negativo,3
flask,5817,Issue,Comentario,@pgjones could you take a look at this if you have a chance?,could take look chance,Positivo,2
flask,5817,Issue,Comentario,Continuing in #5881.,continuing,Neutral,2
flask,5881,Issue,Titulo,asgiref fails with gevent patching,asgiref fails gevent patching,Negativo,3
flask,5881,Issue,Descripcion,"When `gevent.monkey.patch_all()` is used, `async def` functions fail when multiple concurrent requests are sent. asgiref gives the error `RuntimeError: You cannot use AsyncToSync in the same thread as an async event loop - just await the async function directly.`. This suggests that somehow, gevent is causing a running loop to be visible across threads.

`example.py`:

```python
# /// script
# requires-python = ""~=3.14.0""
# dependencies = [
#     ""flask[async]"",
#     ""gevent"",
# ]
#
# [tool.uv]
# exclude-newer = ""2026-01-05T00:00:00Z""
#
# [tool.uv.sources]
# flask = { path = ""."", editable = true }
# ///

import gevent.monkey
gevent.monkey.patch_all()

import asyncio

from flask import Flask

app = Flask(__name__)

@app.get(""/"")
async def hello_world():
    await asyncio.sleep(0.5)
    return f""Hello, World!""
```

```
uv run --with-requirements example.py flask -A example.py run
```

`load.py`:

```python
# /// script
# requires-python = ""~=3.14.0""
# dependencies = [
#     ""httpx"",
# ]
#
# [tool.uv]
# exclude-newer = ""2026-01-05""
# ///

import asyncio
import httpx

async def get(i, client: httpx.AsyncClient):
    r = await client.get(""http://127.0.0.1:5000"")
    print(i, await r.aread())

async def main():
    async with httpx.AsyncClient() as client, asyncio.TaskGroup() as group:
        for i in range(50):
            group.create_task(get(i, client))

asyncio.run(main())
```

```
uv run load.py
```

Continues #5817 with more details.",geventmonkeypatchall used async def function fail multiple concurrent request sent asgiref give error runtimeerror cannot use asynctosync thread async event loop await async function directly suggests somehow gevent causing running loop visible across thread examplepy python script requirespython dependency flaskasync gevent tooluv excludenewer tooluvsources flask path editable true import geventmonkey geventmonkeypatchall import asyncio flask import flask app flaskname get async def helloworld await asynciosleep return fhello world run withrequirements examplepy flask examplepy run loadpy python script requirespython dependency tooluv excludenewer import asyncio import async def geti client await clientget printi await raread async def main async client asynciotaskgroup group range groupcreatetaskgeti client asynciorunmain run loadpy continues detail,Negativo,3
flask,5881,Issue,Comentario,asgiref uses `concurrent.futures.ThreadPoolExecutor` behind the scenes. Perhaps it's possible to override `Flask.async_to_sync` to spawn gevent threads or greenlets directly.,asgiref us concurrentfuturesthreadpoolexecutor behind scene perhaps possible override flaskasynctosync spawn gevent thread greenlets directly,Neutral,3
flask,5881,Issue,Comentario,"If you add an `after_request` callback, it doesn't cause issues, even though it's causing two threads to be spawned by `async_to_sync`. It only fails with concurrent requests, multiple threads for the same request isn't enough.

```python
@app.after_request
async def after(r):
    await asyncio.sleep(1)
    return r
```",add afterrequest callback doesnt cause issue even though causing two thread spawned asynctosync fails concurrent request multiple thread request isnt enough python afterrequest async def afterr await asynciosleep return,Negativo,3
flask,5881,Issue,Comentario,"https://github.com/gfmio/asyncio-gevent/issues/12#issuecomment-3058277636 seems relevant:

> asyncio expects there to be a single loop (per OS thread!).
>
> Before patching, threading.Thread creates a new OS thread and all is fine.
> 
> After patching, threading.Thread will create a new green thread / greenlet running on the same OS thread. Since there is now only one OS thread, attempting to create a second loop will raise an exception.",seems relevant asyncio expects single loop per thread patching threadingthread creates new thread fine patching threadingthread create new green thread greenlet running thread since one thread attempting create second loop raise exception,Positivo,3
flask,5881,Issue,Comentario,"Disclaimer, I do not have a solution to offer for this problem, but I wanted to share my understanding of the issue in case it helps.

The requirement for any gevent + asyncio solution to work well is that gevent runs in one thread, and asyncio runs in another thread. You can't have gevent and asyncio running on the same physical thread because then one loop would block the other.

What's happening when you run the example above is that the monkey patching prevents asgiref from launching a separate asyncio thread. It thinks it is launching a new thread, but due to the monkey patching it is launching a greenlet instead. So then the asyncio loop ends up running in the same physical thread as gevent, and this is bad even without the error messages.

I was actually able to get your example to run without errors only by commenting out the logic that raises the `RuntimeError` in asgiref. But this only masks the issue, it does not remove it. The correct solution would be for asgiref to somehow identify that it is running under a monkey patched gevent and figure out how to access the original unpatched threading module to launch a physical thread.",disclaimer solution offer problem wanted share understanding issue case help requirement gevent asyncio solution work well gevent run one thread asyncio run another thread cant gevent asyncio running physical thread one loop would block whats happening run example monkey patching prevents asgiref launching separate asyncio thread think launching new thread due monkey patching launching greenlet instead asyncio loop end running physical thread gevent bad even without error message actually able get example run without error commenting logic raise runtimeerror asgiref mask issue remove correct solution would asgiref somehow identify running monkey patched gevent figure access original unpatched threading module launch physical thread,Positivo,3
flask,5881,Issue,Comentario,"Yes that's what I was starting to figure out as well. I actually stripped asgiref out for a simple `threading.Thread` in `Flask.async_to_sync` to simplify things, and the problem still occurs. I was hoping to find some way to write `async_to_sync` using Gevent, but it doesn't seem possible with how asyncio and threads work. Tried asyncio-gevent `async_to_sync` as well, but it just freezes with concurrent requests. I also tried `gevent.monkey.patch_all(threading=False)`, but that fails as well.",yes thats starting figure well actually stripped asgiref simple threadingthread flaskasynctosync simplify thing problem still occurs hoping find way write asynctosync using gevent doesnt seem possible asyncio thread work tried asynciogevent asynctosync well freeze concurrent request also tried geventmonkeypatchallthreadingfalse fails well,Positivo,3
flask,5881,Issue,Comentario,"The reason we ever documented that `async` views work with gevent is probably because all the tests pass, and we never tested multiple concurrent requests. Individual requests do work, but that defeats the whole purpose of both.",reason ever documented async view work gevent probably test pas never tested multiple concurrent request individual request work defeat whole purpose,Negativo,3
flask,5881,Issue,Comentario,"> Individual requests do work

In my opinion this needs to be investigated to be sure that it is true in all cases. A simple async view function that just sleeps works, but a view function that does real async work could have interference from monkey-patched stuff in the standard library. For example, will you be able to launch a subprocess or use the process executor from the async function? Probably not, because `subprocess` is monkey-patched by gevent. Same for anything dealing with sockets or anything else that gevent monkey-patches and asyncio expects to be unpatched.

As I said above, after I commented out the `RuntimeError` in asgiref, your example runs cleanly for me. Asgiref by default runs only one asyncio thread for all the calls to `async_to_sync`, so under monkey-patching I see it create a single async loop inside a single greenlet. So at a high-level, this is all good, if you ignore that you now have a gevent loop and an asyncio loop competing with each other inside the same thread.",individual request work opinion need investigated sure true case simple async view function sleep work view function real async work could interference monkeypatched stuff standard library example able launch subprocess use process executor async function probably subprocess monkeypatched gevent anything dealing socket anything else gevent monkeypatches asyncio expects unpatched said commented runtimeerror asgiref example run cleanly asgiref default run one asyncio thread call asynctosync monkeypatching see create single async loop inside single greenlet highlevel good ignore gevent loop asyncio loop competing inside thread,Positivo,3
flask,5881,Issue,Comentario,"After experimenting today, here's a working `Flask.async_to_sync` that uses gevent. The load script completes in a little over the 1 second sleep. It also seems to work fine making an httpx async request within the view.

```python
# /// script
# requires-python = "">=3.14""
# dependencies = [
#     ""flask"",
#     ""gevent"",
#     ""httpx"",
# ]
#
# [tool.uv]
# exclude-newer = ""2026-01-05T00:00:00Z""
#
# [tool.uv.sources]
# flask = { path = ""."", editable = true }
# ///
import asyncio

from flask import Flask, request
import gevent.monkey
import gevent.selectors

gevent.monkey.patch_all()
loop = asyncio.EventLoop(gevent.selectors.DefaultSelector())
gevent.spawn(loop.run_forever)

class MyFlask(Flask):
    def async_to_sync(self, func):
        def run(*args, **kwargs):
            coro = func(*args, **kwargs)
            future = asyncio.run_coroutine_threadsafe(coro, loop)
            return future.result()

        return run

app = MyFlask(__name__)

@app.get(""/"")
async def greet():
    await asyncio.sleep(1)
    return f""Hello, {request.args.get(""name"", ""World"")}!""
```",experimenting today here working flaskasynctosync us gevent load script completes little second sleep also seems work fine making async request within view python script requirespython dependency flask gevent tooluv excludenewer tooluvsources flask path editable true import asyncio flask import flask request import geventmonkey import geventselectors geventmonkeypatchall loop asyncioeventloopgeventselectorsdefaultselector geventspawnlooprunforever class myflaskflask def asynctosyncself func def runargs kwargs coro funcargs kwargs future asyncioruncoroutinethreadsafecoro loop return futureresult return run app myflaskname get async def greet await asynciosleep return fhello requestargsgetname world,Positivo,3
flask,5881,Issue,Comentario,"And looking at `asyncio_gevent.EventLoop`, all it does is `asyncio.EventLoop(gevent.selectors.DefaultSelector())`, so that can be done directly, no need for the asyncio_gevent library for this. Updated the example above.",looking asynciogeventeventloop asyncioeventloopgeventselectorsdefaultselector done directly need asynciogevent library updated example,Negativo,2
flask,5881,Issue,Comentario,"Okay, I thought it was going to be easy to change your example and make it break, but after trying a few things I could not.

I have an updated theory of why this appears to work well. Both loops are still running in the same physical thread, but the asyncio loop is using a monkey-patched selector in its scheduler, so that allows it to coexist with the gevent scheduler, with both working cooperatively, and both using greenlet-based non-blocking waits.",okay thought going easy change example make break trying thing could updated theory appears work well loop still running physical thread asyncio loop using monkeypatched selector scheduler allows coexist gevent scheduler working cooperatively using greenletbased nonblocking wait,Positivo,3
flask,5881,Issue,Comentario,"Correction. This does appear to work with standard asyncio, but it hangs with uvloop. Below is a short demo. If you comment out the monkey patching, then the coroutine runs fine and you can Ctrl-C it.

```python
import gevent.monkey
gevent.monkey.patch_all()

import asyncio
import threading
import uvloop

uvloop.install()
loop = uvloop.loop.Loop()

threading.Thread(target=loop.run_forever).start()

async def count():
    for i in range(5):
        await asyncio.sleep(1)
        print(i)

asyncio.run_coroutine_threadsafe(count(), loop)
```

I don't have a Windows machine at hand right now. You should test on that OS, which uses a loop that is not based on selectors.",correction appear work standard asyncio hang uvloop short demo comment monkey patching coroutine run fine ctrlc python import geventmonkey geventmonkeypatchall import asyncio import threading import uvloop uvloopinstall loop uvlooplooploop threadingthreadtargetlooprunforeverstart async def count range await asynciosleep printi asyncioruncoroutinethreadsafecount loop dont window machine hand right test us loop based selector,Positivo,3
flask,5881,Issue,Comentario,"Oh, and also, I think passing the default selector as an argument when creating the loop is only necessary when you are not monkey patching. If you are monkey patching, the default selector is already the gevent one.",also think passing default selector argument creating loop necessary monkey patching monkey patching default selector already gevent one,Negativo,3
flask,5881,Issue,Comentario,"I don't think I'm going to integrate this directly into Flask, as it requires setting up the event loop externally ahead of time. I'd also prefer to avoid gevent-specific code paths.

I was thinking a new documentation page about using gevent in general and explaining the method override pattern. This would also provide an example of why `Flask.async_to_sync` is intended to be overridden, for other cases such as trio as well. If we figure anything out with uvloop, that can be shown as well.",dont think going integrate directly flask requires setting event loop externally ahead time also prefer avoid geventspecific code path thinking new documentation page using gevent general explaining method override pattern would also provide example flaskasynctosync intended overridden case trio well figure anything uvloop shown well,Positivo,3
flask,5881,Issue,Comentario,"It looks like gevent can use a libuv event loop. Presumably, you'd enable libuv in gevent rather than asyncio, and use the same pattern above. https://www.gevent.org/loop_impls.html",look like gevent use libuv event loop presumably youd enable libuv gevent rather asyncio use pattern,Positivo,3
flask,5881,Issue,Comentario,"Yep, after testing, putting the following at the top works. I have no idea how to tell if it's actually more performant than the default though.

```python
import gevent
gevent.config.loop = ""libuv""
```",yep testing putting following top work idea tell actually performant default though python import gevent geventconfigloop libuv,Positivo,3
flask,5900,Pull Request,Titulo,document using gevent for async,document using gevent async,Neutral,3
flask,5900,Pull Request,Descripcion,"closes #5881 

Adds a separate page about gevent. Shows examples of using asyncio and libuv. Removes mentions of eventlet, since the maintainers have indicated it is no longer recommended.",close add separate page gevent show example using asyncio libuv remove mention eventlet since maintainer indicated longer recommended,Negativo,3
flask,5896,Pull Request,Titulo,Cache compiled templates in render_template_string,cache compiled template rendertemplatestring,Neutral,2
flask,5896,Pull Request,Descripcion,"### Summary
`render_template_string` and `stream_template_string` now cache compiled templates, avoiding repeated compilation when the same source string is rendered multiple times.

The cache is stored per-app on the `Environment` instance with LRU eviction:
- `string_template_cache_size`: max 100 cached templates (configurable via class attribute)
- `string_template_cache_max_len`: templates longer than 100,000 characters are not cached

### Benchmark

The following script runs a server and computes how many requests can be received within 5 seconds.

```py
from threading import Thread
import requests, time, random
import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), ""src""))) # run this script within Flask's directory
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/template')
def t():
    return render_template_string('Hello, {{name}}',  name=request.args.get('q', ''))

def bench():
    time.sleep(1)  # wait for server
    n, end = 0, time.time() + 5
    s = requests.Session()
    while time.time() < end:
        s.get(f'http://127.0.0.1:6000/template?q={random.randint(0,10**6)}')
        n += 1
    print(f'\n{n} requests in 5s ({n/5:.0f} req/s)')
    import os; os._exit(0)

Thread(target=bench).start()
app.run(port=6000, threaded=True)
```

Without cache:
`5373 requests in 5s (1075 req/s)`

With cache:
`8603 requests in 5s (1721 req/s)`

8603/5373 = ~60% speed improvement

### Attribution
This optimization was initially generated using Optifiner AI, then cleaned up and validated manually by a human.",summary rendertemplatestring streamtemplatestring cache compiled template avoiding repeated compilation source string rendered multiple time cache stored perapp environment instance lru eviction stringtemplatecachesize max cached template configurable via class attribute stringtemplatecachemaxlen template longer character cached benchmark following script run server computes many request received within second threading import thread import request time random import sys import syspathinsert ospathabspathospathjoinospathdirnamefile src run script within flask directory flask import flask request rendertemplatestring app flaskname routetemplate def return rendertemplatestringhello name namerequestargsgetq def bench timesleep wait server end timetime requestssession timetime end sgetf printfnn request reqs import osexit threadtargetbenchstart apprunport threadedtrue without cache request reqs cache request reqs speed improvement attribution optimization initially generated using optifiner cleaned validated manually human,Positivo,2
flask,5896,Pull Request,Comentario,"Hi @davidism!

Noticed you edited out the link, totally fair, the plug was probably too aggressive. Though I'm unsure of the reason this PR was closed. I believe the performance gain are quite significant and universal, but this is also my first Flask PR, could you lmk whether I missed something? Would be very grateful.

Thanks!",noticed edited link totally fair plug probably aggressive though unsure reason closed believe performance gain quite significant universal also first flask could lmk whether missed something would grateful thanks,Positivo,4
flask,5896,Pull Request,Comentario,Stop using AI,stop using,Negativo,2
flask,5804,Issue,Titulo,3.1.2 regression: `stream_with_context` triggers `teardown_request()` calls before response generation,regression streamwithcontext trigger teardownrequest call response generation,Neutral,2
flask,5804,Issue,Descripcion,"<!--
This issue tracker is a tool to address bugs in Flask itself. Please use
GitHub Discussions or the Pallets Discord for questions about your own code.

Replace this comment with a clear outline of what the bug is.
-->

<!--
Describe how to replicate the bug.

Include a minimal reproducible example that demonstrates the bug.
Include the full traceback if there was an exception.
-->

<!--
Describe the expected behavior that should have happened but didn't.
-->
Hello,

I believe the changes to `stream_with_context()` in https://github.com/pallets/flask/pull/5799/commits/9822a0351574790cb66c652fcc396ad7aa2b09d8 introduced a bug where the `teardown_request()` callables are invoked too early in the request/response lifecycle (and actually invoked twice, before generating the response and a second time after the end of the request). Take the following example:

```python
# flask_teardown_stream_with_context.py
from flask import Flask, g, stream_with_context


def _teardown_request(_):
    print(""do_teardown_request() called"")
    g.pop(""hello"")


app = Flask(__name__)

app.teardown_request(_teardown_request)


@app.get(""/stream"")
def streamed_response():
    g.hello = ""world""

    def generate():
        print(""Starting to generate response"")
        yield f""<p>Hello {g.hello} !</p>""

    return stream_with_context(generate())


app.run(debug=True)
```

In 3.1.1:

```
% /tmp/venv/bin/flask --version           
Python 3.13.7
Flask 3.1.1
Werkzeug 3.1.3
% /tmp/venv/bin/python flask_teardown_stream_with_context.py 
[‚Ä¶]
Starting to generate response
127.0.0.1 - - [01/Sep/2025 16:07:05] ""GET /stream HTTP/1.1"" 200 -
do_teardown_request() called
```

In 3.1.2:

```
% /tmp/venv/bin/flask --version                             
Python 3.13.7
Flask 3.1.2
Werkzeug 3.1.3
% /tmp/venv/bin/python flask_teardown_stream_with_context.py
do_teardown_request() called
Starting to generate response
do_teardown_request() called
Debugging middleware caught exception in streamed response at a point where response headers were already sent.
Traceback (most recent call last):
  File ""/tmp/venv/lib/python3.13/site-packages/flask/helpers.py"", line 132, in generator
    yield from gen
  File ""/tmp/flask_teardown_stream_with_context.py"", line 21, in generate
    yield f""<p>Hello {g.hello} !</p>""
                      ^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 56, in __getattr__
    raise AttributeError(name) from None
AttributeError: hello

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/tmp/venv/lib/python3.13/site-packages/werkzeug/wsgi.py"", line 256, in __next__
    return self._next()
           ~~~~~~~~~~^^
  File ""/tmp/venv/lib/python3.13/site-packages/werkzeug/wrappers/response.py"", line 32, in _iter_encoded
    for item in iterable:
                ^^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/helpers.py"", line 130, in generator
    with app_ctx, req_ctx:
                  ^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 443, in __exit__
    self.pop(exc_value)
    ~~~~~~~~^^^^^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 410, in pop
    self.app.do_teardown_request(exc)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/app.py"", line 1356, in do_teardown_request
    self.ensure_sync(func)(exc)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^
  File ""/tmp/flask_teardown_stream_with_context.py"", line 7, in _teardown_request
    g.pop(""hello"")
    ~~~~~^^^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 88, in pop
    return self.__dict__.pop(name)
           ~~~~~~~~~~~~~~~~~^^^^^^
KeyError: 'hello'
127.0.0.1 - - [01/Sep/2025 16:09:35] ""GET /stream HTTP/1.1"" 200 -
```

Specifically,

```
do_teardown_request() called
Starting to generate response
do_teardown_request() called
```

So `_teardown_request()` is called before flask start to iterate on the response generator.

This is a simplified version of our own code; I'm not sure we can actually expect `g` to still be available during response generators, but given it worked in 3.1.1 and the phrasing / intent of `teardown_request()`, I'd expect it not to be called before the response is actually generated. Note also that removing the code which causes the error, i.e. the `g` access, and keeping just the `print()` for debugging, will still show `_teardown_request()` being called twice.

It's not obvious to me where exactly the bug is triggered. Adding a `traceback.print_stack()` call to `_teardown_request()`:
* in 3.1.1, the only call, once the request is done, is triggered by https://github.com/pallets/flask/blob/7fff56f5172c48b6f3aedf17ee14ef5c2533dfd1/src/flask/helpers.py#L115 ‚áí https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/ctx.py#L443 
* in 3.1.2, the (new) first call before entering the response generator is triggered by https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/app.py#L1527 ; the second is similar to 3.1.1, i.e. https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/helpers.py#L130 ‚áí https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/ctx.py#L443

Environment:

- Python version: 3.13
- Flask version: 3.1.2
",issue tracker tool address bug flask please use github discussion pallet discord question code replace comment clear outline bug describe replicate bug include minimal reproducible example demonstrates bug include full traceback exception describe expected behavior happened didnt hello believe change streamwithcontext introduced bug teardownrequest callables invoked early requestresponse lifecycle actually invoked twice generating response second time end request take following example python flaskteardownstreamwithcontextpy flask import flask streamwithcontext def teardownrequest printdoteardownrequest called gpophello app flaskname appteardownrequestteardownrequest getstream def streamedresponse ghello world def generate printstarting generate response yield fphello ghello return streamwithcontextgenerate apprundebugtrue tmpvenvbinflask version python flask werkzeug tmpvenvbinpython flaskteardownstreamwithcontextpy starting generate response sep get stream doteardownrequest called tmpvenvbinflask version python flask werkzeug tmpvenvbinpython flaskteardownstreamwithcontextpy doteardownrequest called starting generate response doteardownrequest called debugging middleware caught exception streamed response point response header already sent traceback recent call last file tmpvenvlibpythonsitepackagesflaskhelperspy line generator yield gen file tmpflaskteardownstreamwithcontextpy line generate yield fphello ghello file tmpvenvlibpythonsitepackagesflaskctxpy line getattr raise attributeerrorname none attributeerror hello handling exception another exception occurred traceback recent call last file tmpvenvlibpythonsitepackageswerkzeugwsgipy line next return selfnext file tmpvenvlibpythonsitepackageswerkzeugwrappersresponsepy line iterencoded item iterable file tmpvenvlibpythonsitepackagesflaskhelperspy line generator appctx reqctx file tmpvenvlibpythonsitepackagesflaskctxpy line exit selfpopexcvalue file tmpvenvlibpythonsitepackagesflaskctxpy line pop selfappdoteardownrequestexc file tmpvenvlibpythonsitepackagesflaskapppy line doteardownrequest selfensuresyncfuncexc file tmpflaskteardownstreamwithcontextpy line teardownrequest gpophello file tmpvenvlibpythonsitepackagesflaskctxpy line pop return selfdictpopname keyerror hello sep get stream specifically doteardownrequest called starting generate response doteardownrequest called teardownrequest called flask start iterate response generator simplified version code sure actually expect still available response generator given worked phrasing intent teardownrequest expect called response actually generated note also removing code cause error access keeping print debugging still show teardownrequest called twice obvious exactly bug triggered adding tracebackprintstack call teardownrequest call request done triggered new first call entering response generator triggered second similar environment python version flask version,Negativo,2
flask,5804,Issue,Comentario,"This will be fixed as a side effect of #5812 in 3.2. I'm not sure how to fix it in the mean time, without reintroducing the other issue, but I'm open to reviewing a PR if you can figure it out sooner.

I do understand how this is an issue, but note that the docs already call out that you can't make assumptions about how many times teardown functions will run or what will have or have not run before them. That's something you should address regardless of this being fixed.",fixed side effect sure fix mean time without reintroducing issue open reviewing figure sooner understand issue note doc already call cant make assumption many time teardown function run run thats something address regardless fixed,Negativo,2
flask,5804,Issue,Comentario,"> This will be fixed as a side effect of https://github.com/pallets/flask/pull/5812 in 3.2. I'm not sure how to fix it in the mean time

Seems like it does the trick indeed, thanks. The fact that it won't be fixed until then is not really an issue for us, I've just pinned flask to <3.1.2 until we can upgrade.

> the docs already call out that you can't make assumptions about how many times teardown functions will run or what will have or have not run before them

https://flask.palletsprojects.com/en/stable/reqcontext/#teardown-callbacks here ? It's not immediately obvious to me that they could run more than once, but even then this isn't the original issue we encountered, because our teardown callbacks are indeed idempotent ‚Äî the `g.pop()` was used here to exhibit the issue.

My issue was more around *when* it can be called: in this specific case, even before entering the generator passed to `stream_with_context()`. I wouldn't expect a teardown callback to be called at this point, considering `do_teardown_request()` is ¬´ Called after the request is dispatched and the response is returned ¬ª.",fixed side effect sure fix mean time seems like trick indeed thanks fact wont fixed really issue ive pinned flask upgrade doc already call cant make assumption many time teardown function run run immediately obvious could run even isnt original issue encountered teardown callback indeed idempotent gpop used exhibit issue issue around called specific case even entering generator passed streamwithcontext wouldnt expect teardown callback called point considering doteardownrequest called request dispatched response returned,Negativo,2
flask,5804,Issue,Comentario,Is there an expected release date for 3.2.0? We also encountered this problem in OTEL.,expected release date also encountered problem otel,Negativo,2
flask,5804,Issue,Comentario,"Hi I tested the code of @noirbee and indeed it does give the same error
(venv-flask) ‚ûú  flask git:(fix-streaming-teardown) ‚úó flask --version
Python 3.13.5
Flask 3.2.0.dev0
Werkzeug 3.1.3
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 140-638-840
Starting to generate response
127.0.0.1 - - [29/Sep/2025 23:09:47] ""GET /stream HTTP/1.1"" 200 -
do_teardown_request() called
do_teardown_request() called
Debugging middleware caught exception in streamed response at a point where response headers were already sent.
Traceback (most recent call last):
  File ""/Users/anand/Desktop/oss/flask/src/flask/app.py"", line 1500, in __call__
    return self.wsgi_app(environ, start_response)
           ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/anand/Desktop/oss/flask/src/flask/app.py"", line 1491, in wsgi_app
    ctx.pop(error)
    ~~~~~~~^^^^^^^
  File ""/Users/anand/Desktop/oss/flask/src/flask/ctx.py"", line 474, in pop
    self.app.do_teardown_request(exc)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^
  File ""/Users/anand/Desktop/oss/flask/src/flask/app.py"", line 1339, in do_teardown_request
    self.ensure_sync(func)(exc)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^
  File ""/Users/anand/Desktop/oss/flask/1.py"", line 7, in _teardown_request
    g.pop(""hello"")
    ~~~~~^^^^^^^^^
  File ""/Users/anand/Desktop/oss/flask/src/flask/ctx.py"", line 88, in pop
    return self.__dict__.pop(name)
           ~~~~~~~~~~~~~~~~~^^^^^^
KeyError: 'hello'


**But:** when I add decorator for streaming with context it works correctly

from flask import Flask, g, stream_with_context


def _teardown_request(_):
    print(""do_teardown_request() called"")
    g.pop(""hello"")

app = Flask(__name__)

app.teardown_request(_teardown_request)

@app.get(""/stream"")
def streamed_response():
    g.hello = ""world""

    @stream_with_context # change here
    def generate():
        print(""Starting to generate response"")
        yield f""<p>Hello {g.hello} !</p>""

    return stream_with_context(generate())

app.run(debug=True)

**Even** Replacing g.pop(""hello"") with g.pop(""hello"", None) works suggesting its being trying to popped multiple times and cant find hence error",tested code indeed give error venvflask flask gitfixstreamingteardown flask version python flask dev werkzeug running press ctrlc quit restarting stat debugger active debugger pin starting generate response sep get stream doteardownrequest called doteardownrequest called debugging middleware caught exception streamed response point response header already sent traceback recent call last file usersananddesktopossflasksrcflaskapppy line call return selfwsgiappenviron startresponse file usersananddesktopossflasksrcflaskapppy line wsgiapp ctxpoperror file usersananddesktopossflasksrcflaskctxpy line pop selfappdoteardownrequestexc file usersananddesktopossflasksrcflaskapppy line doteardownrequest selfensuresyncfuncexc file usersananddesktopossflaskpy line teardownrequest gpophello file usersananddesktopossflasksrcflaskctxpy line pop return selfdictpopname keyerror hello add decorator streaming context work correctly flask import flask streamwithcontext def teardownrequest printdoteardownrequest called gpophello app flaskname appteardownrequestteardownrequest getstream def streamedresponse ghello world change def generate printstarting generate response yield fphello ghello return streamwithcontextgenerate apprundebugtrue even replacing gpophello gpophello none work suggesting trying popped multiple time cant find hence error,Negativo,2
flask,5804,Issue,Comentario,"I think we should supress the error as a warning till the issue gets resolves as a side effect by wrapping the 
teardown call on the lines of:

from contextlib import suppress

def do_teardown_request(self, exc: BaseException | None = None) -> None:
    """"""Called after the request is dispatched and the response is finalized.""""""
    req = _cv_app.get().request

    for name in chain(req.blueprints, (None,)):
        if name in self.teardown_request_funcs:
            for func in reversed(self.teardown_request_funcs[name]):
                with suppress(KeyError):
                    self.ensure_sync(func)(exc)

    request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)
",think supress error warning till issue get resolve side effect wrapping teardown call line contextlib import suppress def doteardownrequestself exc baseexception none none none called request dispatched response finalized req cvappgetrequest name chainreqblueprints none name selfteardownrequestfuncs func reversedselfteardownrequestfuncsname suppresskeyerror selfensuresyncfuncexc requesttearingdownsendself asyncwrapperselfensuresync excexc,Negativo,2
flask,5804,Issue,Comentario,"sorry I am new to open source contribution so please forgive if formatting issues,",sorry new open source contribution please forgive formatting issue,Positivo,4
flask,5804,Issue,Comentario,"We are suffering the same issue with 3.1.2, and had to pin Flask to version < 3.1.2.
Did not quite get it: is this expected to be resolved in Flask 3.2.0? 
Thanks",suffering issue pin flask version quite get expected resolved flask thanks,Positivo,4
flask,5804,Issue,Comentario,"> is this expected to be resolved in Flask 3.2.0?

yes",expected resolved flask yes,Positivo,2
flask,5899,Pull Request,Titulo,deprecate `should_ignore_error`,deprecate shouldignoreerror,Neutral,2
flask,5899,Pull Request,Descripcion,closes #5816 ,close,Neutral,2
flask,5816,Issue,Titulo,deprecate `should_ignore_error`,deprecate shouldignoreerror,Neutral,2
flask,5816,Issue,Descripcion,"This was added in f1918093ac70d589a4d67af0d77140734c06c13d as part of the original code to keep the context around for use in the debugger, tests, etc. It was not part of a PR, and there's no linked issue or explanation on why it was added.

The intention seems to be to allow ignoring certain errors during debugging, so that cleanup is still run immediately. That's not how context preservation works anymore.  It also causes the exception to not be passed to teardown handlers, but there doesn't seem to be any reason to hide that, and handlers can already choose what to do if they're passed an error.

The method is only documented in the API, not in any other pages. There's no test for it. I have a feeling this isn't used. It results in an extra function call every single request, only to always return false. This can be deprecated then removed.",added facdadafdccd part original code keep context around use debugger test etc part there linked issue explanation added intention seems allow ignoring certain error debugging cleanup still run immediately thats context preservation work anymore also cause exception passed teardown handler doesnt seem reason hide handler already choose theyre passed error method documented api page there test feeling isnt used result extra function call every single request always return false deprecated removed,Negativo,2
flask,5816,Issue,Comentario,"@davidism Would you assign this to me?
I am interested in contributing to this.
",would assign interested contributing,Positivo,2
flask,5816,Issue,Comentario,"Thanks, however this type of task is not something for new contributors.",thanks however type task something new contributor,Positivo,4
flask,5816,Issue,Comentario,"Hi @davidism,
I‚Äôve been going through the context preservation and teardown logic in Flask and would love to contribute to this issue.
I understand this task was marked as not suitable for new contributors, but I have experience with Python internals and would like to work carefully under your guidance.

I‚Äôve already explored how should_ignore_error interacts with teardown handlers and can open a draft PR showing a safe deprecation path (with tests).

Would you be open to me working on this?",ive going context preservation teardown logic flask would love contribute issue understand task marked suitable new contributor experience python internals would like work carefully guidance ive already explored shouldignoreerror interacts teardown handler open draft showing safe deprecation path test would open working,Positivo,2
flask,5816,Issue,Comentario,"Hey, I can try and handle this issue. New to contribution, not software development lol. This issue has been open for over a month, I can definitely try and figure this one out. Currently unemployed with nothing better to do, and this one seems like it'll be a doozy and extremely fun for my brain to figure out.",hey try handle issue new contribution software development lol issue open month definitely try figure one currently unemployed nothing better one seems like itll doozy extremely fun brain figure,Positivo,2
flask,5844,Pull Request,Titulo,pre-commit: Add codespell,precommit add codespell,Neutral,2
flask,5844,Pull Request,Descripcion,"* #5833 on the `stable` branch.

The `stable` branch contains no codespell discoverable typos, but the default branch contains:
```
./docs/appcontext.rst:122: requet ==> request
./docs/quickstart.rst:465: interanlly ==> internally
./docs/templating.rst:186: avaialble ==> available
```

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",stable branch stable branch contains codespell discoverable typo default branch contains docsappcontextrst requet request docsquickstartrst interanlly internally docstemplatingrst avaialble available opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5825,Issue,Titulo,Document 415 on the receiving json section,document receiving json section,Neutral,1
flask,5825,Issue,Descripcion,"Documentation on ""json"" request throwing a 415 as well as 400.  

The problem text is on https://flask.palletsprojects.com/en/stable/patterns/javascript/#receiving-json-in-views

> Receiving JSON in Views
> 
> Use the [json](https://flask.palletsprojects.com/en/stable/api/#flask.Request.json) property of the [request](https://flask.palletsprojects.com/en/stable/api/#flask.request) object to decode the request‚Äôs body as JSON. If the body is not valid JSON, or the Content-Type header is not set to application/json, a 400 Bad Request error will be raised

I believe you want to indicate that it's a 415 instead of 400 when the Content-Type header doesn't match as it's done on https://flask.palletsprojects.com/en/stable/api/#flask.Request.json

400 is still valid for when the body isn't json (even though the content-type is json).

So maybe something like this ? 

> Receiving JSON in Views
>
> Use the [json](https://flask.palletsprojects.com/en/stable/api/#flask.Request.json) property of the [request](https://flask.palletsprojects.com/en/stable/api/#flask.request) object to decode the request‚Äôs body as JSON. If the body is not valid JSON, a 400 Bad Request error will be raised.  If the Content-Type header is not set to application/json, a 415 Unsupported Media Type error will be raised

Environment:

- Python version: N/A
- Flask version: latest doc



This is in no way a bug, but it's for being aligned everywhere in your doc :).  I'm just trying to make things better, I love the product ! thanks for the great work you've done ! ",documentation json request throwing well problem text receiving json view use json property request object decode request body json body valid json contenttype header set applicationjson bad request error raised believe want indicate instead contenttype header doesnt match done still valid body isnt json even though contenttype json maybe something like receiving json view use json property request object decode request body json body valid json bad request error raised contenttype header set applicationjson unsupported medium type error raised environment python version flask version latest doc way bug aligned everywhere doc trying make thing better love product thanks great work youve done,Positivo,1
flask,5825,Issue,Comentario,"Hi, I‚Äôd like to work on this documentation issue.I‚Äôll review the ‚Äúreceiving JSON‚Äù section and add clarification about when and why
a 415 (Unsupported Media Type) error occurs, along with an example if appropriate.

",like work documentation issueill review receiving json section add clarification unsupported medium type error occurs along example appropriate,Negativo,1
flask,5825,Issue,Comentario,"Hi üëã,
I'd like to work on improving this documentation section and submit a PR.
Please let me know if this issue is available or needs clarification.
",like work improving documentation section submit please let know issue available need clarification,Positivo,2
flask,5825,Issue,Comentario,"Hii ! I'd like to work on this issue by updating the documentation to clarify the 415 Unsupported Media Type behaviour when the Content-Type is not application/json.
Please let me know if that sounds good. ",hii like work issue updating documentation clarify unsupported medium type behaviour contenttype applicationjson please let know sound good,Positivo,1
flask,5825,Issue,Comentario,"Hi, I looked into this issue and it appears to be related to how Flask handles
request.get_json() when the Content-Type header is missing or incorrect.

From reading the documentation, the 415 error can occur when a request does
not specify 'application/json' or sends invalid JSON, but this behavior is
not clearly explained for users.

Adding a short explanation and a simple example to the
request.get_json() documentation (in docs/reqcontext.rst) should help
users understand why this error occurs and how to resolve it.

Please let me know if this approach makes sense before I proceed.
",looked issue appears related flask handle requestgetjson contenttype header missing incorrect reading documentation error occur request specify applicationjson sends invalid json behavior clearly explained user adding short explanation simple example requestgetjson documentation docsreqcontextrst help user understand error occurs resolve please let know approach make sense proceed,Positivo,1
flask,5827,Pull Request,Titulo,clarify 415 vs 400 errors for request.json,clarify error requestjson,Negativo,1
flask,5827,Pull Request,Descripcion,"## Description
Clarifies the distinction between 415 and 400 error codes when using `request.json`, aligning the JavaScript patterns documentation with the API reference.

## Changes
- Updated ""Receiving JSON in Views"" section to specify:
  - 400 Bad Request: for invalid JSON body
  - 415 Unsupported Media Type: for missing/incorrect Content-Type header
- Updated ""Making a Request with fetch"" section for consistency

## Fixes
Fixes #5825

## Checklist
- [x] Documentation updated
- [x] Changes align with existing API documentation",description clarifies distinction error code using requestjson aligning javascript pattern documentation api reference change updated receiving json view section specify bad request invalid json body unsupported medium type missingincorrect contenttype header updated making request fetch section consistency fix fix checklist documentation updated change align existing api documentation,Negativo,1
flask,5827,Pull Request,Comentario,"Hey @adityasah104, I see you have edited the line quite a bit. Why not to keep it as it is and just edit the error message?

As example:
Use the [json](https://flask.palletsprojects.com/en/stable/api/#flask.Request.json) property of the [request](https://flask.palletsprojects.com/en/stable/api/#flask.request) object to decode the request‚Äôs body as JSON. If the body is not valid JSON, or the Content-Type header is not set to application/json, a ~400 Bad Request~ 415 Unsupported Media Type error will be raised.


How about changing it this way? üôÇ",hey see edited line quite bit keep edit error message example use json property request object decode request body json body valid json contenttype header set applicationjson bad request unsupported medium type error raised changing way,Negativo,1
flask,5827,Pull Request,Comentario,"@lonelyH3b because that's not accurate, as described in the issue, in the PR description, and in the code.",thats accurate described issue description code,Neutral,2
flask,5827,Pull Request,Comentario,"Yes, got it ‚ù§Ô∏è",yes got,Positivo,2
flask,5827,Pull Request,Comentario,Thanks @davidism for clarifying! The PR is ready for review whenever you have time.,thanks clarifying ready review whenever time,Positivo,4
flask,5827,Pull Request,Comentario,@davidism Just wanted to gently follow up on this when you have a chance. Happy to make any additional changes if needed!,wanted gently follow chance happy make additional change needed,Positivo,2
flask,5808,Pull Request,Titulo,fix annotation for select_jinja_autoescape,fix annotation selectjinjaautoescape,Neutral,2
flask,5808,Pull Request,Descripcion,"Inside the code of the method the filename is checked against a None value and returns True, but the static annotated type is a str. I have changed the static annotation type to `str` to `str | None`.",inside code method filename checked none value return true static annotated type str changed static annotation type str str none,Positivo,4
flask,5808,Pull Request,Comentario,Is there anything required from my end to close this particular pull request,anything required end close particular pull request,Neutral,2
flask,5808,Pull Request,Comentario,"Hi Maintainers, is there anything I could do to get this PR resolved",maintainer anything could get resolved,Positivo,2
flask,5835,Pull Request,Titulo,Add Seenode deployment instructions to documentation,add seenode deployment instruction documentation,Neutral,2
flask,5835,Pull Request,Descripcion,"Hey. Just wanted to add seenode to the listed providers, as we have [first class support for flask](https://seenode.com/docs/frameworks/python/flask/). Thanks!
<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",hey wanted add seenode listed provider first class support flask thanks opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Positivo,0
flask,5835,Pull Request,Comentario,"Thanks, it's always great to see services supporting Flask.

However, at this time we don't plan on adding more services to this list, as it is difficult to keep updated and fair. You'll notice that around that list, the docs say:

> The links below are for some of the most common platforms

> This list is not exhaustive, and you should evaluate these and other services based on your application‚Äôs needs.

I'll keep this in mind if I do change my mind.",thanks always great see service supporting flask however time dont plan adding service list difficult keep updated fair youll notice around list doc say link common platform list exhaustive evaluate service based application need ill keep mind change mind,Positivo,4
flask,5845,Pull Request,Titulo,docs: Add explanation of reloader types and terminal output,doc add explanation reloader type terminal output,Neutral,2
flask,5845,Pull Request,Descripcion,"## Summary

This PR adds documentation explaining the different reloader types that Flask uses and the terminal output users see when running in debug mode.

## Problem

When running Flask with debug mode enabled, users see messages like:
- `* Restarting with stat`
- `* Restarting with watchdog (windowsapi)`
- `* Restarting with inotify`

These messages are never explained in the documentation, which can confuse users (especially beginners) who don't understand what they mean or why they appear.

## Changes

### `docs/server.rst`
- Added new ""Understanding the Reloader"" section explaining:
  - The two reloader backends (watchdog vs stat)
  - Why Flask chooses different backends automatically
  - What the platform-specific names mean (windowsapi, inotify, kqueue)
  - How to install watchdog for better performance
  - How to manually specify a reloader type if needed

### `docs/quickstart.rst`
- Added a note in the Debug Mode section that references the new server.rst section
- Helps users immediately understand the reloader output they see in the quickstart example

## Testing

- Verified reStructuredText syntax is correct
- Checked that internal documentation links work properly
- Confirmed the new content fits naturally with existing documentation structure

## Related

The installation docs already mention watchdog as an optional dependency, but don't explain what it does or when it's used. This PR bridges that gap.
",summary add documentation explaining different reloader type flask us terminal output user see running debug mode problem running flask debug mode enabled user see message like restarting stat restarting watchdog windowsapi restarting inotify message never explained documentation confuse user especially beginner dont understand mean appear change docsserverrst added new understanding reloader section explaining two reloader backends watchdog stat flask chooses different backends automatically platformspecific name mean windowsapi inotify kqueue install watchdog better performance manually specify reloader type needed docsquickstartrst added note debug mode section reference new serverrst section help user immediately understand reloader output see quickstart example testing verified restructuredtext syntax correct checked internal documentation link work properly confirmed new content fit naturally existing documentation structure related installation doc already mention watchdog optional dependency dont explain used bridge gap,Positivo,2
flask,5898,Pull Request,Titulo,redirect defaults to 303,redirect default,Neutral,2
flask,5898,Pull Request,Descripcion,closes #5895 ,close,Neutral,2
flask,5895,Issue,Titulo,change default redirect code to 303,change default redirect code,Neutral,2
flask,5895,Issue,Descripcion,"Flask and Werkzeug `redirect` currently defaults to a [302](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/302). Routing uses [307](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/307) since that preserves method consistently. We didn't change the `redirect` default to 307, since that would break the common pattern of ""GET form, POST form, redirect to GET result"", ending up doing ""POST result"" instead. [303](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/303) seems designed exactly for this pattern, so that a redirect always results in a GET, instead of preserving the method or only rewriting it sometimes. [HTMX actually calls this out about Flask.](https://hypermedia.systems/htmx-patterns/#:~:text=cleaner%2E-,A,resource)

I don't _think_ there would actually be a problem switching to 303 as the default. It would still do the expected thing for basic page redirects and form submission redirects. I would be really surprised if anyone was relying on the 302 behavior of only converting POST and nothing else. I don't even remember that being the behavior when we were switching to 307, and I would have switched to 303 instead of leaving 302 then if I had known about it.",flask werkzeug redirect currently default routing us since preserve method consistently didnt change redirect default since would break common pattern get form post form redirect get result ending post result instead seems designed exactly pattern redirect always result get instead preserving method rewriting sometimes htmx actually call flask dont think would actually problem switching default would still expected thing basic page redirects form submission redirects would really surprised anyone relying behavior converting post nothing else dont even remember behavior switching would switched instead leaving known,Negativo,2
flask,5885,Pull Request,Titulo,clarify async view incompatibility with gevent monkey patching,clarify async view incompatibility gevent monkey patching,Neutral,3
flask,5885,Pull Request,Descripcion,"@davidism Please Check 

 Closes #5881 


This PR adds documentation clarifying the limitations and unsupported nature of using Flask async views together with gevent monkey patching.

While simple async views may appear to work for individual requests, concurrent requests can fail due to conflicts between asyncio‚Äôs event loop assumptions and gevent‚Äôs greenlet-based threading model. The documentation explains why this behavior occurs, highlights failure modes that typically only appear under concurrency, and outlines recommended alternatives and advanced override considerations.

This change is documentation-only and is based on the investigation and conclusions discussed in the linked issue.
",please check close add documentation clarifying limitation unsupported nature using flask async view together gevent monkey patching simple async view may appear work individual request concurrent request fail due conflict asyncios event loop assumption gevents greenletbased threading model documentation explains behavior occurs highlight failure mode typically appear concurrency outline recommended alternative advanced override consideration change documentationonly based investigation conclusion discussed linked issue,Negativo,3
flask,5878,Pull Request,Titulo,Add hello.py for testing,add hellopy testing,Neutral,2
flask,5878,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5878,Pull Request,Comentario,Please stop abusing big public repos for random tests ,please stop abusing big public repos random test,Negativo,2
flask,5879,Pull Request,Titulo,Add GitHub Actions CI workflow,add github action workflow,Neutral,2
flask,5879,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5879,Pull Request,Comentario,"Please stop abusing other people's repos for random tests or learning how to use GitHub, this is not a playground.",please stop abusing people repos random test learning use github playground,Negativo,2
flask,5824,Pull Request,Titulo,Clarify asyncio and gevent incompatibility in docs (#5817),clarify asyncio gevent incompatibility doc,Neutral,3
flask,5824,Pull Request,Descripcion,"Updated the _async_await.rst documentation to clarify that Flask's asynchronous support
(using asgiref) is **not compatible with gevent or eventlet**. 

Added a recommendation to use ASGI servers like `uvicorn` or `hypercorn` 
for proper async support, giving users a clear alternative until issue #5817 
is addressed.
",updated asyncawaitrst documentation clarify flask asynchronous support using asgiref compatible gevent eventlet added recommendation use asgi server like uvicorn hypercorn proper async support giving user clear alternative issue addressed,Positivo,3
flask,5877,Pull Request,Titulo,Minor documentation,minor documentation,Neutral,2
flask,5877,Pull Request,Descripcion,"This PR  practicing open source contribution workflow.
",practicing open source contribution workflow,Neutral,4
flask,5877,Pull Request,Comentario,Do not use other's public repositories for practice. Also this change is in no way an improvement. ,use others public repository practice also change way improvement,Positivo,2
flask,5876,Pull Request,Titulo,docs: Upgrade HTTP links to HTTPS,doc upgrade http link,Neutral,2
flask,5876,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.
Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->
This PR upgrades several HTTP links to HTTPS in the documentation to ensure best security practices and avoid redirection.
- `docs/patterns/mongoengine.rst`: Upgraded `mongoengine.org` link.
- `docs/web-security.rst`: Upgraded example URL in security context.
<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.
fixes #<issue number>
-->
N/A (Documentation fix)
<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:
- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket upgrade several http link documentation ensure best security practice avoid redirection docspatternsmongoenginerst upgraded mongoengineorg link docswebsecurityrst upgraded example url security context link relevant issue previous pr one per line use fix automatically close issue fix issue number documentation fix ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Positivo,0
flask,5875,Pull Request,Titulo,docs: clarify 415 error when receiving JSON requests,doc clarify error receiving json request,Negativo,1
flask,5875,Pull Request,Descripcion,"This PR adds a short clarification to the ""APIs with JSON"" section in the
Flask quickstart documentation explaining when a 415 Unsupported Media Type
error can occur while receiving JSON requests.

The change explains that the error may be raised when the Content-Type
header is missing or incorrect, or when invalid JSON is sent, and provides
guidance on how to avoid it.
",add short clarification apis json section flask quickstart documentation explaining unsupported medium type error occur receiving json request change explains error may raised contenttype header missing incorrect invalid json sent provides guidance avoid,Negativo,1
flask,5873,Pull Request,Titulo,Clarify 415 Unsupported Media Type in JSON docs,clarify unsupported medium type json doc,Negativo,1
flask,5873,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5874,Pull Request,Titulo,Clarify 415 Unsupported Media in JSON docs,clarify unsupported medium json doc,Negativo,1
flask,5874,Pull Request,Descripcion,"Update the ‚ÄúReceiving JSON in Views‚Äù documentation to clarify that Flask returns
a 415 Unsupported Media Type error when the Content-Type is not application/json,
and a 400 Bad Request error for invalid JSON, as discussed in #5825.
",update receiving json view documentation clarify flask return unsupported medium type error contenttype applicationjson bad request error invalid json discussed,Negativo,1
flask,5871,Pull Request,Titulo,init,init,Neutral,2
flask,5871,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5870,Issue,Titulo,Teardown handler chain exception handling,teardown handler chain exception handling,Neutral,2
flask,5870,Issue,Descripcion,"Flask executes registered teardown handlers (used for closing DB connections, releasing locks, etc.) in a chain. The do_teardown_request method which is supposed to make these teardown requests does not wrap individual handlers in a try/except block. If one handler raises an exception, the loop terminates immediately, and all subsequent handlers are skipped, this can lead to the application to skip critical cleanup routines if a non critical one fails.

Sample reproduction code
```python
import threading
import time
import requests
from flask import Flask

app = Flask(__name__)

#a simulation of a limited resource pool
mock_db_connections = 0

@app.route('/')
def index():
    global mock_db_connections
    mock_db_connections = mock_db_connections + 1
    return ""Request Processed""

#simulating a critical teardown handler which is supposed to free resources from the db
@app.teardown_request
def critical_db_close(exc):
    global mock_db_connections
    mock_db_connections = mock_db_connections - 1

#teardown handler which can crash
@app.teardown_request
def buggy_extension(exc):
    raise Exception(""Crash in buggy extension!"")

def run_server():
    #just for clearner output
    import logging
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.ERROR)
    app.logger.disabled = True
    
    app.run(port=5000, threaded=True)

def verify_bug():
    
    print(f""Initial DB Connections: {mock_db_connections}"")
    
    try:
        requests.get('http://127.0.0.1:5000/')
    except Exception:
        pass

    #wait time to ensure teardown has happened in the other thread
    time.sleep(1)
    
    print(f""Final DB Connections: {mock_db_connections}"")
    
    if mock_db_connections > 0:
        print(""Teardown Chain Broken"")
    else:
        print(""Failed to reproduce"")

server_thread = threading.Thread(target=run_server, daemon=True)
server_thread.start()
verify_bug()
```",flask executes registered teardown handler used closing connection releasing lock etc chain doteardownrequest method supposed make teardown request wrap individual handler tryexcept block one handler raise exception loop terminates immediately subsequent handler skipped lead application skip critical cleanup routine non critical one fails sample reproduction code python import threading import time import request flask import flask app flaskname simulation limited resource pool mockdbconnections route def index global mockdbconnections mockdbconnections mockdbconnections return request processed simulating critical teardown handler supposed free resource teardownrequest def criticaldbcloseexc global mockdbconnections mockdbconnections mockdbconnections teardown handler crash teardownrequest def buggyextensionexc raise exceptioncrash buggy extension def runserver clearner output import logging log logginggetloggerwerkzeug logsetlevelloggingerror apploggerdisabled true apprunport threadedtrue def verifybug printfinitial connection mockdbconnections try requestsget except exception pas wait time ensure teardown happened thread timesleep printffinal connection mockdbconnections mockdbconnections printteardown chain broken else printfailed reproduce serverthread threadingthreadtargetrunserver daemontrue serverthreadstart verifybug,Negativo,2
flask,5870,Issue,Comentario,"From the [docs](https://flask.palletsprojects.com/en/stable/reqcontext/#teardown-callbacks) about teardown callbacks:

> Be sure to write these functions in a way that does not depend on other callbacks and will not fail.

Teardown happens after the response has already started, so there's no way to indicate that there was a server error at that point except by crashing. If we silently ignored exceptions in these handlers, the app could end up in an unexpected state.",doc teardown callback sure write function way depend callback fail teardown happens response already started there way indicate server error point except crashing silently ignored exception handler app could end unexpected state,Negativo,2
flask,5869,Pull Request,Titulo,Document 415 Unsupported Media Type for JSON requests,document unsupported medium type json request,Negativo,1
flask,5869,Pull Request,Descripcion,"This adds a short note to the Incoming Request Data documentation explaining
when Flask may return a 415 Unsupported Media Type error if JSON requests are
missing or have an incorrect Content-Type header.
",add short note incoming request data documentation explaining flask may return unsupported medium type error json request missing incorrect contenttype header,Negativo,1
flask,5868,Pull Request,Titulo,Improve exception handler in wsgi_app method,improve exception handler wsgiapp method,Positivo,2
flask,5868,Pull Request,Descripcion,"This change replaces the bare except clause with an explicit BaseException 
handler for better code clarity and to avoid potential issues with 
sys.exc_info().

The previous code used a bare except: clause with sys.exc_info()[1] which 
is discouraged in Python. This change makes the exception handling more 
explicit by catching BaseException directly, which includes KeyboardInterrupt 
and SystemExit that should not be handled by the normal exception handler.

All existing tests pass successfully.",change replaces bare except clause explicit baseexception handler better code clarity avoid potential issue sysexcinfo previous code used bare except clause sysexcinfo discouraged python change make exception handling explicit catching baseexception directly includes keyboardinterrupt systemexit handled normal exception handler existing test pas successfully,Positivo,2
flask,5867,Pull Request,Titulo,Deprecate should_ignore_error method,deprecate shouldignoreerror method,Neutral,2
flask,5867,Pull Request,Descripcion,"The `should_ignore_error()` method was added in f191809 to support context preservation for debugging, but it no longer serves its original purpose and adds unnecessary overhead.

Issues with the current implementation:
- Always returns False by default
- Called on every single request with no benefit
- The original intention for error ignoring during debugging is not how context preservation works anymore
- No documentation beyond API reference
- No tests for the functionality
- No evidence of real-world usage

Changes:
- Add deprecation warning to App.should_ignore_error() that will be removed in Flask 4.0
- Optimize call site to only invoke the method if it's been overridden by a subclass, eliminating the function call overhead for 99.9% of requests
- Add comprehensive tests for the deprecation behavior
- Update CHANGES.rst with deprecation notice

Teardown handlers should manage their own error handling instead of relying on this method.

Fixes #5816

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",shouldignoreerror method added support context preservation debugging longer serf original purpose add unnecessary overhead issue current implementation always return false default called every single request benefit original intention error ignoring debugging context preservation work anymore documentation beyond api reference test functionality evidence realworld usage change add deprecation warning appshouldignoreerror removed flask optimize call site invoke method overridden subclass eliminating function call overhead request add comprehensive test deprecation behavior update changesrst deprecation notice teardown handler manage error handling instead relying method fix opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5867,Pull Request,Comentario,why do I have the feeling that you used an LLM to create this PR?,feeling used llm create,Positivo,2
flask,5866,Pull Request,Titulo,Clarify JSON request errors: 400 vs 415,clarify json request error,Negativo,1
flask,5866,Pull Request,Descripcion,"This updates the ""Receiving JSON in Views"" section to correctly distinguish between:
- 400 Bad Request: raised when the body is not valid JSON
- 415 Unsupported Media Type: raised when the Content-Type header is not application/json

This aligns the documentation with Flask's actual behavior and makes it clearer for users.",update receiving json view section correctly distinguish bad request raised body valid json unsupported medium type raised contenttype header applicationjson aligns documentation flask actual behavior make clearer user,Negativo,1
flask,5872,Pull Request,Titulo,Fixed error code documentation for request.json,fixed error code documentation requestjson,Negativo,1
flask,5872,Pull Request,Descripcion,"Fix error code documentation for request.json

Clarify that a 415 error is raised when Content-Type is incorrect,
while a 400 error is raised when the body is not valid JSON.

This aligns the patterns documentation with the API reference at
https://flask.palletsprojects.com/en/stable/api/#flask.Request.json

Changes Made
Updated `docs/patterns/javascript.rst` in the ""Receiving JSON in Views""
section to correctly distinguish between:

400 Bad Request: Raised when the request body is not valid JSON
415 Unsupported Media Type: Raised when Content-Type header is not
set to application/json

Previously, the documentation incorrectly stated that both scenarios
would raise a 400 error.

fixes #5825",fix error code documentation requestjson clarify error raised contenttype incorrect error raised body valid json aligns pattern documentation api reference change made updated docspatternsjavascriptrst receiving json view section correctly distinguish bad request raised request body valid json unsupported medium type raised contenttype header set applicationjson previously documentation incorrectly stated scenario would raise error fix,Negativo,1
flask,5872,Pull Request,Comentario,"Hi David, 

I wanted to verify whether the issue addressed in my PR has already been resolved somewhere else? I noticed the PR was closed and would appreciate any context or guidance on the reason.",david wanted verify whether issue addressed already resolved somewhere else noticed closed would appreciate context guidance reason,Positivo,2
flask,5872,Pull Request,Comentario,"There's already an open PR. You're approximately the 10th person not to notice that. You also asked an AI to do it for you, and it slopped out a huge unnecessary description. ",there already open youre approximately person notice also asked slopped huge unnecessary description,Positivo,2
flask,5872,Pull Request,Comentario,"I just wanted to point that this is my first attempt to a contribution as an aspiring open source developer. My description was for the sole purpose of indicating the changes following the template that was given when creating the PR. I thoroughly reviewed the updated Flask API documentation before submitting my solution with the use of AI. 

Additionally, It seems like the issue was already resolved in an open PR (#5827). Closing it would help prevent others like ```myself``` from continuing to work on it unintentionally. ",wanted point first attempt contribution aspiring open source developer description sole purpose indicating change following template given creating thoroughly reviewed updated flask api documentation submitting solution use additionally seems like issue already resolved open closing would help prevent others like continuing work unintentionally,Positivo,2
flask,5872,Pull Request,Comentario,"From our [contributing guide](https://palletsprojects.com/contributing/#what-to-work-on):

> Before starting, check if anyone else is assigned to the issue, or if there are any linked open pull requests. Look through the issue for that information as well as discussion and other linked issues for context.

Also, this was a one sentence change, and _that sentence was already written_ in the issue. There was absolutely no reason to waste resources using an LLM to do a copy paste.",contributing guide starting check anyone else assigned issue linked open pull request look issue information well discussion linked issue context also one sentence change sentence already written issue absolutely reason waste resource using llm copy paste,Negativo,2
flask,5859,Pull Request,Titulo,Create test,create test,Positivo,2
flask,5859,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5859,Pull Request,Comentario,do not use other people's repos for testing.,use people repos testing,Neutral,2
flask,5860,Pull Request,Titulo,Fix documentation for JSON error codes,fix documentation json error code,Negativo,1
flask,5860,Pull Request,Descripcion,"## Description

This PR fixes the documentation for JSON error handling in the ""Receiving JSON in Views"" section to correctly distinguish between different HTTP error codes.

## Changes

- Updated `docs/patterns/javascript.rst`
- Changed documentation to show:
  - `400 Bad Request` for invalid JSON content
  - `415 Unsupported Media Type` for wrong Content-Type header

## Before
`If the body is not valid JSON, or the Content-Type header is not set to application/json, a 400 Bad Request error will be raised.`

## After
`If the body is not valid JSON, a 400 Bad Request error will be raised. If the Content-Type header is not set to application/json, a 415 Unsupported Media Type error will be raised.`

## Fixes 
#5825

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",description fix documentation json error handling receiving json view section correctly distinguish different http error code change updated docspatternsjavascriptrst changed documentation show bad request invalid json content unsupported medium type wrong contenttype header body valid json contenttype header set applicationjson bad request error raised body valid json bad request error raised contenttype header set applicationjson unsupported medium type error raised fix opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,1
flask,5858,Pull Request,Titulo,"Refactor __init__.py module to improve organization, readability and public API structure",refactor initpy module improve organization readability public api structure,Positivo,2
flask,5858,Pull Request,Descripcion,"### Description:

This Pull Request introduces a structured refactoring of the src/flask/__init__.py file, aiming to improve internal organization and clarify the definition of the framework‚Äôs public API.
The modifications do not change runtime behavior but make the module more consistent, cleaner and aligned with architecture and style best practices.

### Changes implemented:

- Fully reorganized imports, grouping them by source (standard library, third-party, internal modules).
- Removed redundant or unused imports.
- Improved __all__ export structure to clearly define the public API.
- Added comments explaining the module‚Äôs responsibility as a high-level interface aggregator.
- Reduced visual noise and increased cohesion.
- Formatting and style adjustments aligned with tools like Flake8 and Pylint.

### Motivation:

The __init__.py file acts as the main entry point for the Flask package, exposing the symbols developers interact with.
Before refactoring, the file contained inconsistencies in import ordering, export grouping and general structure.

### These improvements:

- increase the clarity of the public API;
- make the codebase easier to navigate and maintain;
- reduce style violations (E401, F401, E302, etc.);
- decrease cognitive coupling and prepare the ground for deeper refactoring in critical modules such as app.py.
- Expected impact on metrics:
- Readability: improved through organized imports and structural cleanup.
- Cohesion: increased by keeping the module focused on API aggregation.
- Cognitive coupling: reduced due to clearer responsibilities.
- Flake8 violations: expected reduction in F401 (unused imports) and E501 (line length issues).

",description pull request introduces structured refactoring srcflaskinitpy file aiming improve internal organization clarify definition framework public api modification change runtime behavior make module consistent cleaner aligned architecture style best practice change implemented fully reorganized import grouping source standard library thirdparty internal module removed redundant unused import improved export structure clearly define public api added comment explaining module responsibility highlevel interface aggregator reduced visual noise increased cohesion formatting style adjustment aligned tool like flake pylint motivation initpy file act main entry point flask package exposing symbol developer interact refactoring file contained inconsistency import ordering export grouping general structure improvement increase clarity public api make codebase easier navigate maintain reduce style violation etc decrease cognitive coupling prepare ground deeper refactoring critical module apppy expected impact metric readability improved organized import structural cleanup cohesion increased keeping module focused api aggregation cognitive coupling reduced due clearer responsibility flake violation expected reduction unused import line length issue,Positivo,2
flask,5858,Pull Request,Comentario,This is useless LLM junk. Do not waste maintainer time. ,useless llm junk waste maintainer time,Negativo,2
flask,5858,Pull Request,Comentario,"Hey! Sorry for the inconvenience. I was studying ways to improve Flask for a university assignment. I apologize again ‚Äî it wasn‚Äôt my intention to disrupt your progress. Best regards, and once again, sorry¬†about¬†that.",hey sorry inconvenience studying way improve flask university assignment apologize wasnt intention disrupt progress best regard sorry,Positivo,2
flask,5858,Pull Request,Comentario,Then your professor failed you in not teaching you how to contribute. Please tell your professor that maintainers want them to stop assigning this.,professor failed teaching contribute please tell professor maintainer want stop assigning,Negativo,2
flask,5863,Issue,Titulo,Modern CSRF Protection Using `Sec-Fetch-Site` Header,modern csrf protection using secfetchsite header,Neutral,2
flask,5863,Issue,Descripcion,"Flask's documentation states that CSRF protection requires a form validation framework (which Flask doesn't provide), necessitating one-time tokens stored in cookies and transmitted with form data. However, modern browsers now support `Sec-Fetch-Site` headers, making token-based CSRF protection unnecessary. Rails just merged this approach in [rails/rails#56350](https://github.com/rails/rails/pull/56350). Flask should offer a similar modern solution‚Äîbut in a more Flask-like way: as a simple argument to `@app.route()`.

## Current State

From Flask's security documentation:

> ""Why does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask.""

This was written when CSRF tokens were the only viable protection mechanism. That's no longer true. And with header-based protection, no form validation framework is needed‚Äîjust a simple check before dispatching to the view.

## The Modern Approach

The `Sec-Fetch-Site` header is a [Fetch Metadata Request Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site) that modern browsers send automatically. It indicates the relationship between the request origin and the target origin:

- `same-origin`: Request from the same origin (same scheme, host, and port)
- `same-site`: Request from the same site but different origin
- `cross-site`: Request from a completely different site
- `none`: User-initiated navigation (typing URL, bookmark, etc.)

For state-changing requests (POST, PUT, DELETE, PATCH), we can simply reject requests where `Sec-Fetch-Site` is `cross-site`. No tokens needed.

**Browser Support:** All modern browsers (Chrome 76+, Firefox 90+, Safari 16.4+, Edge 79+) - [caniuse.com/mdn-http_headers_sec-fetch-site](https://caniuse.com/mdn-http_headers_sec-fetch-site)

## Why This Matters

Token-based CSRF has significant operational pain:

1. **Caching conflicts**: Cached pages contain stale tokens ‚Üí false positives
2. **Session expiry edge cases**: Token/session mismatch after timeout
3. **SPA complexity**: Managing token refresh in JavaScript applications
4. **Multi-tab issues**: Tokens invalidated when user opens multiple tabs

Header-based protection eliminates all of these.

## Proposed Flask Implementation

Rather than adding another extension, this should be a first-class citizen in Flask's routing. The implementation is simple enough that it belongs in core‚Äîjust an argument to `@app.route()`:

```python
from flask import Flask

app = Flask(__name__)
app.config['CSRF_TRUSTED_ORIGINS'] = ['https://accounts.google.com']

# Protected by default for state-changing methods
@app.route('/api/data', methods=['POST'])
def create_data():
    return {'status': 'ok'}

# Explicitly disable for webhooks that use signature verification
@app.route('/webhooks/stripe', methods=['POST'], csrf=False)
def stripe_webhook():
    return {'received': True}

# GET requests are never protected (no state change)
@app.route('/api/data', methods=['GET'])
def get_data():
    return {'data': []}
```

## Configuration

```python
# Default configuration in Flask
CSRF_ENABLED = True                    # Global kill switch
CSRF_TRUSTED_ORIGINS = []              # Allow cross-origin from these origins
CSRF_PROTECTED_METHODS = {'POST', 'PUT', 'PATCH', 'DELETE'}
```

Note: Unlike my earlier draft, `same-site` requests are **rejected by default**. This is intentional‚Äîdifferent subdomains often have different trust levels (e.g., `marketing.example.com` vs `admin.example.com`). If you need same-site requests, add the specific origin to `CSRF_TRUSTED_ORIGINS`.


## Questions for Maintainers

1. **Default On vs Off**: Should CSRF protection be on by default for state-changing methods (proposed), or require explicit `csrf=True`?

2. **Same-site Policy**: The algorithm rejects `same-site` requests by default (per Filippo Valsorda's guidance). Should there be a config option to relax this, or is explicit `CSRF_TRUSTED_ORIGINS` sufficient?

3. **Werkzeug Level**: Should the core check logic live in Werkzeug so other frameworks (Bottle, etc.) can use it?

## References

- [MDN: Sec-Fetch-Site](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site)
- [web.dev: Fetch Metadata](https://web.dev/articles/fetch-metadata)
- [Rails PR #56350](https://github.com/rails/rails/pull/56350) - Rails implementation (merged Dec 2025)
- [Rack Issue #2367](https://github.com/rack/rack/issues/2367) - Rack-level discussion
- [Go proposal: CrossOriginForgeryHandler](https://github.com/golang/go/issues/73626)
- [Blog from go author](https://words.filippo.io/csrf/)
- [OWASP Fetch Metadata positioning](https://github.com/OWASP/CheatSheetSeries/pull/1875)

## Willingness to Implement

I'm prepared to submit a PR implementing this. The change is small and self-contained.
",flask documentation state csrf protection requires form validation framework flask doesnt provide necessitating onetime token stored cooky transmitted form data however modern browser support secfetchsite header making tokenbased csrf protection unnecessary rail merged approach railsrails flask offer similar modern solutionbut flasklike way simple argument route current state flask security documentation flask ideal place happen form validation framework exist flask written csrf token viable protection mechanism thats longer true headerbased protection form validation framework neededjust simple check dispatching view modern approach secfetchsite header fetch metadata request header modern browser send automatically indicates relationship request origin target origin sameorigin request origin scheme host port samesite request site different origin crosssite request completely different site none userinitiated navigation typing url bookmark etc statechanging request post put delete patch simply reject request secfetchsite crosssite token needed browser support modern browser chrome firefox safari edge caniusecommdn matter tokenbased csrf significant operational pain caching conflict cached page contain stale token false positive session expiry edge case tokensession mismatch timeout spa complexity managing token refresh javascript application multitab issue token invalidated user open multiple tab headerbased protection eliminates proposed flask implementation rather adding another extension firstclass citizen flask routing implementation simple enough belongs corejust argument route python flask import flask app flaskname appconfigcsrftrustedorigins protected default statechanging method routeapidata methodspost def createdata return status explicitly disable webhooks use signature verification routewebhooksstripe methodspost csrffalse def stripewebhook return received true get request never protected state change routeapidata methodsget def getdata return data configuration python default configuration flask csrfenabled true global kill switch csrftrustedorigins allow crossorigin origin csrfprotectedmethods post put patch delete note unlike earlier draft samesite request rejected default intentionaldifferent subdomains often different trust level marketingexamplecom adminexamplecom need samesite request add specific origin csrftrustedorigins question maintainer default csrf protection default statechanging method proposed require explicit csrftrue samesite policy algorithm reject samesite request default per filippo valsordas guidance config option relax explicit csrftrustedorigins sufficient werkzeug level core check logic live werkzeug framework bottle etc use reference mdn secfetchsite webdev fetch metadata rail rail implementation merged dec rack issue racklevel discussion proposal crossoriginforgeryhandler blog author owasp fetch metadata positioning willingness implement prepared submit implementing change small selfcontained,Positivo,2
flask,5863,Issue,Comentario,"> Handling Missing Headers: Current proposal allows requests with valid Origin header when Sec-Fetch-Site is missing. Should this be configurable or should we reject outright?

Requiring `Origin` seems like a massive breaking change for APIs (where CSRF is generally not an issue anyway since you need to provide a Bearer token for authentication, or for unauthenticated APIs that do not require CSRF protections).

So default-on would likely be a breaking change.",handling missing header current proposal allows request valid origin header secfetchsite missing configurable reject outright requiring origin seems like massive breaking change apis csrf generally issue anyway since need provide bearer token authentication unauthenticated apis require csrf protection defaulton would likely breaking change,Negativo,2
flask,5863,Issue,Comentario,"> > Handling Missing Headers: Current proposal allows requests with valid Origin header when Sec-Fetch-Site is missing. Should this be configurable or should we reject outright?
> 
> Requiring `Origin` seems like a massive breaking change for APIs (where CSRF is generally not an issue anyway since you need to provide a Bearer token for authentication, or for unauthenticated APIs that do not require CSRF protections).
> 
> So default-on would likely be a breaking change.

The algorithm I was hoping to implement was Filippo's recommended appraoch:

1. Allow safe methods (GET, HEAD, OPTIONS)
2. If Origin in trusted list ‚Üí allow
3. If Sec-Fetch-Site present:
   - same-origin or none ‚Üí allow
   - same-site or cross-site ‚Üí REJECT
4. If neither header present ‚Üí allow (not a browser)
5. If Origin host == Host ‚Üí allow, else reject

Based on this.

**What gets rejected:**

- Browser requests where Sec-Fetch-Site is cross-site or same-site
- Browser requests where Origin is present but doesn't match Host (old browsers)

**What gets allowed:**

- Sec-Fetch-Site: same-origin (browser, same origin)
- Sec-Fetch-Site: none (browser, user-initiated like bookmarks)
- No Sec-Fetch-Site + no Origin (not a browser ‚Äî API clients)
- No Sec-Fetch-Site + Origin matches Host (old browser, same origin)
- Any request to a trusted origin in CSRF_TRUSTED_ORIGINS 

So default-on should not break APIs at all. The protection only kicks in when browser-specific headers are present and indicate a cross-origin request.

Does this address your concern, or am I missing an edge case?
",handling missing header current proposal allows request valid origin header secfetchsite missing configurable reject outright requiring origin seems like massive breaking change apis csrf generally issue anyway since need provide bearer token authentication unauthenticated apis require csrf protection defaulton would likely breaking change algorithm hoping implement filippos recommended appraoch allow safe method get head option origin trusted list allow secfetchsite present sameorigin none allow samesite crosssite reject neither header present allow browser origin host host allow else reject based get rejected browser request secfetchsite crosssite samesite browser request origin present doesnt match host old browser get allowed secfetchsite sameorigin browser origin secfetchsite none browser userinitiated like bookmark secfetchsite origin browser api client secfetchsite origin match host old browser origin request trusted origin csrftrustedorigins defaulton break apis protection kick browserspecific header present indicate crossorigin request address concern missing edge case,Positivo,2
flask,5863,Issue,Comentario,"Yeah, I think ""neither header present ‚Üí allow (not a browser)"" addresses my concern.",yeah think neither header present allow browser address concern,Positivo,2
flask,5863,Issue,Comentario,"This was already on my radar. I've experimented a bit with a middleware in Werkzeug or an implementation in Flask (or both). The difficulty comes from figuring out a nice way to manage allowed origins and exempt paths. Go's implementation reuses its routing implementation, but creating a separate map of exempt paths is a bit more expensive (and difficult to sync configurations) in Werkzeug/Flask. I'm also not sure if we could use `TRUSTED_HOSTS` as the allowed origins as well, but I'm pretty sure we can't as ""host"" is different from ""origin"".",already radar ive experimented bit middleware werkzeug implementation flask difficulty come figuring nice way manage allowed origin exempt path go implementation reuses routing implementation creating separate map exempt path bit expensive difficult sync configuration werkzeugflask also sure could use trustedhosts allowed origin well pretty sure cant host different origin,Positivo,2
flask,5863,Issue,Comentario,"@davidism Here's how I was thinking of implementing this.

**Option 1: Flask + Werkzeug implementation**

1. Accept csrf as a parameter to `@app.route | @blueprint.route` but will still be in `**options` kwargs
2. `werkzeug.routing.Rule` [class](https://github.com/pallets/werkzeug/blob/a9f6b3c7924912e62ea74f39f10fb611d6e7725e/src/werkzeug/routing/rules.py#L459-L473) to have the argument `csrf` and attribute `csrf` 
3. In `flask.App.full_dispatch_request`, call `self.check_csrf(ctx.request)` after `request_started.send` and before `self.preprocess_request` 

https://github.com/pallets/flask/blob/2579ce9f18e67ec3213c6eceb5240310ccd46af8/src/flask/app.py#L1001-L1002

**Option 2: Flask only implementation**

1. Same as above
2. Instead of adding argument to `werkzeug.routing.Rule`, just set `rule_obj.csrf = options.get(""csrf"")` similar to how `provide_automatic_options` is set.
3. Same as above 

https://github.com/pallets/flask/blob/2579ce9f18e67ec3213c6eceb5240310ccd46af8/src/flask/sansio/app.py#L647-L648

---

**On exempt paths:** This approach avoids the ""separate map of exempt paths"" problem entirely. Since `csrf` is stored on the `Rule` object itself, we just check `request.url_rule.csrf` at dispatch time requiring no separate data structure to sync.

**On `TRUSTED_HOSTS` vs origins:** You're right, they're different. So I'd keep them separate:

- `TRUSTED_HOSTS`: existing, for [Host header validation](https://flask.palletsprojects.com/en/stable/api/#flask.Request.trusted_hosts)
- `CSRF_TRUSTED_ORIGINS`: new, full origins for cross-origin allowlist (OAuth callbacks, etc.)

**On Werkzeug vs Flask:** I lean toward Option 2 (Flask only) since:
- The check logic references Flask's `app.config` for `CSRF_TRUSTED_ORIGINS`
- It follows the `provide_automatic_options` precedent
- Werkzeug stays transport-layer focused

The core check logic (~40 lines) could still live in Werkzeug as a utility function that Flask calls, if you want other frameworks to benefit. But the routing integration feels Flask-specific.

Want me to put together a draft PR for Option 2?",here thinking implementing option flask werkzeug implementation accept csrf parameter route route still option kwargs werkzeugroutingrule class argument csrf attribute csrf flaskappfulldispatchrequest call selfcheckcsrfctxrequest requeststartedsend selfpreprocessrequest option flask implementation instead adding argument werkzeugroutingrule set ruleobjcsrf optionsgetcsrf similar provideautomaticoptions set exempt path approach avoids separate map exempt path problem entirely since csrf stored rule object check requesturlrulecsrf dispatch time requiring separate data structure sync trustedhosts origin youre right theyre different keep separate trustedhosts existing host header validation csrftrustedorigins new full origin crossorigin allowlist oauth callback etc werkzeug flask lean toward option flask since check logic reference flask appconfig csrftrustedorigins follows provideautomaticoptions precedent werkzeug stay transportlayer focused core check logic line could still live werkzeug utility function flask call want framework benefit routing integration feel flaskspecific want put together draft option,Negativo,2
flask,5863,Issue,Comentario,"You're using an LLM tool to write for you. If I wanted to chat about and idea and design with an LLM, I could do so directly at any time, I don't need you as an intermediary. Closing, I'll work on this myself at some point.",youre using llm tool write wanted chat idea design llm could directly time dont need intermediary closing ill work point,Neutral,2
flask,5864,Pull Request,Titulo,Add built-in CSRF protection using Sec-Fetch-Site header,add builtin csrf protection using secfetchsite header,Neutral,2
flask,5864,Pull Request,Descripcion,"Implements Option 2 from #5863.

Adds built-in CSRF protection using the Sec-Fetch-Site header that modern browsers send
 automatically, with an Origin header fallback for older browsers.

**Changes**

- Add CSRF_PROTECTION, CSRF_TRUSTED_ORIGINS, and CSRF_PROTECTED_METHODS config options
- Add csrf_protection parameter to @app.route() and add_url_rule()
- Add csrf_protection attribute support for class-based views
- Check CSRF in full_dispatch_request() before preprocess_request()

**Algorithm**

1. Allow safe methods (GET, HEAD, OPTIONS)
2. Allow if origin is in CSRF_TRUSTED_ORIGINS
3. If Sec-Fetch-Site header present: allow same-origin/none, reject
same-site/cross-site
4. If no browser headers present: allow (non-browser clients)
5. If Origin present: allow if it matches Host, otherwise reject

**Usage**

```python
# Enable globally
app.config['CSRF_PROTECTION'] = True

# Enable per-route
@app.route('/api', methods=['POST'], csrf_protection=True)
def api():
    ...

# Exempt a route when enabled globally
@app.route('/webhook', methods=['POST'], csrf_protection=False)
def webhook():
    ...
```

fixes #5863
",implement option add builtin csrf protection using secfetchsite header modern browser send automatically origin header fallback older browser change add csrfprotection csrftrustedorigins csrfprotectedmethods config option add csrfprotection parameter route addurlrule add csrfprotection attribute support classbased view check csrf fulldispatchrequest preprocessrequest algorithm allow safe method get head option allow origin csrftrustedorigins secfetchsite header present allow sameoriginnone reject samesitecrosssite browser header present allow nonbrowser client origin present allow match host otherwise reject usage python enable globally appconfigcsrfprotection true enable perroute routeapi methodspost csrfprotectiontrue def api exempt route enabled globally routewebhook methodspost csrfprotectionfalse def webhook fix,Positivo,2
flask,5864,Pull Request,Comentario,Are you using an LLM tool to substantially generate your writing or code?,using llm tool substantially generate writing code,Neutral,2
flask,5864,Pull Request,Comentario,"> Are you using an LLM tool to substantially generate your writing or code?

Used claude code with opus 4.5 (substantially for the test cases).",using llm tool substantially generate writing code used claude code opus substantially test case,Neutral,2
flask,5864,Pull Request,Comentario,"@ThiefMaster apologies if I've missed any contribution guidelines around tooling or process; happy to correct anything that's not aligned.

@davidism and @ThiefMaster If you have concerns about the implementation or approach itself, I'd genuinely like to hear them.",apology ive missed contribution guideline around tooling process happy correct anything thats aligned concern implementation approach genuinely like hear,Positivo,2
flask,5864,Pull Request,Comentario,"You didn't have time to understand or implement the feature, but you expect the maintainers to have that time to carefully review everything you asked an LLM to generate. That's not acceptable for anything, but especially for a security-related feature. 

If I did want to use an AI, I have access to the same tools you do, so you saved me essentially no time at all in that case.",didnt time understand implement feature expect maintainer time carefully review everything asked llm generate thats acceptable anything especially securityrelated feature want use access tool saved essentially time case,Positivo,2
flask,5857,Pull Request,Titulo,Add documentation and fix type safety bugs,add documentation fix type safety bug,Positivo,2
flask,5857,Pull Request,Descripcion,"# Bug report

**Describe the bug**

The recent refactor introduced a missing type safety and potential runtime error:
- `remove_ctx` and `add_ctx` lacked documentation, making their purpose unclear.
- `get_send_file_max_age` returned a value without proper type casting, triggering `type: ignore` comments.
- The static file route used a lambda referencing a weakref; if the app was garbage‚Äëcollected it could raise an obscure error.
- `raise_routing_exception` raised `request.routing_exception` without guaranteeing it was not `None`, leading to a possible `TypeError`.

These issues manifested as type‚Äëchecking failures and potential crashes when serving static files or handling routing exceptions.

**Steps to reproduce**

1. Run the test suite (`pytest`).
2. Observe `type: ignore` warnings and potential failures in `test_regression.py` when static files are accessed.
3. Manually trigger a routing exception (e.g., abort with a redirect) and notice that `raise_routing_exception` may raise `None`.
4. Access a static file after the app has been garbage‚Äëcollected (unlikely in normal use but possible in long‚Äërunning processes).

**Expected behavior**

- Functions should have clear docstrings.
- `get_send_file_max_age` should return an `int` or `None` with proper type casting.
- The static file view should raise a clear `RuntimeError` if the app is unavailable.
- `raise_routing_exception` should assert the exception exists before raising.

**Environment**

- Python version: 3.12
- Flask version: 3.2.0.dev
",bug report describe bug recent refactor introduced missing type safety potential runtime error removectx addctx lacked documentation making purpose unclear getsendfilemaxage returned value without proper type casting triggering type ignore comment static file route used lambda referencing weakref app garbagecollected could raise obscure error raiseroutingexception raised requestroutingexception without guaranteeing none leading possible typeerror issue manifested typechecking failure potential crash serving static file handling routing exception step reproduce run test suite pytest observe type ignore warning potential failure testregressionpy static file accessed manually trigger routing exception abort redirect notice raiseroutingexception may raise none access static file app garbagecollected unlikely normal use possible longrunning process expected behavior function clear docstrings getsendfilemaxage return int none proper type casting static file view raise clear runtimeerror app unavailable raiseroutingexception assert exception exists raising environment python version flask version dev,Positivo,2
flask,5857,Pull Request,Comentario,"This kind of smells like AI-generated slop considering the `ISSUE.md` file you ended up committing...

Mixing unrelated changes in a single PR is also not a good idea.",kind smell like aigenerated slop considering issuemd file ended committing mixing unrelated change single also good idea,Neutral,2
flask,5854,Pull Request,Titulo,Deprecate should_ignore_error method and add unit tests,deprecate shouldignoreerror method add unit test,Neutral,2
flask,5854,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
This pull request deprecates the Flask.should_ignore_error method according to the current context preservation design. 
It now always returns False and is no longer meaningful. Unit tests have been added to verify its behavior, including:
- parameterized test for multiple exception types
- return value always False
- repeated calls trigger DeprecationWarning
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc pull request deprecates flaskshouldignoreerror method according current context preservation design always return false longer meaningful unit test added verify behavior including parameterized test multiple exception type return value always false repeated call trigger deprecationwarning,Positivo,0
flask,5855,Pull Request,Titulo,kimi-v1,kimiv,Neutral,2
flask,5855,Pull Request,Descripcion,"Âú®ÂΩìÂâçÈ°πÁõÆ‰∏≠Â¢ûÂä† flask/scheduler Êâ©Â±ïÔºöÂê´Ë∞ÉÂ∫¶Âô®„ÄÅ‰ªªÂä°Ë£ÖÈ•∞Âô®(interval/delay/cron)„ÄÅcron Ëß£Êûê„ÄÅÁä∂ÊÄÅÂ≠òÂÇ®„ÄÅÊåáÊ†á‰∏éÁÆ°ÁêÜËìùÂõæ(/_internal/metrics, POST /_internal/tasks//run, /reload)Ôºå‰ªªÂä°Áä∂ÊÄÅÂ≠óÊÆµ‰∏éÂºÇÂ∏∏ËÆ∞ÂΩïÔºåÈÖçÁΩÆÈ°π SCHEDULER_ENABLED/AUTOSTART/TICK_INTERVALÔºåÁ§∫‰æã 3 ‰∏™‰ªªÂä°ÔºåÊØè 10 Áßí„ÄÅÂª∂Ëøü 5 Áßí„ÄÅcron */2 * *„ÄÇ",flaskscheduler intervaldelaycroncron internalmetrics post internaltasksrun reload schedulerenabledautostarttickinterval cron,Neutral,2
flask,5856,Pull Request,Titulo,Refactor Blueprint.register to reduce cyclomatic complexity,refactor blueprintregister reduce cyclomatic complexity,Neutral,2
flask,5856,Pull Request,Descripcion,"Refactored Blueprint.register method in src/flask/sansio/blueprints.py.

- Extracted helper methods:
  _ensure_unique_name,
  _register_static,
  _merge_blueprint_funcs_if_needed,
  _run_deferred_functions,
  _register_cli,
  _register_nested_blueprints,
  _compute_nested_blueprint_options.

- Reduced cyclomatic complexity from D (23) to A (2).
- All tests pass: 485 passed, 5 skipped.",refactored blueprintregister method srcflasksansioblueprintspy extracted helper method ensureuniquename registerstatic mergeblueprintfuncsifneeded rundeferredfunctions registercli registernestedblueprints computenestedblueprintoptions reduced cyclomatic complexity test pas passed skipped,Positivo,2
flask,5861,Issue,Titulo,Proposal: CLI command to validate API endpoints by making test requests,proposal cli command validate api endpoint making test request,Positivo,2
flask,5861,Issue,Descripcion,"### Motivation

When working on Flask applications with many API endpoints, it is sometimes
useful to quickly check whether all registered routes can be accessed without
raising unexpected errors (e.g. unhandled exceptions, 500 errors).

At the moment, developers typically need to write custom scripts or tests to
perform this kind of basic validation. Providing an opt-in CLI command could
help improve developer experience, especially during local development.

### Proposal

Introduce an optional Flask CLI command (for example, `flask check-endpoints`)
that iterates over registered routes and makes test requests using Flask‚Äôs
test client.

The goal would not be full correctness testing, but a lightweight sanity check
to detect obvious runtime errors.

Possible initial scope:
- Only routes with simple methods (e.g. GET by default)
- Skip routes with required path parameters
- Report endpoints that raise exceptions or return 5xx responses
- Development-only usage

### Design considerations

- The command should be fully opt-in and not affect existing behavior.
- No network requests; use Flask‚Äôs built-in test client.
- Keep output simple and readable (similar to `flask routes`).
- Advanced features (custom payloads, auth, etc.) could be out of scope initially.

### Open questions

- Should this live as a core CLI command or as an optional extension?
- How should endpoints with required parameters or authentication be handled?
- Should the command fail on the first error or report all failures?

Feedback on the general direction and scope would be appreciated before
starting an implementation.
",motivation working flask application many api endpoint sometimes useful quickly check whether registered route accessed without raising unexpected error unhandled exception error moment developer typically need write custom script test perform kind basic validation providing optin cli command could help improve developer experience especially local development proposal introduce optional flask cli command example flask checkendpoints iterates registered route make test request using flask test client goal would full correctness testing lightweight sanity check detect obvious runtime error possible initial scope route simple method get default skip route required path parameter report endpoint raise exception return response developmentonly usage design consideration command fully optin affect existing behavior network request use flask builtin test client keep output simple readable similar flask route advanced feature custom payload auth etc could scope initially open question live core cli command optional extension endpoint required parameter authentication handled command fail first error report failure feedback general direction scope would appreciated starting implementation,Negativo,2
flask,5861,Issue,Comentario,I think you could easily create that as a standalone package that integrates in the flask-cli via an entrypoint.,think could easily create standalone package integrates flaskcli via entrypoint,Positivo,2
flask,5861,Issue,Comentario,"@ThiefMaster 
Yes, so I've already created it, and I'd like to discuss here what features would be useful.",yes ive already created like discus feature would useful,Positivo,2
flask,5861,Issue,Comentario,"ah ok, to me it sounded like something you'd like to have in the flask core. I'll move this to discussions",sounded like something youd like flask core ill move discussion,Positivo,2
flask,5853,Pull Request,Titulo,Added rate limiting functionality to Flask app,added rate limiting functionality flask app,Neutral,2
flask,5853,Pull Request,Descripcion,"- Introduced MemoryRateLimiter for managing request limits.
- Added configuration options for enabling rate limiting and setting request limits and time windows.
- Implemented methods to enforce rate limits and build rate limit keys based on request context.
- Integrated rate limiting checks into the request handling process.
",introduced memoryratelimiter managing request limit added configuration option enabling rate limiting setting request limit time window implemented method enforce rate limit build rate limit key based request context integrated rate limiting check request handling process,Neutral,2
flask,5853,Pull Request,Comentario,there are already extensions like flask-limiter for this...,already extension like flasklimiter,Positivo,2
flask,5853,Pull Request,Comentario,Looking at the name of your branch: Is this some kind of university/school project where you were asked to make a contribution to a project on GitHub?,looking name branch kind universityschool project asked make contribution project github,Neutral,2
flask,5853,Pull Request,Comentario,"> Looking at the name of your branch: Is this some kind of university/school project where you were asked to make a contribution to a project on GitHub?

Yes, and we were asked to contribute to a big library but I don't think any of us really know how to or what contributions to make. ",looking name branch kind universityschool project asked make contribution project github yes asked contribute big library dont think really know contribution make,Positivo,2
flask,5853,Pull Request,Comentario,"Please convey to your teacher that this is not an acceptable way to promote open source contribution. They need to properly set you up for success, rather than hoping you figure it out. This was not a good use of maintainer time.",please convey teacher acceptable way promote open source contribution need properly set success rather hoping figure good use maintainer time,Positivo,4
flask,5853,Pull Request,Comentario,"> Please convey to your teacher that this is not an acceptable way to promote open source contribution. They need to properly set you up for success, rather than hoping you figure it out. This was not a good use of maintainer time.

Yes I will do that, my sincere apologies.",please convey teacher acceptable way promote open source contribution need properly set success rather hoping figure good use maintainer time yes sincere apology,Positivo,4
flask,5852,Pull Request,Titulo,Docs: Add WSGI documentation note to README,doc add wsgi documentation note readme,Neutral,2
flask,5852,Pull Request,Descripcion,Added a helpful documentation note to the README explaining what WSGI stands for (Web Server Gateway Interface) and its purpose. This clarifies the acronym for newcomers to the Flask framework.,added helpful documentation note readme explaining wsgi stand web server gateway interface purpose clarifies acronym newcomer flask framework,Positivo,2
flask,5852,Pull Request,Comentario,thanks but this isn't really an improvement...,thanks isnt really improvement,Positivo,4
flask,5851,Issue,Titulo,Add Copy-to-Clipboard button for code examples in documentation,add copytoclipboard button code example documentation,Neutral,2
flask,5851,Issue,Descripcion,"### Feature Request: Add copy button to code blocks in documentation

#### Problem

Many pages in the Flask documentation contain multi-line code snippets, but there is no built-in way to copy the entire block with one click. Users currently need to manually select text, which is slower and error-prone.

#### Proposed Solution

Add a small ""Copy"" button to each `div.highlight` element using a small JavaScript file included via Sphinx.

- Implemented using the native Clipboard API (no external library)
- Minimal UI impact
- Applied only to docs frontend, not core package

#### Motivation & Benefits

- Easier copy-paste for beginners following tutorials
- Consistent with other frameworks (FastAPI, Django, Click docs, etc.)
- Improves developer experience without affecting core Flask code

#### Status

I have already implemented a working version locally and can submit a PR once approved.

Let me know if this is useful and if I should proceed with a pull request.
",feature request add copy button code block documentation problem many page flask documentation contain multiline code snippet builtin way copy entire block one click user currently need manually select text slower errorprone proposed solution add small copy button divhighlight element using small javascript file included via sphinx implemented using native clipboard api external library minimal impact applied doc frontend core package motivation benefit easier copypaste beginner following tutorial consistent framework fastapi django click doc etc improves developer experience without affecting core flask code status already implemented working version locally submit approved let know useful proceed pull request,Positivo,2
flask,5849,Pull Request,Titulo,Add copy-to-clipboard button for code blocks in Flask documentation.,add copytoclipboard button code block flask documentation,Negativo,2
flask,5850,Pull Request,Titulo,Add copy-to-clipboard button for code blocks in Flask documentation.,add copytoclipboard button code block flask documentation,Negativo,2
flask,5850,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

This pull request adds a **‚Äúcopy to clipboard‚Äù button** for all code blocks in the Flask documentation.  
This feature improves usability by allowing users to quickly copy code snippets with a single click, enhancing the overall documentation experience.

The implementation includes:
- A copy button added to each code block.
- JavaScript logic to handle clipboard copying.
- Styling to ensure visibility while matching the existing documentation theme.

Below are screenshots demonstrating the new UI changes:

<img width=""972"" height=""278"" alt=""Copy Button Preview"" src=""https://github.com/user-attachments/assets/4cbd52d2-bf76-4961-9d8c-c3cee960b450"" />

<img width=""990"" height=""309"" alt=""Copy Button Functionality"" src=""https://github.com/user-attachments/assets/ea744dd5-5a1f-4385-a01e-db430531407d"" />

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

fixes **#5848**

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->

I have followed all the steps in `CONTRIBUTING.rst`:

- Added/updated relevant documentation in the `docs` folder.  
- Added an entry in `CHANGES.rst` summarizing the change and linking to the issue.  
- Included `.. versionchanged::` entries in appropriate documentation code strings.  
- (Tests are not required for this documentation UI feature.)
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket pull request add copy clipboard button code block flask documentation feature improves usability allowing user quickly copy code snippet single click enhancing overall documentation experience implementation includes copy button added code block javascript logic handle clipboard copying styling ensure visibility matching existing documentation theme screenshots demonstrating new change img width height altcopy button preview src img width height altcopy button functionality src link relevant issue previous pr one per line use fix automatically close issue fix issue number fix ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc followed step contributingrst addedupdated relevant documentation doc folder added entry changesrst summarizing change linking issue included versionchanged entry appropriate documentation code string test required documentation feature,Negativo,0
flask,5848,Issue,Titulo,Add copy-to-clipboard button for code blocks in Flask documentation.,add copytoclipboard button code block flask documentation,Negativo,2
flask,5848,Issue,Descripcion,"### Description

I propose to add a ""copy to clipboard"" button next to all code blocks in the Flask documentation. This will allow users to easily copy example code or command-line snippets with a single click instead of manually selecting the text. This feature greatly improves usability and convenience, especially on mobile devices.

Flask documentation uses Sphinx for static site generation, and there is an existing Sphinx extension called [sphinx-copybutton](https://sphinx-copybutton.readthedocs.io/en/latest/) that provides this functionality out of the box. It can be enabled by simply adding it to the `extensions` list in the Sphinx `conf.py` file.


This extension also supports stripping common prompts (like `>>>`, `$`) from copied content, making the copied snippets cleaner.

### Problem this resolves

Currently, users have to manually select and copy code blocks, which can be error-prone and inconvenient. Adding a copy button makes the process faster and less error-prone.

### Additional notes

- The change is additive and does not affect existing documentation content or structure.
- This enhancement aligns Flask docs with modern documentation practices seen in many popular projects.

I am happy to implement this feature and create a pull request once the issue is approved.

",description propose add copy clipboard button next code block flask documentation allow user easily copy example code commandline snippet single click instead manually selecting text feature greatly improves usability convenience especially mobile device flask documentation us sphinx static site generation existing sphinx extension called sphinxcopybutton provides functionality box enabled simply adding extension list sphinx confpy file extension also support stripping common prompt like copied content making copied snippet cleaner problem resolve currently user manually select copy code block errorprone inconvenient adding copy button make process faster less errorprone additional note change additive affect existing documentation content structure enhancement aligns flask doc modern documentation practice seen many popular project happy implement feature create pull request issue approved,Positivo,2
flask,5831,Pull Request,Titulo,Update installation instructions for Windows PowerShell,update installation instruction window powershell,Neutral,2
flask,5831,Pull Request,Descripcion,Added instructions for enabling PowerShell script execution on Windows.,added instruction enabling powershell script execution window,Neutral,2
flask,5831,Pull Request,Comentario,Just checked my build and the link is broken...,checked build link broken,Neutral,2
flask,5831,Pull Request,Comentario,Fixed! Silly missing underscores.,fixed silly missing underscore,Negativo,2
flask,5831,Pull Request,Comentario,"I don't think we need to go into this detail here. In fact, I really want to _reduce_ this page, and point people at official docs for uv, virtualenv, etc instead.",dont think need detail fact really want reduce page point people official doc virtualenv etc instead,Positivo,2
flask,5831,Pull Request,Comentario,"I‚Äôm not really sure how to link to that note in the docs as you have to scroll halfway down that page to actually find that note - it would probably be easier for a user to just read it straight from the flask docs, unless you can find a better link that I could use.",really sure link note doc scroll halfway page actually find note would probably easier user read straight flask doc unless find better link could use,Positivo,2
flask,5818,Pull Request,Titulo,pass context through dispatch methods,pas context dispatch method,Neutral,2
flask,5818,Pull Request,Descripcion,"The current `AppContext` object is passed through the various request dispatch methods, rather than each method accessing the proxies. closes #5815 

@pgjones first proposed this in #5229 as a way to speed up dispatch especially for Quart and async views. This PR applies to more methods, and also implements compatibility during a deprecation period.

Dispatch methods now take `ctx: AppContext` as the first parameter. The following `Flask` methods were changed:

- `update_template_context`
- `handle_http_exception`
- `handle_user_exception`
- `handle_exception`
- `log_exception`
- `dispatch_request`
- `full_dispatch_request`
- `finalize_request`
- `make_default_options_response`
- `preprocess_request`
- `process_response`
- `do_teardown_request`
- `do_teardown_appcontext`

`url_for` and `make_response` were not changed, as it's much more likely that these are called from user code that only has access to the proxy.

An `__init_subclass__` class method is added to detect old signatures on subclasses of `Flask`. The second parameter is inspected (first is self). If it is not annotated, it must be named `ctx`. If it is annotated, it must either be the string or class `AppContext`. If an old signature is detected, the method is wrapped to remove the argument when other `Flask` methods call it during dispatch. The base method is also wrapped to inject the argument so that `super().base_method` from the overridden method will continue to work.

I did not apply the compat wrapper to every base `Flask` method, only the ones that a subclass overrides. Therefore, if user code is directly calling these internal dispatch methods, they will get a `TypeError`. This is only likely (and unlikely at that) to happen during testing. I did this over concern that the wrapper would be unnecessary and a performance hit for most applications. If we get bug reports we can consider adding the wrapper.",current appcontext object passed various request dispatch method rather method accessing proxy close first proposed way speed dispatch especially quart async view applies method also implement compatibility deprecation period dispatch method take ctx appcontext first parameter following flask method changed updatetemplatecontext handle handleuserexception handleexception logexception dispatchrequest fulldispatchrequest finalizerequest makedefaultoptionsresponse preprocessrequest processresponse doteardownrequest doteardownappcontext urlfor makeresponse changed much likely called user code access proxy initsubclass class method added detect old signature subclass flask second parameter inspected first self annotated must named ctx annotated must either string class appcontext old signature detected method wrapped remove argument flask method call dispatch base method also wrapped inject argument superbasemethod overridden method continue work apply compat wrapper every base flask method one subclass override therefore user code directly calling internal dispatch method get typeerror likely unlikely happen testing concern wrapper would unnecessary performance hit application get bug report consider adding wrapper,Negativo,2
flask,5815,Issue,Titulo,pass context internally instead of using contextvars,pas context internally instead using contextvars,Neutral,2
flask,5815,Issue,Descripcion,"Currently, there are a bunch of different methods on the `Flask` class that run to dispatch each request. Many of these access `request` and other context proxies. We should update them to pass the `AppContext` everywhere instead. This is more convenient after #5812 with only one context object instead of two. As @pgjones pointed out in #5229, not having to access the contextvar is a significant speedup to ASGI Quart, although it doesn't appear to affect WSGI Flask as much. Perhaps if we were serving with greenlets and so contexts were switching more, it would be more noticeable in Flask too.

The obvious problem is that it is a breaking change to the signatures of all these methods. I'm unsure how many methods are affected, but I'm also unsure how many projects are even subclassing `Flask` to override any of the methods. The fact that the methods are public seems unintentional, compared to the much more common ways of configuring and customizing an app.

We could continue to support both signatures, showing a deprecation warning for the old one, by adding some detection to `Flask.__init__`. This would add some amount of time during app setup, but wouldn't affect runtime performance of the app.

---

Another idea I had for the future was to have `@route` and other decorators inspect the signature of the decorated function, to allow injecting `request`, `app`, etc. if users would rather use that pattern than import the proxies. Having the request object directly available in all the dispatch methods would make this more straightforward. User code would be able to choose what pattern they want, the current proxy pattern would never be deprecated for user code.
",currently bunch different method flask class run dispatch request many access request context proxy update pas appcontext everywhere instead convenient one context object instead two pointed access contextvar significant speedup asgi quart although doesnt appear affect wsgi flask much perhaps serving greenlets context switching would noticeable flask obvious problem breaking change signature method unsure many method affected also unsure many project even subclassing flask override method fact method public seems unintentional compared much common way configuring customizing app could continue support signature showing deprecation warning old one adding detection flaskinit would add amount time app setup wouldnt affect runtime performance app another idea future decorator inspect signature decorated function allow injecting request app etc user would rather use pattern import proxy request object directly available dispatch method would make straightforward user code would able choose pattern want current proxy pattern would never deprecated user code,Negativo,2
flask,5815,Issue,Comentario,"Not a fan of deprecating it, for 99% of all apps the performance difference is unnecessary so the convenience wins IMHO.

I think nobody wants to update their application to a change like this, also because it would imply having to propagate the vars deeper into application code, util functions, etc. that currently use the profies.",fan deprecating apps performance difference unnecessary convenience win imho think nobody want update application change like also would imply propagate var deeper application code util function etc currently use profies,Positivo,2
flask,5815,Issue,Comentario,"This would _only_ be for methods on `Flask` (`Scaffold`, etc), it would not require passing them throughout your own code. #5229 gives an idea of the scope of that.

I've been playing around with the injector a bit, it could be used to re-add the arguments from the proxies further down the chain if some code wanted to use that pattern but other didn't.

The deprecation can be unversioned for a bit, just to see if anyone brings it up. If we do this internally, I don't want to support signature inspection and wrappers forever.",would method flask scaffold etc would require passing throughout code give idea scope ive playing around injector bit could used readd argument proxy chain code wanted use pattern didnt deprecation unversioned bit see anyone brings internally dont want support signature inspection wrapper forever,Negativo,2
flask,5815,Issue,Comentario,"ah, internals only. not such a big deal then, as it would just affect people subclassing...",internals big deal would affect people subclassing,Neutral,2
flask,5815,Issue,Comentario,"It may be very difficult to do this in a way that existing overridden code will not fail and will show a deprecation warning.

We want to upgrade an overridden method that does not take the new `ctx: AppContext` parameter. We can detect this in `__init_subclass__` with `inspect.signature`, and wrap the function to take the correct signature, so that other parts of the dispatch code will call it correctly. But that's the ""simple"" part.

What if other user code is still calling the method, overridden or not, without the new argument? The most obvious way this happens is with `super().method` within the overridden method. The wrapper could perhaps be clever enough to check the type of the first argument, and decide to make a new or old signature call. The wrapper would have to be applied to every base method to handle the `super` call case.

I haven't tried to write this more complex wrapper yet. I have a feeling it will be difficult to write. I know it will add overhead to every request, since multiple methods will now have to do detection on the arguments passed to them. This overhead will mostly be waste, as the vast majority of code will not be overridden.

Perhaps we can just say this is a breaking change in 4.0? I still think the result is worth it. We could still show a better error message by doing some detection in `__init_subclass__`, but showing an error instead of applying a wrapper and showing a warning.",may difficult way existing overridden code fail show deprecation warning want upgrade overridden method take new ctx appcontext parameter detect initsubclass inspectsignature wrap function take correct signature part dispatch code call correctly thats simple part user code still calling method overridden without new argument obvious way happens supermethod within overridden method wrapper could perhaps clever enough check type first argument decide make new old signature call wrapper would applied every base method handle super call case havent tried write complex wrapper yet feeling difficult write know add overhead every request since multiple method detection argument passed overhead mostly waste vast majority code overridden perhaps say breaking change still think result worth could still show better error message detection initsubclass showing error instead applying wrapper showing warning,Negativo,2
flask,5815,Issue,Comentario,"The following method signatures would change to add `ctx: AppContext` as the first parameter:

- `update_template_context`
- `handle_http_exception`
- `handle_user_exception`
- `handle_exception`
- `log_exception`
- `dispatch_request`
- `full_dispatch_request`
- `finalize_request`
- `make_default_options_response`
- `preprocess_request`
- `process_response`
- `do_teardown_request`
- `do_teardown_appcontext`

I'd be somewhat surprised to find any of these overridden. They're either really internal, or they're the machinery that calls registered callback functions.",following method signature would change add ctx appcontext first parameter updatetemplatecontext handle handleuserexception handleexception logexception dispatchrequest fulldispatchrequest finalizerequest makedefaultoptionsresponse preprocessrequest processresponse doteardownrequest doteardownappcontext somewhat surprised find overridden theyre either really internal theyre machinery call registered callback function,Positivo,2
flask,5815,Issue,Comentario,"I've managed to write some code that can detect overridden methods with the old signature, and wrap them and the corresponding base method so they'll continue to work during the deprecation period.",ive managed write code detect overridden method old signature wrap corresponding base method theyll continue work deprecation period,Neutral,2
flask,5847,Pull Request,Titulo,docs: Improve Quickstart example clarity for beginners,doc improve quickstart example clarity beginner,Positivo,2
flask,5847,Pull Request,Descripcion,"## Description
   This PR improves the Quickstart documentation to help beginners understand:
   - Where to save their first Flask application
   - How to structure the basic example
   - Common patterns like `if __name__ == '__main__'`
   
   ## Changes Made
   - Added explicit file naming instructions
   - Enhanced code comments
   - Included complete working example
   - Clarified common beginner confusion points
   
   ## Testing
   - Built documentation locally and verified changes render correctly
   - Tested example code to ensure it works
   
   ## Related Issues
   Addresses common beginner confusion mentioned in #[issue-number if applicable]",description improves quickstart documentation help beginner understand save first flask application structure basic example common pattern like name main change made added explicit file naming instruction enhanced code comment included complete working example clarified common beginner confusion point testing built documentation locally verified change render correctly tested example code ensure work related issue address common beginner confusion mentioned issuenumber applicable,Positivo,2
flask,5847,Pull Request,Comentario,"I don't think this is a useful change. For example, `flask run` is a thing and thus the part of running the file directly isn't even needed in the code.",dont think useful change example flask run thing thus part running file directly isnt even needed code,Positivo,2
flask,5836,Issue,Titulo,Test failures with click 8.3.1,test failure click,Negativo,2
flask,5836,Issue,Descripcion,"Click 8.3.1 was [tagged](https://github.com/pallets/click/releases/tag/8.3.1) but not released on PyPI. Running flask's test suite with that version results in
```
============================= test session starts ==============================
platform linux -- Python 3.13.8, pytest-8.4.2, pluggy-1.6.0
rootdir: /build/flask-3.1.2
configfile: pyproject.toml
testpaths: tests
collected 490 items                                                            

tests/test_appctx.py ..............                                      [  2%]
tests/test_async.py ........                                             [  4%]
tests/test_basic.py .................................................... [ 15%]
........................................................................ [ 29%]
......                                                                   [ 31%]
tests/test_blueprints.py ............................................... [ 40%]
.............                                                            [ 43%]
tests/test_cli.py ...................................................F.. [ 54%]
...F                                                                     [ 55%]
tests/test_config.py ...................                                 [ 58%]
tests/test_converters.py ..                                              [ 59%]
tests/test_helpers.py ...................................                [ 66%]
tests/test_instance_config.py .......                                    [ 67%]
tests/test_json.py ...............................                       [ 74%]
tests/test_json_tag.py ..............                                    [ 77%]
tests/test_logging.py ......                                             [ 78%]
tests/test_regression.py .                                               [ 78%]
tests/test_reqctx.py .......ss.....                                      [ 81%]
tests/test_request.py ...                                                [ 82%]
tests/test_session_interface.py .                                        [ 82%]
tests/test_signals.py .......                                            [ 83%]
tests/test_subclassing.py .                                              [ 83%]
tests/test_templating.py ................................                [ 90%]
tests/test_testing.py .........................                          [ 95%]
tests/test_user_error_handler.py .........                               [ 97%]
tests/test_views.py .............                                        [100%]

=================================== FAILURES ===================================
______________________________ test_run_cert_path ______________________________

    def test_run_cert_path():
        # no key
        with pytest.raises(click.BadParameter):
            run_command.make_context(""run"", [""--cert"", __file__])
    
        # no cert
>       with pytest.raises(click.BadParameter):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'click.exceptions.BadParameter'>


tests/test_cli.py:590: Failed
__________________________ test_run_exclude_patterns ___________________________

    def test_run_exclude_patterns():
>       ctx = run_command.make_context(""run"", [""--exclude-patterns"", __file__])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


tests/test_cli.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:1216: in make_context
    self.parse_args(ctx, args)
        args       = []
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        extra      = {}
        info_name  = 'run'
        parent     = None
        self       = <Command run>
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:1227: in parse_args
    _, args = param.handle_parse_result(ctx, opts, args)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        _          = 5000
        args       = []
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        opts       = {'exclude_patterns': '/build/flask-3.1.2/tests/test_cli.py'}
        param      = <Option key>
        param_order = [<Option exclude_patterns>]
        parser     = <click.parser._OptionParser object at 0x7ffff4b08bd0>
        self       = <Command run>
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:2548: in handle_parse_result
    value = self.process_value(ctx, value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        args       = []
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        opts       = {'exclude_patterns': '/build/flask-3.1.2/tests/test_cli.py'}
        self       = <Option key>
        source     = <ParameterSource.DEFAULT: 3>
        value      = Sentinel.UNSET
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:3283: in process_value
    return super().process_value(ctx, value)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        __class__  = <class 'click.core.Option'>
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        self       = <Option key>
        value      = Sentinel.UNSET
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:2443: in process_value
    value = self.callback(ctx, self, value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        self       = <Option key>
        value      = None
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ctx = <click.core.Context object at 0x7ffff4c02b10>, param = <Option key>
value = None

    def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:
        """"""The ``--key`` option must be specified when ``--cert`` is a file.
        Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
        """"""
        cert = ctx.params.get(""cert"")
        is_adhoc = cert == ""adhoc""
    
        try:
            import ssl
        except ImportError:
            is_context = False
        else:
            is_context = isinstance(cert, ssl.SSLContext)
    
        if value is not None:
            if is_adhoc:
                raise click.BadParameter(
                    'When ""--cert"" is ""adhoc"", ""--key"" is not used.', ctx, param
                )
    
            if is_context:
                raise click.BadParameter(
                    'When ""--cert"" is an SSLContext object, ""--key"" is not used.',
                    ctx,
                    param,
                )
    
            if not cert:
                raise click.BadParameter('""--cert"" must also be specified.', ctx, param)
    
            ctx.params[""cert""] = cert, value
    
        else:
            if cert and not (is_adhoc or is_context):
>               raise click.BadParameter('Required when using ""--cert"".', ctx, param)
E               click.exceptions.BadParameter: Required when using ""--cert"".

cert       = Sentinel.UNSET
ctx        = <click.core.Context object at 0x7ffff4c02b10>
is_adhoc   = False
is_context = False
param      = <Option key>
ssl        = <module 'ssl' from '/nix/store/cfapjd2rvqrpry4grb0kljnp8bvnvfxz-python3-3.13.8/lib/python3.13/ssl.py'>
value      = None

/nix/store/12gfdjrf93rixvjrkj9pbfy5349q3j4m-python3.13-flask-3.1.2/lib/python3.13/site-packages/flask/cli.py:870: BadParameter
=========================== short test summary info ============================
FAILED tests/test_cli.py::test_run_cert_path - Failed: DID NOT RAISE <class 'click.exceptions.BadParameter'>
FAILED tests/test_cli.py::test_run_exclude_patterns - click.exceptions.BadParameter: Required when using ""--cert"".
================== 2 failed, 486 passed, 2 skipped in 13.73s ===================
```",click tagged released pypi running flask test suite version result test session start platform linux python pytest pluggy rootdir buildflask configfile pyprojecttoml testpaths test collected item teststestappctxpy teststestasyncpy teststestbasicpy teststestblueprintspy teststestclipy teststestconfigpy teststestconverterspy teststesthelperspy teststestinstanceconfigpy teststestjsonpy teststestjsontagpy teststestloggingpy teststestregressionpy teststestreqctxpy teststestrequestpy teststestsessioninterfacepy teststestsignalspy teststestsubclassingpy teststesttemplatingpy teststesttestingpy teststestusererrorhandlerpy teststestviewspy failure testruncertpath def testruncertpath key pytestraisesclickbadparameter runcommandmakecontextrun cert file cert pytestraisesclickbadparameter failed raise class clickexceptionsbadparameter teststestclipy failed testrunexcludepatterns def testrunexcludepatterns ctx runcommandmakecontextrun excludepatterns file teststestclipy nixstoreyaagcaaqhqrgammxwmzvmpythonclicklibpythonsitepackagesclickcorepy makecontext selfparseargsctx args args ctx clickcorecontext object xffffcb extra infoname run parent none self command run nixstoreyaagcaaqhqrgammxwmzvmpythonclicklibpythonsitepackagesclickcorepy parseargs args paramhandleparseresultctx opts args args ctx clickcorecontext object xffffcb opts excludepatterns buildflaskteststestclipy param option key paramorder option excludepatterns parser clickparseroptionparser object xffffbbd self command run nixstoreyaagcaaqhqrgammxwmzvmpythonclicklibpythonsitepackagesclickcorepy handleparseresult value selfprocessvaluectx value args ctx clickcorecontext object xffffcb opts excludepatterns buildflaskteststestclipy self option key source parametersourcedefault value sentinelunset nixstoreyaagcaaqhqrgammxwmzvmpythonclicklibpythonsitepackagesclickcorepy processvalue return superprocessvaluectx value class class clickcoreoption ctx clickcorecontext object xffffcb self option key value sentinelunset nixstoreyaagcaaqhqrgammxwmzvmpythonclicklibpythonsitepackagesclickcorepy processvalue value selfcallbackctx self value ctx clickcorecontext object xffffcb self option key value none ctx clickcorecontext object xffffcb param option key value none def validatekeyctx clickcontext param clickparameter value tany tany key option must specified cert file modifies cert param cert key pair needed cert ctxparamsgetcert isadhoc cert adhoc try import ssl except importerror iscontext false else iscontext isinstancecert sslsslcontext value none isadhoc raise clickbadparameter cert adhoc key used ctx param iscontext raise clickbadparameter cert sslcontext object key used ctx param cert raise clickbadparametercert must also specified ctx param ctxparamscert cert value else cert isadhoc iscontext raise clickbadparameterrequired using cert ctx param clickexceptionsbadparameter required using cert cert sentinelunset ctx clickcorecontext object xffffcb isadhoc false iscontext false param option key ssl module ssl nixstorecfapjdrvqrprygrbkljnpbvnvfxzpythonlibpythonsslpy value none nixstoregfdjrfrixvjrkjpbfyqjmpythonflasklibpythonsitepackagesflaskclipy badparameter short test summary info failed teststestclipytestruncertpath failed raise class clickexceptionsbadparameter failed teststestclipytestrunexcludepatterns clickexceptionsbadparameter required using cert failed passed skipped,Negativo,2
flask,5836,Issue,Comentario,"`test_run_exclude_patterns` can be fixed by replacing
https://github.com/pallets/flask/blob/88a65bb374e87a18816a780dbd4ae69d307aa85c/src/flask/cli.py#L861
with
```python
if cert is not None and cert != click._utils.UNSET and not (is_adhoc or is_context):
```
but this is probably an upstream bug
cc @rowlando13",testrunexcludepatterns fixed replacing python cert none cert clickutilsunset isadhoc iscontext probably upstream bug,Neutral,2
flask,5836,Issue,Comentario,"Sentinel is an implementation detail that is not intentionally exposed. However, it is in the context params during a callback: sentinel_in_callback.py

```
import click

def _validate(ctx, param, value):

    you_sentinel = ctx.params.get(""you"")
    you_too_sentinel = ctx.params.get(""you_too"")
    print(f""you: {you_sentinel}"")
    print(f""you_too: {you_too_sentinel}"")
    print(f""param: {param}"")
    print(f""value: {value}"")
    return value

@click.group()
def basic():
    pass

@basic.command()
@click.argument('you', required=False)
@click.option('--you-too', )
@click.option('--yall', callback=_validate)
@click.pass_context
def hello(ctx, you, you_too, yall):
    click.echo('Hello World!')

if __name__ == '__main__':
    basic()
    # python -m sentinel_in_callback hello
``` 

``` 
> python -m sentinel_in_callback hello
you: Sentinel.UNSET
you_too: Sentinel.UNSET
param: <Option yall>
value: None
Hello World!
```",sentinel implementation detail intentionally exposed however context params callback sentinelincallbackpy import click def validatectx param value yousentinel ctxparamsgetyou youtoosentinel ctxparamsgetyoutoo printfyou yousentinel printfyoutoo youtoosentinel printfparam param printfvalue value return value group def basic pas command argumentyou requiredfalse optionyoutoo optionyall callbackvalidate passcontext def helloctx youtoo yall clickechohello world name main basic python sentinelincallback hello python sentinelincallback hello sentinelunset youtoo sentinelunset param option yall value none hello world,Positivo,2
flask,5836,Issue,Comentario,Minimal reproduction for flask failures. ,minimal reproduction flask failure,Negativo,2
flask,5836,Issue,Comentario,`_validate_key` is used as a callback for an option. The test is invoking the command directly with `Command.make_context()`. ,validatekey used callback option test invoking command directly commandmakecontext,Neutral,2
flask,5836,Issue,Comentario,"@davidism I am on the fence, should this bug hold up releasing click 8.3.1? ",fence bug hold releasing click,Neutral,2
flask,5836,Issue,Comentario,"I'd prefer this held up 8.3.1, as it's an indicator that there is still a problem with Click's new default implementation.",prefer held indicator still problem click new default implementation,Negativo,2
flask,5836,Issue,Comentario,Closing because this is an issue that will be addressed in Click.,closing issue addressed click,Neutral,2
flask,5836,Issue,Comentario,"FYI, I just proposed a fix at: https://github.com/pallets/click/pull/3137",fyi proposed fix,Positivo,2
flask,5846,Pull Request,Titulo,Fix _validate_key to handle click 8.3.1 Sentinel values,fix validatekey handle click sentinel value,Positivo,2
flask,5846,Pull Request,Descripcion,"Fixes #5836

Updates the condition in _validate_key to properly check for click._utils.UNSET sentinel value, which is now present in ctx.params during callbacks in click 8.3.1.

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",fix update condition validatekey properly check clickutilsunset sentinel value present ctxparams callback click opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Positivo,0
flask,5846,Pull Request,Comentario,"The fix will be in Click, not here. UNSET is an internal symbol.",fix click unset internal symbol,Neutral,2
flask,5689,Issue,Titulo,Is flask still being maintained?,flask still maintained,Neutral,2
flask,5689,Issue,Descripcion,"Is flask still being maintained, I see the git was updated 2 month back, can I still use flask for my new project?",flask still maintained see git updated month back still use flask new project,Neutral,2
flask,5689,Issue,Comentario,Flask is stable mature software with most issues resolved it's unrealistic to expect the same activity as a project under exploration/shift ,flask stable mature software issue resolved unrealistic expect activity project explorationshift,Positivo,2
flask,5689,Issue,Comentario,Thanks for clarification,thanks clarification,Positivo,4
flask,5833,Pull Request,Titulo,fix typos discovered by  codespell,fix typo discovered codespell,Neutral,2
flask,5833,Pull Request,Descripcion,"Fix typos discovered by codespell - https://pypi.org/project/codespell

% `codespell --ignore-words-list=te`
```
./docs/appcontext.rst:122: requet ==> request
./docs/quickstart.rst:465: interanlly ==> internally
./docs/templating.rst:186: avaialble ==> available
```
% `codespell -ignore-words-list=te --write-changes` ",fix typo discovered codespell codespell ignorewordslistte docsappcontextrst requet request docsquickstartrst interanlly internally docstemplatingrst avaialble available codespell ignorewordslistte writechanges,Neutral,2
flask,5833,Pull Request,Comentario,"See our contributing guide about docs https://palletsprojects.com/contributing/docs, in particular

> If you are fixing or improving existing docs, or writing about existing features, you want to branch off of the stable branch, as well as target the stable branch in the PR.",see contributing guide doc particular fixing improving existing doc writing existing feature want branch stable branch well target stable branch,Positivo,2
flask,5833,Pull Request,Comentario,"Unfortunately, the three typos above are not on the `stable` branch, so let's get `codespell` in place to catch future typos.
* #5844 ",unfortunately three typo stable branch let get codespell place catch future typo,Negativo,2
flask,5834,Pull Request,Titulo,`pre-commit autoupdate --freeze` 2025-10-23,precommit autoupdate freeze,Neutral,2
flask,5834,Pull Request,Descripcion,"% `pre-commit autoupdate --freeze`
```
[https://github.com/astral-sh/ruff-pre-commit] updating v0.12.9 -> v0.14.1 (frozen)
[https://github.com/astral-sh/uv-pre-commit] updating 0.8.12 -> 0.9.5 (frozen)
```
% `pre-commit run --all-files`
```
```
* https://github.com/astral-sh/ruff/releases
* https://github.com/astral-sh/uv/releases -- Fixes [CVE-2025-62518](https://github.com/advisories/GHSA-j5gw-2vrg-8fgx) a high-severity vulnerability.

It is unclear to me how modifying `.pre-commit-config.yaml` would break `Tests / Development Versions`.",precommit autoupdate freeze updating frozen updating frozen precommit run allfiles fix cve highseverity vulnerability unclear modifying precommitconfigyaml would break test development version,Negativo,2
flask,5832,Pull Request,Titulo,GitHub Actions: Add Python 3.14 and 3.14t to the testing,github action add python testing,Neutral,2
flask,5832,Pull Request,Descripcion,"On branch ___stable___.

https://www.python.org/downloads/release/python-3140/

https://py-free-threading.github.io/porting
",branch stable,Neutral,2
flask,5840,Pull Request,Titulo,docs: enhance README with comprehensive examples and troubleshooting,doc enhance readme comprehensive example troubleshooting,Positivo,2
flask,5840,Pull Request,Descripcion,"This PR significantly improves the Flask README by:

- Adding comprehensive quick start guide with step-by-step instructions
- Including multiple practical examples covering common use cases
- Adding advanced features section with blueprints and database integration
- Creating detailed troubleshooting section for common beginner issues
- Providing project structure guidance and installation options
- Enhancing organization with clear sections and better formatting

These enhancements make the README much more beginner-friendly and practical for real-world Flask development.",significantly improves flask readme adding comprehensive quick start guide stepbystep instruction including multiple practical example covering common use case adding advanced feature section blueprint database integration creating detailed troubleshooting section common beginner issue providing project structure guidance installation option enhancing organization clear section better formatting enhancement make readme much beginnerfriendly practical realworld flask development,Positivo,2
flask,5837,Pull Request,Titulo,Create jenkinsfile,create jenkinsfile,Positivo,2
flask,5837,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5838,Pull Request,Titulo,Update app.py,update apppy,Neutral,2
flask,5838,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5838,Pull Request,Comentario,This is not your playground. Stop sending garbage PRs to other people's repos to learn how to use GitHub.,playground stop sending garbage pr people repos learn use github,Positivo,2
flask,5839,Issue,Titulo,"Really, I can't close connection???",really cant close connection,Neutral,2
flask,5839,Issue,Descripcion,"Jesus Christ, what kind of library doesn‚Äôt allow forcefully closing a connection? Even after returning or using abort, it still continues to process data in the background. This is disappointing, there‚Äôs no way, for example, to forcefully stop a file upload after checking its header. It will still continue to process the remaining 100 GB of the file.

```
@app.route('/upload', methods=['POST'])
def upload_file():
    print(1)
    return ""wtf"", 400 # still continues to process data
```",jesus christ kind library doesnt allow forcefully closing connection even returning using abort still continues process data background disappointing there way example forcefully stop file upload checking header still continue process remaining file routeupload methodspost def uploadfile print return wtf still continues process data,Negativo,2
flask,5839,Issue,Comentario,"Now try again without being passive aggressive. This is not appreciated anywhere, but in particular not by open source maintainers.",try without passive aggressive appreciated anywhere particular open source maintainer,Negativo,4
flask,5839,Issue,Comentario,"Also, your webserver should typically be configured with sane limits. In fact, the code in your function won't even run until the file has been uploaded.",also webserver typically configured sane limit fact code function wont even run file uploaded,Neutral,2
flask,5839,Issue,Comentario,"Yeah, I set the limit to 2 GB, but I don‚Äôt want it to keep uploading the full 2 GB. It does start immediately tho. I can then get the stream with `request.files.get('file')`, but reading the header takes quite some time `header = file.stream.read(1024)`. So I decided to check if I could just abort the connection immediately, like in the example, and no, I can‚Äôt.

FIX: Actually, I think it‚Äôs a Chrome problem now. I‚Äôve never experienced anything like that because it works fine when using curl.",yeah set limit dont want keep uploading full start immediately tho get stream requestfilesgetfile reading header take quite time header filestreamread decided check could abort connection immediately like example cant fix actually think chrome problem ive never experienced anything like work fine using curl,Positivo,2
flask,5839,Issue,Comentario,"Regardless of frustration you may be feeling, your approach to reporting this issue and asking for help was not acceptable. Please reflect on how you'd like people to interact with you, then apply that to future interactions with others.",regardless frustration may feeling approach reporting issue asking help acceptable please reflect youd like people interact apply future interaction others,Negativo,2
flask,5829,Pull Request,Titulo,Docs typo/markup fixes,doc typomarkup fix,Neutral,2
flask,5829,Pull Request,Descripcion,Just two typos I've run into.,two typo ive run,Neutral,2
flask,5828,Pull Request,Titulo,docs: fix missing quote in flashing example,doc fix missing quote flashing example,Negativo,2
flask,5828,Pull Request,Descripcion,"### Change

Fix missing quotation mark in ‚ÄúFlashing with categories‚Äù example.

### Description

* Add missing quotation mark in `<ul class=flashes>` -> `<ul class=""flashes"">`.",change fix missing quotation mark flashing category example description add missing quotation mark classflashes classflashes,Negativo,2
flask,5828,Pull Request,Comentario,It's valid as is,valid,Neutral,2
flask,5828,Pull Request,Comentario,"Sorry about that, I didn't know single class names without quotations were valid in HTML5. 

Thank you so much for the review!",sorry didnt know single class name without quotation valid html thank much review,Positivo,2
flask,5826,Pull Request,Titulo,docs: clarify JSON parsing error conditions in Flask views,doc clarify json parsing error condition flask view,Negativo,1
flask,5826,Pull Request,Descripcion,"## Update Documentation: JSON Parsing Behavior

Update the documentation to specify that JSON parsing fails for any reason, including a missing or incorrect `Content-Type` header, not just invalid JSON or an unset header. This improves accuracy and clarity for developers.

issue #5825 ",update documentation json parsing behavior update documentation specify json parsing fails reason including missing incorrect contenttype header invalid json unset header improves accuracy clarity developer issue,Positivo,1
flask,5826,Pull Request,Comentario,"This doesn't address the linked issue, which talks about a specific error code, whereas this only rewords the existing sentence. The linked issue even has the suggested wording. It only required copying a sentence from one place to another, no writing required, no reason to reach for AI.",doesnt address linked issue talk specific error code whereas rewords existing sentence linked issue even suggested wording required copying sentence one place another writing required reason reach,Negativo,2
flask,5821,Pull Request,Titulo,Add type hints to tutorial and Javascript examples,add type hint tutorial javascript example,Neutral,4
flask,5821,Pull Request,Descripcion,"- Add return type annotations and parameter types
 - Import necessary typing modules (Optional, Union, Flask, Response)
 - Improve code readability and IDE support for examples
 - All existing tests continue to pass

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",add return type annotation parameter type import necessary typing module optional union flask response improve code readability ide support example existing test continue pas opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Positivo,0
flask,5821,Pull Request,Comentario,"LGTM, follows other areas of the source in style, thanks for adding the type hints!",lgtm follows area source style thanks adding type hint,Positivo,4
flask,5821,Pull Request,Comentario,Thanks!! I'll do it ,thanks ill,Positivo,4
flask,5821,Pull Request,Comentario,@davidism This PR got closed but I don't see it merged back into main.  I'm still learning so was just wondering what that means.  The code changes have been deemed unnecessary or they will be merged back into main at som point?,got closed dont see merged back main still learning wondering mean code change deemed unnecessary merged back main som point,Neutral,2
flask,5821,Pull Request,Comentario,"IMHO the changes are not particularly useful and just make otherwise simple examples harder to understand, especially for beginners. Having type hints on view functions in an application do not add any rael benefit, unlike type hints on library code, utils, etc.",imho change particularly useful make otherwise simple example harder understand especially beginner type hint view function application add rael benefit unlike type hint library code utils etc,Positivo,4
flask,5821,Pull Request,Comentario,"Well said, an opinion hahaha",well said opinion hahaha,Positivo,2
flask,5819,Issue,Titulo,Enrich Flask‚Äôs public API type hints using typing.Annotated with Doc metadata,enrich flask public api type hint using typingannotated doc metadata,Neutral,4
flask,5819,Issue,Descripcion,"## Feature Request

### Summary

Enhance selected public Flask APIs (for example `add_url_rule` and `route`) by adding
`typing.Annotated` with `Doc` metadata **and `Literal` types for HTTP methods** to provide
richer IDE assistance and stronger static type checking.

### Example

```python
from typing import Annotated, Literal
from typing_extensions import Doc

# Strict HTTP method type for auto-complete and validation
Method = Literal[""GET"", ""POST"", ""PUT"", ""DELETE"", ""PATCH"", ""OPTIONS"", ""HEAD""]

def add_url_rule(
    rule: Annotated[str, Doc(""URL path such as '/home' or '/api/items/<int:id>'"")],
    *,
    methods: Annotated[list[Method], Doc(""Allowed HTTP methods, e.g. ['GET', 'POST']"")],
    ...
) -> None:
    ...
```

### Benefits

* **Better editor/IDE hints and documentation** for route paths and HTTP methods.
* **Static validation of HTTP verbs** so type checkers catch typos like `""GEET""`.
* **Backward compatible** with existing type checkers and runtime behavior (`typing_extensions.Annotated` and `Literal` are supported across Python versions Flask supports).

### Questions for Maintainers

* Would you accept `Annotated` + `Doc` and `Literal` types in public API signatures?
* If yes, should I begin with a small pilot (e.g., only `add_url_rule`) before expanding to other decorators such as `route`?
",feature request summary enhance selected public flask apis example addurlrule route adding typingannotated doc metadata literal type http method provide richer ide assistance stronger static type checking example python typing import annotated literal typingextensions import doc strict http method type autocomplete validation method literalget post put delete patch option head def addurlrule rule annotatedstr docurl path home apiitemsintid method annotatedlistmethod docallowed http method get post none benefit better editoride hint documentation route path http method static validation http verb type checker catch typo like geet backward compatible existing type checker runtime behavior typingextensionsannotated literal supported across python version flask support question maintainer would accept annotated doc literal type public api signature yes begin small pilot addurlrule expanding decorator route,Positivo,4
flask,5229,Pull Request,Titulo,Pass the request ctx rather than use the globals in the app,pas request ctx rather use globals app,Neutral,2
flask,5229,Pull Request,Descripcion,"The globals have a performance penalty which can be justified for the convinience in user code. In the app however the ctx can easily be passed through the method calls thereby reducing the performance penalty.

This may affect extensions if they have subclassed the app and overridden these methods.

Checklist:

- [x] Add tests that demonstrate the correct behavior of the change. Tests should fail without the change.
- [x] Add or update relevant docs, in the docs folder and in code.
- [x] Add an entry in `CHANGES.rst` summarizing the change and linking to the issue.
- [x] Add `.. versionchanged::` entries in any relevant code docs.
- [x] Run `pre-commit` hooks and fix any issues.
- [x] Run `pytest` and `tox`, no tests failed.
",globals performance penalty justified convinience user code app however ctx easily passed method call thereby reducing performance penalty may affect extension subclassed app overridden method checklist add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc run precommit hook fix issue run pytest tox test failed,Negativo,0
flask,5229,Pull Request,Comentario,"I've done something similar for Quart after finding it had a significant impact on micro benchmarks.

Edit: The quart study was done a few years ago before the switch to ContextVars which seem significantly quicker. I still think this is a useful change, but seems less performance motivated now.",ive done something similar quart finding significant impact micro benchmark edit quart study done year ago switch contextvars seem significantly quicker still think useful change seems less performance motivated,Positivo,2
flask,5229,Pull Request,Comentario,"My initial reaction is that while this makes sense, I'm uncomfortable with making the change. I'll have to think about this for a little bit. ",initial reaction make sense uncomfortable making change ill think little bit,Negativo,2
flask,5229,Pull Request,Comentario,"Could you give more information about the benchmarks? How micro are we talking; how fast does the complexity of the app overshadow any speed gains?

Is the speed loss in the use of the proxy, or is the gain in the use of the local variable? Perhaps using `_cv_req.get()` directly and avoiding the proxy could have a similar improvement?",could give information benchmark micro talking fast complexity app overshadow speed gain speed loss use proxy gain use local variable perhaps using cvreqget directly avoiding proxy could similar improvement,Positivo,2
flask,5229,Pull Request,Comentario,"This is an interesting one, with Quart the equivalent to this makes around a 1.5 times improvement, whereas for Flask it doesn't seem to have any affect (maybe a minor positive one). I don't think I can therefore remove it from Quart, but I'd like the APIs to match. 

(I tried `_cv_request` in Quart and it made little difference.)

Also I don't think this makes it more complex - without knowledge of Flask's globals it would be expected to be passed via the call chain.",interesting one quart equivalent make around time improvement whereas flask doesnt seem affect maybe minor positive one dont think therefore remove quart like apis match tried cvrequest quart made little difference also dont think make complex without knowledge flask globals would expected passed via call chain,Positivo,2
flask,5229,Pull Request,Comentario,This will be deferred to allow further discussion.,deferred allow discussion,Positivo,2
flask,5229,Pull Request,Comentario,continued in #5818,continued,Neutral,2
flask,5812,Pull Request,Titulo,merge app and request context,merge app request context,Neutral,2
flask,5812,Pull Request,Descripcion,"Merges the `RequestContext` class into the `AppContext` class. closes #5639

A lot of the size of this PR is rewriting or cleaning up docs related to the contexts. See `ctx.py` for the bulk of the work, and even there it's pretty much no new code, mostly deduplication. The ""request context"" still exists, but what data is available on the context object is what distinguishes it from an ""app context"" now.

How the user works with the context is pretty much unchanged. For example, `teardown_request` and `teardown_appcontext` still both exist, `app.app_context` and `app.test_request_context`, etc. All the same global proxies, `current_app`, `g`, `request`, and `session` still exist and are still available. in the same situations they were before.

The difference is that we no longer have to track whether an app context is already pushed when pushing a request context. This was already sort of an artificial behavior, it was not something that would ever happen under intended/documented request or testing scenarios. Now, every request always sets the app, and the request if request data is given. This greatly simplifies the internal data, as we simply need to record the previous value of the context var to restore on pop.

Some code in app internals was changed to use the contextvar directly, which code was already doing. This probably gains some tiny bit of performance rather than going through the proxies. When we go ahead with #5229 and beyond, we'll be passing around the context objects directly and won't even need to use the contextvar.

---

There are a few implications for testing that may have used `with app.app_context()` around a test client request. I've already highly discouraged this practice in issues over the years because it was already causing other issues. None of these patterns were in our docs.

With the old behavior, an app context was not pushed if one was already pushed when pushing a request context. Therefore,  `teardown_app` functions would only run once the `with` block exited rather than when the request exited. Along with using `with client` around everything, this was already the source of occasional bug reports and questions. The docs also say that no assumptions should be made about how many times a teardown function will be called or what data will be set for them.

Also, `g` was part of the app context, not the request context. Data could be set on `g` ahead of the request, because a new app context wouldn't be pushed. This was never documented, I don't know where I saw it.

```python
# do not do this, for example only
with app.app_context():
    g.user = test_user
    r = client.get(""/secret"")
```

It's not in Flask's docs or tests. The docs show making a request to login before making the request being tested, relying on the session to persist across requests. If you _really_ wanted to set up `g` beforehand, the signal docs show using the `appcontext_pushed` signal to modify the current context's `g` once it's created.

A project may run into some failed tests when upgrading, if they were relying on this. However, the failure would indicate patterns that were already unsound and should be fixed, so I don't see this as a blocker.

Interestingly, `copy_current_request_context` was already not copying `g`. I thought about changing this, but concluded that it was a good thing, because `g` is often used to store connections/caches that are not concurrent safe, such as Flask-SQLAlchemy's `db.session`.",merges requestcontext class appcontext class close lot size rewriting cleaning doc related context see ctxpy bulk work even pretty much new code mostly deduplication request context still exists data available context object distinguishes app context user work context pretty much unchanged example teardownrequest teardownappcontext still exist appappcontext apptestrequestcontext etc global proxy currentapp request session still exist still available situation difference longer track whether app context already pushed pushing request context already sort artificial behavior something would ever happen intendeddocumented request testing scenario every request always set app request request data given greatly simplifies internal data simply need record previous value context var restore pop code app internals changed use contextvar directly code already probably gain tiny bit performance rather going proxy ahead beyond well passing around context object directly wont even need use contextvar implication testing may used appappcontext around test client request ive already highly discouraged practice issue year already causing issue none pattern doc old behavior app context pushed one already pushed pushing request context therefore teardownapp function would run block exited rather request exited along using client around everything already source occasional bug report question doc also say assumption made many time teardown function called data set also part app context request context data could set ahead request new app context wouldnt pushed never documented dont know saw python example appappcontext guser testuser clientgetsecret flask doc test doc show making request login making request tested relying session persist across request really wanted set beforehand signal doc show using appcontextpushed signal modify current context created project may run failed test upgrading relying however failure would indicate pattern already unsound fixed dont see blocker interestingly copycurrentrequestcontext already copying thought changing concluded good thing often used store connectionscaches concurrent safe flasksqlalchemys dbsession,Negativo,2
flask,5812,Pull Request,Comentario,Would be great if some people could test their apps with this branch. I'll plan to merge it a week from now.,would great people could test apps branch ill plan merge week,Positivo,2
flask,5812,Pull Request,Comentario,"after `uv pip install 'git+https://github.com/pallets/flask@merge-contexts'` on [indico `master`](https://github.com/indico/indico):

- no errors at import time
- no errors when running the repl w/ all the indico stuff imported (`indico shell`)
- no errors accessing it via web (custom wrapper running the flask dev server)
- all tests still passing",pip install git indico master error import time error running repl indico stuff imported indico shell error accessing via web custom wrapper running flask dev server test still passing,Negativo,2
flask,5812,Pull Request,Comentario,Thanks to those who tested and left a üöÄ or commented on Mastodon. Having a big app like Indico pass unchanged is a good sign as well. Time to merge this.,thanks tested left commented mastodon big app like indico pas unchanged good sign well time merge,Positivo,4
flask,5639,Issue,Titulo,merge app and request contexts into a single context,merge app request context single context,Neutral,2
flask,5639,Issue,Descripcion,"Right now we have two separate contexts managed separately, the app and request contexts. This makes the implementation pretty complicated, as we need to maintain two context var stacks, and do a bunch of checks in the request context to make sure we're managing the correct app context. It makes an already confusing topic more complicated to explain: app context is active for requests and cli commands, don't push an app context before making a request, etc.

I think merging the two contexts could be possible. The single context (`ExecutionContext`?) would have the `g`, `request`, and `session` attributes, but accessing `request` or `session` when not in a request would raise an error.",right two separate context managed separately app request context make implementation pretty complicated need maintain two context var stack bunch check request context make sure managing correct app context make already confusing topic complicated explain app context active request cli command dont push app context making request etc think merging two context could possible single context executioncontext would request session attribute accessing request session request would raise error,Negativo,2
flask,5639,Issue,Comentario,"I was never clear on why, but the contexts support being pushed multiple times. If the same context is pushed multiple times, the teardown functions are only run once it's fully popped. I don't think I've ever seen this used, and I can't think of a use case. There is a test, but it just demonstrates that the system works, it doesn't demonstrate any intended use of it. There's no docs about it. Perhaps it's a holdover from how things were tracked as a stack on top of thread locals, before things were refactored?

Having to keep track of a stack of how many times a context has been pushed complicates the implementation, especially when the request context also has to track whether it had to push an app context as well or if one was already present. It would be much easier (and probably faster and less memory) to error if the context is currently pushed.

This is not the same as being able to push _different_ contexts on top of each other.",never clear context support pushed multiple time context pushed multiple time teardown function run fully popped dont think ive ever seen used cant think use case test demonstrates system work doesnt demonstrate intended use there doc perhaps holdover thing tracked stack top thread local thing refactored keep track stack many time context pushed complicates implementation especially request context also track whether push app context well one already present would much easier probably faster less memory error context currently pushed able push different context top,Positivo,2
flask,5639,Issue,Comentario,"Tentatively marking this for 3.2. I think I can do the merge and have uses of the old contexts issue deprecation warnings and redirect to the new context. Then it can be fully removed in a later release, maybe 4.0.",tentatively marking think merge us old context issue deprecation warning redirect new context fully removed later release maybe,Negativo,2
flask,5639,Issue,Comentario,"So far I've still been using the ""app context"" name for the new merged context. Couldn't think of a better term.

`teardown_appcontext` and `teardown_request` need to be combined, but they currently run at different times. `teardown_appcontext` runs in a `finally` block after `teardown_request` was attempted, and after `request` is no longer bound. The signals `appcontext_tearing_down` and `request_tearing_down` share the same timing.

I'd prefer to move away from the squished word ""appcontext"" to `teardown_context` and `context_tearing_down`. It's not clear whether `teardown_appcontext` or `teardown_request` is more commonly used right now, so it would probably be equally disruptive either way, since one of them is also getting removed.",far ive still using app context name new merged context couldnt think better term teardownappcontext teardownrequest need combined currently run different time teardownappcontext run finally block teardownrequest attempted request longer bound signal appcontexttearingdown requesttearingdown share timing prefer move away squished word appcontext teardowncontext contexttearingdown clear whether teardownappcontext teardownrequest commonly used right would probably equally disruptive either way since one also getting removed,Negativo,2
flask,5639,Issue,Comentario,"Perhaps steal some ideas from dishka 

For example request context could only be entered from a active app context 

Also a siebling to request context for usage in background workers might be nice to have 


To draw a pytest analogy app context is a bit like session scope and request context is a bit like function scope ",perhaps steal idea dishka example request context could entered active app context also siebling request context usage background worker might nice draw pytest analogy app context bit like session scope request context bit like function scope,Positivo,2
flask,5639,Issue,Comentario,"I might not have the full picture, however I don't see much value in merging them **from user's perspective**. I fully acknowledge that it might be a bit of a hell from developer's perspective :)

Logically, application and request contexts separate makes sense, maybe out of habit if nothing else.",might full picture however dont see much value merging user perspective fully acknowledge might bit hell developer perspective logically application request context separate make sense maybe habit nothing else,Negativo,2
flask,5639,Issue,Comentario,"> I was never clear on why, but the contexts support being pushed multiple times.

Far enough along now that I've run into why this was done. As far as I've found this is the only scenario where it's needed, only during testing. When using `stream_with_context` to re-push the context once reading the streaming response starts, along with `with context` to preserve the context after the request is over. These two both try to push the same context, first to keep the preserved context active, then to keep the context active during the stream.

Using a single reference to the previous context is indeed much simpler than two contexts each with a stack of references. With only one context, using a stack would be more straightforward than currently, but seems like unnecessary (but very minor) runtime overhead just to support this test scenario.  Need to experiment more.",never clear context support pushed multiple time far enough along ive run done far ive found scenario needed testing using streamwithcontext repush context reading streaming response start along context preserve context request two try push context first keep preserved context active keep context active stream using single reference previous context indeed much simpler two context stack reference one context using stack would straightforward currently seems like unnecessary minor runtime overhead support test scenario need experiment,Positivo,2
flask,5639,Issue,Comentario,"Keeping a simple integer count of how many times the context has been pushed/popped, and returning early if this is not the first push or last pop, fixes the issue.",keeping simple integer count many time context pushedpopped returning early first push last pop fix issue,Neutral,2
flask,5814,Pull Request,Titulo,this is issue here,issue,Neutral,2
flask,5814,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5814,Pull Request,Comentario,this new changing,new changing,Neutral,2
flask,5814,Pull Request,Comentario,Do not use public projects as your learning area. ,use public project learning area,Neutral,4
flask,5813,Pull Request,Titulo,Create codeql-analysis.yml,create codeqlanalysisyml,Positivo,2
flask,5813,Pull Request,Descripcion,"add this request on teacher

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",add request teacher opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5813,Pull Request,Comentario,here this add yam; file,add yam file,Neutral,2
flask,5813,Pull Request,Comentario,"Please share what exactly your teacher told you. it's either a misunderstanding on your side, or if he really asks students to open random PRs that are just noise in real projects, it's highly inappropriate and disrespectful towards maintainers on his side.",please share exactly teacher told either misunderstanding side really asks student open random pr noise real project highly inappropriate disrespectful towards maintainer side,Positivo,2
flask,5810,Pull Request,Titulo,Add various bugs for BugBot demo,add various bug bugbot demo,Neutral,2
flask,5810,Pull Request,Descripcion,"- Fix missing None check in get_debug_flag() that could cause AttributeError
- Fix assertion logic in MethodView.dispatch_request() for HEAD requests
- Fix missing return statement in get_send_file_max_age() method
- Fix typo in Config.__init__() - root_paths instead of root_path
- Fix incorrect test assertion in test_options_work()

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",fix missing none check getdebugflag could cause attributeerror fix assertion logic methodviewdispatchrequest head request fix missing return statement getsendfilemaxage method fix typo configinit rootpaths instead rootpath fix incorrect test assertion testoptionswork opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5811,Pull Request,Titulo,Add various bugs for BugBot demo,add various bug bugbot demo,Neutral,2
flask,5811,Pull Request,Descripcion,"- Fix missing None check in get_debug_flag() that could cause AttributeError
- Fix assertion logic in MethodView.dispatch_request() for HEAD requests
- Fix missing return statement in get_send_file_max_age() method
- Fix typo in Config.__init__() - root_paths instead of root_path
- Fix incorrect test assertion in test_options_work()

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",fix missing none check getdebugflag could cause attributeerror fix assertion logic methodviewdispatchrequest head request fix missing return statement getsendfilemaxage method fix typo configinit rootpaths instead rootpath fix incorrect test assertion testoptionswork opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5811,Pull Request,Comentario,"Sorry, I'm new to github and I create these two PRs by accident.",sorry new github create two pr accident,Negativo,2
flask,5809,Pull Request,Titulo,Added a line for first contributionme,added line first contributionme,Neutral,2
flask,5809,Pull Request,Descripcion,This is my first PR to practice open source contribution,first practice open source contribution,Neutral,4
flask,5809,Pull Request,Comentario,This is not a playground.,playground,Neutral,2
flask,5807,Pull Request,Titulo,Changed the static annotated type of select_jinja_autoescape method in src/flask/sansio/app.py,changed static annotated type selectjinjaautoescape method srcflasksansioapppy,Neutral,4
flask,5807,Pull Request,Descripcion,"Inside the code of the method the filename is checked against a None value and returns True, but the static annotated type is a str. I have changed the static annotation type to `str` to `str | None`.",inside code method filename checked none value return true static annotated type str changed static annotation type str str none,Positivo,4
flask,5807,Pull Request,Comentario,Closing the pull request,closing pull request,Neutral,2
flask,5806,Pull Request,Titulo,Changed the static annotated type of select_jinja_autoescape method in src/flask/sansio/app.py,changed static annotated type selectjinjaautoescape method srcflasksansioapppy,Neutral,4
flask,5806,Pull Request,Descripcion,"Inside the code of the method the filename is checked against a None value and returns True, but the static annotated type is a str. I have changed the static annotation type to `str` to `str | None`.",inside code method filename checked none value return true static annotated type str changed static annotation type str str none,Positivo,4
flask,5806,Pull Request,Comentario,Please target this type of change at the stable branch. ,please target type change stable branch,Positivo,4
flask,5806,Pull Request,Comentario,"Closing this pull request as a corresponding pull request is raised in the stable branch
https://github.com/pallets/flask/pull/5808",closing pull request corresponding pull request raised stable branch,Positivo,2
flask,5805,Pull Request,Titulo,feat(example/blog): Add flash messages for user feedback,featexampleblog add flash message user feedback,Neutral,2
flask,5805,Pull Request,Descripcion,"### Description
This PR adds flash messages (`created`, `updated`, `deleted`) to the blog example application in order to provide better user feedback after a post is modified. This improves the overall user experience.

### How This Was Tested
1. Ran the blog example application locally.
2. Created, updated, and deleted a post.
3. Verified that the appropriate success message was displayed at the top of the page after each action.",description add flash message created updated deleted blog example application order provide better user feedback post modified improves overall user experience tested ran blog example application locally created updated deleted post verified appropriate success message displayed top page action,Positivo,2
flask,5805,Pull Request,Comentario,Thank you for the review and I understand the goal of keeping the examples minimal. I appreciate you taking the time to look at my contribution!,thank review understand goal keeping example minimal appreciate taking time look contribution,Positivo,2
flask,5803,Issue,Titulo,`flask.testing` misleadingly appears to import `TestResponse`,flasktesting misleadingly appears import testresponse,Neutral,2
flask,5803,Issue,Descripcion,"`testing.py` contains the following:
```python
if t.TYPE_CHECKING:  # pragma: no cover
    from werkzeug.test import TestResponse
```
As such, any IDE or static checker will consider this to be valid code:
```python
import flask.testing as _flask_test

def my_test_helper(flask_test_client: _flask_test.FlaskClient) -> _flask_test.TestResponse:
    ...
```

However, at runtime, this code will fail, because `TestResponse` is not actually imported into the `flask.testing` namespace.

Possible solutions:
- Move `from werkzeug.test import TestResponse` outside the `if t.TYPE_CHECKING` block; you're already importing `werkzeug.test` in that file anyway
- Remove `from werkzeug.test import TestResponse` entirely and replace `TestResponse` with `werkzeug.test.TestResponse` in type-hints
- Change `from werkzeug.test import TestResponse` to `from werkzeug.test import TestResponse as _TestResponse`; the leading underscore signals marks the import as private, at which point it doesn't matter if its really imported or not because nobody should be using it from outside the file
",testingpy contains following python ttypechecking pragma cover werkzeugtest import testresponse ide static checker consider valid code python import flasktesting flasktest def mytesthelperflasktestclient flasktestflaskclient flasktesttestresponse however runtime code fail testresponse actually imported flasktesting namespace possible solution move werkzeugtest import testresponse outside ttypechecking block youre already importing werkzeugtest file anyway remove werkzeugtest import testresponse entirely replace testresponse werkzeugtesttestresponse typehints change werkzeugtest import testresponse werkzeugtest import testresponse testresponse leading underscore signal mark import private point doesnt matter really imported nobody using outside file,Negativo,2
flask,5803,Issue,Comentario,"That's a bug to report to the IDE that is saying it's valid. Importing names but not exporting them is a normal and valid pattern in pretty much all code, not just flask. ",thats bug report ide saying valid importing name exporting normal valid pattern pretty much code flask,Positivo,2
flask,5803,Issue,Comentario,"> That's a bug to report to the IDE that is saying it's valid. Importing names but not exporting them is a normal and valid pattern in pretty much all code, not just flask.

No, it's a standard part of Python. If you import a module, you import all the items in that module, unless they are marked as private via the convention of a leading underscore on the name. Indeed, many modules import many objects with the explicit intent that users will access them via that module. Most often, but not exclusively, that happens in `__init__.py`, but it can and does happen anywhere.",thats bug report ide saying valid importing name exporting normal valid pattern pretty much code flask standard part python import module import item module unless marked private via convention leading underscore name indeed many module import many object explicit intent user access via module often exclusively happens initpy happen anywhere,Positivo,2
flask,5802,Pull Request,Titulo,Add CodeQL scan workflow,add codeql scan workflow,Neutral,2
flask,5802,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5802,Pull Request,Comentario,"This pull request sets up GitHub code scanning for this repository. Once the scans have completed and the checks have passed, the analysis results for this pull request branch will appear on [this overview](/pallets/flask/security/code-scanning?query=pr%3A5802+is%3Aopen). Once you merge this pull request, the 'Security' tab will show more code scanning analysis results (for example, for the default branch). Depending on your configuration and choice of analysis tool, future pull requests will be annotated with code scanning analysis results. For more information about GitHub code scanning, check out [the documentation](https://docs.github.com/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning). ",pull request set github code scanning repository scan completed check passed analysis result pull request branch appear overviewpalletsflasksecuritycodescanningquerypraisaopen merge pull request security tab show code scanning analysis result example default branch depending configuration choice analysis tool future pull request annotated code scanning analysis result information github code scanning check documentation,Neutral,2
flask,5802,Pull Request,Comentario,"Do not make unsolicited changes to our project configuration.

Also FYI, the analysis it produced is complete junk.",make unsolicited change project configuration also fyi analysis produced complete junk,Positivo,2
flask,5801,Pull Request,Titulo,Add DEVOPS_NOTES.txt for practice,add devopsnotestxt practice,Neutral,2
flask,5801,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
",opening open ticket describing issue feature address issue required fixing typo documentation simple noncode change replace comment description change describe address linked ticket link relevant issue previous pr one per line use fix automatically close issue fix issue number ensure step contributingrst complete especially following add test demonstrate correct behavior change test fail without change add update relevant doc doc folder code add entry changesrst summarizing change linking issue add versionchanged entry relevant code doc,Negativo,0
flask,5801,Pull Request,Comentario,Do not use other people's repositories for learning how to use Git or GitHub. Create your own repo which is NOT a fork of someone else's repo to test PRs.,use people repository learning use git github create repo fork someone elses repo test pr,Positivo,2
flask,5774,Issue,Titulo,`stream_with_context` does not work with async routes,streamwithcontext work async route,Neutral,3
flask,5774,Issue,Descripcion,"Consider this trivial route + test in `app.py`:

```python
import flask
from flask import Flask
from flask import Response

import pytest

app = Flask(__name__)


@app.route(""/foo"")
async def foo():
    def gen():
        yield ""bar""

    return Response(flask.stream_with_context(gen()))


def test_foo():
    with app.test_client() as client:
        client.get(""/foo"")
```

With the following `requirements.txt`:

```
flask[async]==3.1.1
pytest==8.4.1
werkzeug==3.1.3
```

Running `pytest app.py` results in:

```
============================= test session starts ==============================
platform darwin -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0
rootdir: /private/tmp/stream_with_context
collected 1 item

app.py F                                                                 [100%]

=================================== FAILURES ===================================
___________________________________ test_foo ___________________________________

    def test_foo():
        with app.test_client() as client:
>           client.get(""/foo"")

app.py:20:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv/lib/python3.12/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/flask/testing.py:235: in open
    response = super().open(
venv/lib/python3.12/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/flask/app.py:1527: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <RequestContext 'http://localhost/foo' [GET] of app>, exc = None

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """"""Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.

        .. versionchanged:: 0.9
           Added the `exc` argument.
        """"""
        clear_request = len(self._cv_tokens) == 1

        try:
            if clear_request:
                if exc is _sentinel:
                    exc = sys.exc_info()[1]
                self.app.do_teardown_request(exc)

                request_close = getattr(self.request, ""close"", None)
                if request_close is not None:
                    request_close()
        finally:
            ctx = _cv_request.get()
            token, app_ctx = self._cv_tokens.pop()
>           _cv_request.reset(token)
E           ValueError: <Token var=<ContextVar name='flask.request_ctx' at 0x103cd9a30> at 0x104b23a40> was created in a different Context

venv/lib/python3.12/site-packages/flask/ctx.py:418: ValueError
=========================== short test summary info ============================
FAILED app.py::test_foo - ValueError: <Token var=<ContextVar name='flask.request_ctx' at 0x103cd9a30>...
============================== 1 failed in 0.11s ===============================
```

Similarly, `python -m flask run` and then `curl http://127.0.0.1:5000/foo` results in:

```
127.0.0.1 - - [15/Jul/2025 13:40:14] ""GET /foo HTTP/1.1"" 500 -
Error on request:
Traceback (most recent call last):
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/werkzeug/serving.py"", line 370, in run_wsgi
    execute(self.server.app)
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/werkzeug/serving.py"", line 331, in execute
    application_iter = app(environ, start_response)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/flask/app.py"", line 1536, in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/flask/app.py"", line 1527, in wsgi_app
    ctx.pop(error)
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/flask/ctx.py"", line 418, in pop
    _cv_request.reset(token)
ValueError: <Token var=<ContextVar name='flask.request_ctx' at 0x1029ccea0> at 0x1049e1980> was created in a different Context
```

If the route is defined `def foo():` without `async`, then this works without issue.

Or if we remove `stream_with_context` and just `return Response(gen())`, also works.

But the combination of `async` + `stream_with_context` fails.

There's also no issue with e.g. flask 2.1.0; I believe this was introduced in flask 2.2.0, specifically by #4682.

Environment:

- Python version: 3.12.11
- Flask version: 3.1.1",consider trivial route test apppy python import flask flask import flask flask import response import pytest app flaskname routefoo async def foo def gen yield bar return responseflaskstreamwithcontextgen def testfoo apptestclient client clientgetfoo following requirementstxt flaskasync pytest werkzeug running pytest apppy result test session start platform darwin python pytest pluggy rootdir privatetmpstreamwithcontext collected item apppy failure testfoo def testfoo apptestclient client clientgetfoo apppy venvlibpythonsitepackageswerkzeugtestpy get return selfopenargs venvlibpythonsitepackagesflasktestingpy open response superopen venvlibpythonsitepackageswerkzeugtestpy open responseparts selfrunwsgiapprequestenviron bufferedbuffered venvlibpythonsitepackageswerkzeugtestpy runwsgiapp runwsgiappselfapplication environ bufferedbuffered venvlibpythonsitepackageswerkzeugtestpy runwsgiapp apprv appenviron startresponse venvlibpythonsitepackagesflaskapppy call return selfwsgiappenviron startresponse venvlibpythonsitepackagesflaskapppy wsgiapp ctxpoperror self requestcontext get app exc none def popself exc baseexception none sentinel none type ignore pop request context unbinds also trigger execution function registered methflaskflaskteardownrequest decorator versionchanged added exc argument clearrequest lenselfcvtokens try clearrequest exc sentinel exc sysexcinfo selfappdoteardownrequestexc requestclose getattrselfrequest close none requestclose none requestclose finally ctx cvrequestget token appctx selfcvtokenspop cvrequestresettoken valueerror token varcontextvar nameflaskrequestctx xcda xba created different context venvlibpythonsitepackagesflaskctxpy valueerror short test summary info failed apppytestfoo valueerror token varcontextvar nameflaskrequestctx xcda failed similarly python flask run curl result jul get foo error request traceback recent call last file privatetmpstreamwithcontextvenvlibpythonsitepackageswerkzeugservingpy line runwsgi executeselfserverapp file privatetmpstreamwithcontextvenvlibpythonsitepackageswerkzeugservingpy line execute applicationiter appenviron startresponse file privatetmpstreamwithcontextvenvlibpythonsitepackagesflaskapppy line call return selfwsgiappenviron startresponse file privatetmpstreamwithcontextvenvlibpythonsitepackagesflaskapppy line wsgiapp ctxpoperror file privatetmpstreamwithcontextvenvlibpythonsitepackagesflaskctxpy line pop cvrequestresettoken valueerror token varcontextvar nameflaskrequestctx xccea created different context route defined def foo without async work without issue remove streamwithcontext return responsegen also work combination async streamwithcontext fails there also issue flask believe introduced flask specifically environment python version flask version,Negativo,2
flask,5774,Issue,Comentario,"I don't think this can be supported. `Response`, which comes from Werkzeug, expects a sync iterable, not an async one. I'm pretty sure it is possible to stream async responses with context, but just not by using the `Response(stream(gen))` pattern. Maybe @pgjones can point you to the exact pattern.",dont think supported response come werkzeug expects sync iterable async one pretty sure possible stream async response context using responsestreamgen pattern maybe point exact pattern,Positivo,3
flask,5774,Issue,Comentario,"Never mind, this is a specific fixable issue with `stream_with_context`, not an issue with async views. Thanks for finding the PR that affected it, when I took another look at this it put me on the right path.

The problem is related to how we automatically push an app context when pushing a request context. If an app context is not already pushed, we create one and push it, recording that we should pop it when the request context is popped. We store this using `ContextVars`, which are sensitive to the async loop/thread they were modified from. The order that pushes and pops happens in is important, and is pretty complex when dealing with the request/response, stream with context, and test client context preservation all at once.

The immediate issue you reported is because of when `stream_with_context` was pushing the request. It would push it as soon as the generator started, and in the case of an async view it is running in a temporary async loop context only for that view function. Therefore, when we went to pop it later during cleanup and test client, the context it was pushed in no longer matched the current context.

That can be fixed by adjusting when the context is pushed to when the streaming response starts, rather than when the generator starts. But this resulted in another error, because at that point the app context had already been cleaned up, but recorded for client preservation. So the generator would automatically push a new app context, then things would get cleaned up in the wrong order.

That can be fixed by pushing the app and request contexts separately in `stream_with_context`, so that the request context will not automatically add or clean up the app context.

There's a comment in `stream_with_context` saying that pushing at the point it was is intentional and required for correct operation. But as far as I can tell with further test scenarios, everything works correctly with the change. Perhaps it was required before that PR changed how things worked.

Phew üòÆ‚Äçüí®",never mind specific fixable issue streamwithcontext issue async view thanks finding affected took another look put right path problem related automatically push app context pushing request context app context already pushed create one push recording pop request context popped store using contextvars sensitive async loopthread modified order push pop happens important pretty complex dealing requestresponse stream context test client context preservation immediate issue reported streamwithcontext pushing request would push soon generator started case async view running temporary async loop context view function therefore went pop later cleanup test client context pushed longer matched current context fixed adjusting context pushed streaming response start rather generator start resulted another error point app context already cleaned recorded client preservation generator would automatically push new app context thing would get cleaned wrong order fixed pushing app request context separately streamwithcontext request context automatically add clean app context there comment streamwithcontext saying pushing point intentional required correct operation far tell test scenario everything work correctly change perhaps required changed thing worked phew,Negativo,2
flask,5774,Issue,Comentario,thank you for fixing!,thank fixing,Positivo,2
flask,5799,Pull Request,Titulo,refactor stream_with_context for async views,refactor streamwithcontext async view,Neutral,3
flask,5799,Pull Request,Descripcion,"Store the app context as well as the request context when creating the generator. This prevents the request context from automatically creating and pushing a different app context. Then push the app context first, and push them only when iteration starts, not during setup. This prevents the request context from automatically popping the app context, and avoids associating the internal ContextVar with the temporary event loop in async views.

fixes #5774",store app context well request context creating generator prevents request context automatically creating pushing different app context push app context first push iteration start setup prevents request context automatically popping app context avoids associating internal contextvar temporary event loop async view fix,Positivo,2
