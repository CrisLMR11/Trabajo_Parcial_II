repo,id_referencia,tipo_origen,tipo_mensaje,texto
flask,5910,Pull Request,Titulo,ü§ñ Automated code quality improvements (5 fixes)
flask,5910,Pull Request,Descripcion,"## ü§ñ Automated Code Quality Improvements

This PR contains automated fixes for code quality issues detected in the repository.

### üìä Summary of Fixes

| Category | Count |
|----------|-------|
| Syntax Errors/Bugs | 42 |
| Security Vulnerabilities | 62 |
| Code Style Violations | 1126 |
| Performance Issues | 0 |
| Unused Code | 164 |
| Code Duplication | 1 |
| Error Handling | 0 |
| **Total** | **1395** |

### üîß Fixes Applied

1. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_basic.py:1365` - Using variable 'error' before assignment
2. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_config.py:129` - Too many positional arguments for method call
3. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_cli.py:54` - class already defined line 49
4. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_cli.py:59` - class already defined line 49
5. üêõ **BUG** `/tmp/code-fixer-20260206-135038/tests/test_cli.py:64` - class already defined line 49

### ‚úÖ Verification

All fixes have been automatically applied and tested. Please review the changes and merge if appropriate.

---
*Generated by GitHub Code Fixer*
"
flask,5910,Pull Request,Comentario,"Closing this PR - it was a test of my automated code quality improvement tool. 
   Thank you for the opportunity to test on Flask! üôè"
flask,5910,Pull Request,Comentario,"please create test prs against own repos, they waste attention and time of maintainers"
flask,5891,Pull Request,Titulo,docs: clarify 415 vs 400 errors for Request.json
flask,5891,Pull Request,Descripcion,"Fixes #5825

## Summary
Clarified the documentation for `Request.json` to distinguish between the two error cases:
- **415 Unsupported Media Type**: Raised when the `Content-Type` header is not set to `application/json`
- **400 Bad Request**: Raised when the body is not valid JSON

## Changes
Updated `docs/patterns/javascript.rst` in the ""Receiving JSON in Views"" section to accurately reflect these two distinct error codes, making it consistent with the API reference documentation.

## Test Plan
- [x] Verified the change matches the Flask API documentation behavior
- [x] Confirmed the reStructuredText syntax is correct
- [x] Checked that both error conditions are now clearly documented

---
ü§ñ Generated with [Solari AGI](https://github.com/SolariSystems)"
flask,5892,Pull Request,Titulo,docs: improve wording in appdispatch
flask,5892,Pull Request,Descripcion,"- Clarify wording in Application Dispatching docs (docs/patterns/appdispatch.rst).
- No functional changes.
"
flask,5892,Pull Request,Comentario,Hi! This PR improves wording in the Application Dispatching documentation for clarity. Thanks!
flask,5893,Pull Request,Titulo,fix: Clarify Request.json error handling
flask,5893,Pull Request,Descripcion,"Fixes #5825

## Summary
Clarify Request.json error handling

## Changes Made
Modified files to address the issue requirements as described in #5825.

## Testing
Validation passed for these changes.
"
flask,5890,Pull Request,Titulo,Improve templating documentation for clarity and readability
flask,5890,Pull Request,Descripcion,"This PR updates the templating documentation to improve clarity for new
readers while maintaining technical accuracy.

Changes include:
- Rephrased sections describing autoescaping behavior
- Added structured explanation of template streaming
- Reformatted code examples for consistency
- Added contextual notes for template utility functions
- Improved explanation of `url_for` with example usage

These revisions aim to make the documentation more beginner-friendly and
easier to follow without reducing detail.

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5902,Issue,Titulo,Improve alt text for Debug Mode interactive debugger image (accessibility)
flask,5902,Issue,Descripcion,"
In the Flask documentation section [‚ÄúDebug Mode‚Äù](https://flask.palletsprojects.com/en/stable/quickstart/#debug-mode), there is an image demonstrating the interactive debugger with the following markup:
```
<img alt=""The interactive debugger in action.""
     class=""screenshot align-center""
     src=""../_images/debugger.png"">  
```
The alt text is very generic and does not clearly describe the content or purpose of the image.
For users who rely on screen readers, the current alt text does not convey that this is a Flask error page shown in the browser
This makes the documentation less accessible for users with visual impairments and does not fully meet the intent of WCAG 1.1.1 (Non-text Content)

**Suggested improvement**
Replace the existing alt text with something more descriptive, for example:
‚ÄúFlask debug mode error page showing a Python traceback and an interactive debugger panel in the browser"
flask,5902,Issue,Comentario,"Hello @davidism,
Thank you for taking the time to review the issue,  I understand that maintaining the project involves careful prioritization.

I wanted to briefly highlight that this suggestion is motivated by accessibility considerations. There are developers who rely on assistive technologies such as screen readers or alternative navigation methods to work effectively. For them, even small accessibility-related details can have a significant impact on usability and inclusion.

From that perspective, accessibility improvements aren‚Äôt just cosmetic; they help ensure that the project remains usable by a broader and more diverse developer community. This also aligns with long-term project quality and inclusiveness.

I‚Äôm personally very interested in accessibility and would be happy to contribute if there‚Äôs a preferred approach or scope for such improvements within the project. Any guidance would be greatly appreciated.

Thank you again for your work on the project and for considering this perspective."
flask,5889,Pull Request,Titulo,Revise Jinja templating documentation for clarity and readability
flask,5889,Pull Request,Descripcion,"This PR updates the templating documentation to improve clarity for new
readers while maintaining technical accuracy.

Changes include:
- Rephrased sections describing autoescaping behavior
- Added structured explanation of template streaming
- Reformatted code examples for consistency
- Added contextual notes for template utility functions
- Improved explanation of `url_for` with example usage

These revisions aim to make the documentation more beginner-friendly and
easier to follow without reducing detail.

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5908,Pull Request,Titulo,style: format response tuple unpacking (extract helper)
flask,5908,Pull Request,Descripcion,"## Summary

Refactors the response tuple unpacking logic in `make_response` into a small
private helper method to improve readability and maintainability.

No behavior changes are intended.

##Fixes #5907 
## Details

The existing tuple-unpacking logic inside `make_response` was moved into a
dedicated private helper method. This keeps the method shorter and easier to
reason about, without changing any runtime behavior.

## Testing

- All existing tests pass.
- No new tests were added, as this change does not affect behavior.

## Notes

This is an internal refactor only. No public API or documented behavior is
changed.
"
flask,5907,Issue,Titulo,Internal refactor: simplify response tuple unpacking in make_response in app.py
flask,5907,Issue,Descripcion,"This is an internal, non-user-facing refactor.

The `make_response` method currently contains inline logic to unpack
response tuples with different valid shapes. While this logic is correct,
it is dense and increases cognitive load in an already large method.

Refactoring this logic into a small private helper would improve
readability and long-term maintainability without changing behavior.

The current tuple unpacking logic handles multiple valid forms
((body, status, headers), (body, status), (body, headers)) inline inside
`make_response`. This makes the control flow harder to follow and
duplicates validation responsibilities within the method.

This is not easily improved via subclassing or extensions, as the logic
is internal to Flask's response handling. A small internal refactor would
isolate this responsibility and make future maintenance safer.
"
flask,5906,Pull Request,Titulo,Added a return type annotation to an internal utility function in the Requests library to improve code readability and static analysis without affecting behavior.
flask,5906,Pull Request,Descripcion,"Improved Flask documentation by clarifying JSON request requirements,
helping new users avoid common request-handling issues."
flask,5888,Pull Request,Titulo,Docs: add context to Incoming Request Data section
flask,5888,Pull Request,Descripcion,":wq

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5888,Pull Request,Comentario,"Thanks for the thoughtful review!

You‚Äôre right about the consistency across sections. My intention here was to
improve clarity for readers in a section that jumps directly into the API
reference, similar to how the Sessions and Application Globals sections
provide
brief context.

I wanted to keep the scope of this PR minimal as a first contribution, but
I‚Äôm
happy to adjust the wording to better match the existing style, or extend
similar
introductory context to other major sections if that‚Äôs preferred.

Please let me know what approach you‚Äôd recommend.

On Fri, Jan 16, 2026 at 3:05‚ÄØAM Copilot ***@***.***> wrote:

> ***@***.**** commented on this pull request.
> Pull request overview
>
> This PR adds introductory context to the ""Incoming Request Data"" section
> in the Flask API documentation. The changes aim to help developers better
> understand what the section covers and the purpose of the request proxy
> object before diving into the detailed API reference.
>
> *Changes:*
>
>    - Added an introductory paragraph to the ""Incoming Request Data""
>    section explaining its purpose
>    - Enhanced the request proxy documentation with a clarifying sentence
>    about its role in view functions
>
> ------------------------------
>
> üí° Add Copilot custom instructions
> <http:///pallets/flask/new/main/.github/instructions?filename=*.instructions.md>
> for smarter, more guided reviews. Learn how to get started
> <https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot>
> .
> ------------------------------
>
> In docs/api.rst
> <https://github.com/pallets/flask/pull/5888#discussion_r2696041318>:
>
> > +This section describes how to access data sent by the client in an HTTP
> +request, such as query parameters, form data, JSON payloads, and headers.
>
> Consider adding consistency with other sections. The 'Sessions' section
> (lines 59-67) and 'Application Globals' section (lines 151-156) also have
> introductory paragraphs. However, 'Application Object', 'Blueprint
> Objects', and 'Response Objects' sections do not. While this addition is
> helpful, it creates inconsistency. Consider either adding similar
> introductions to other major sections or ensuring the current style aligns
> with the documentation's overall approach.
>
> ‚Äî
> Reply to this email directly, view it on GitHub
> <https://github.com/pallets/flask/pull/5888#pullrequestreview-3667685341>,
> or unsubscribe
> <https://github.com/notifications/unsubscribe-auth/BZY6ACYOVMCD6YE7YVTP7JT4HABZ3AVCNFSM6AAAAACR264P3WVHI2DSMVQWIX3LMV43YUDVNRWFEZLROVSXG5CSMV3GSZLXHMZTMNRXGY4DKMZUGE>
> .
> You are receiving this because you authored the thread.Message ID:
> ***@***.***>
>
"
flask,5903,Pull Request,Titulo,Abort if the instance folder cannot be created
flask,5903,Pull Request,Descripcion,"According to the comment, the instance folder should exist in any case. But a PermissionError was ignored silently.

Since Python 3.9 is the minimum required version, it is safe to use ""exist_ok"" added in Python 3.2 and avoid exception handling."
flask,5903,Pull Request,Comentario,"Make sure you update the code in the `examples` dir as well. Does any surrounding text need to be updated? Docs changes should be targetted at stable, so that they're available in the current docs."
flask,5903,Pull Request,Comentario,"My branch was already based on `stable`, but it got wrong in the PR. I fixed that.

Code in `examples/` had already been updated, no further surrounding text needs changes, even the `os.makedirs` description further below fits better than before.

The surrounding code in `examples/` already wasn't in sync with the docs, though."
flask,5887,Issue,Titulo,Add explicit support for async teardown_request handlers
flask,5887,Issue,Descripcion,"### Summary

At the moment, `teardown_request` handlers in Flask are synchronous and cannot be defined as async functions. This makes it harder for apps that depend on async cleanup logic (e.g., closing async DB connections or awaiting async tasks) to integrate cleanly with Flask‚Äôs request lifecycle.

### Problem

When users attempt to define an async teardown handler like:

```python
@app.teardown_request
async def cleanup_async_resources(response):
    await close_async_connections()
```

Flask does not await it and treats it as a regular function, leading to unawaited coroutine warnings and the async cleanup not running as intended.

### Proposed Solution
Make teardown handlers awaitable - if a handler is declared async, Flask should await it during the teardown phase.

### Example
```python
@app.teardown_request
async def cleanup_async_resources(response):
    await some_async_cleanup()  # should be awaited before response is finalized
```

### Motivation
Better async integration support as more frameworks and applications adopt async patterns. This would make Flask‚Äôs async support more complete and intuitive.

### Environment

```python
Flask version: (e.g., 3.2.x)
Python version: 3.9+
```

Async libs used: Any

### Thanks!"
flask,5887,Issue,Comentario,"This already works. https://flask.palletsprojects.com/en/stable/async-await/

Do not use LLM tools to generate issues on your behalf."
flask,5897,Issue,Titulo,package detection fails with namespace package in editable mode
flask,5897,Issue,Descripcion,"Given a package which uses namespace packaging and has been installed using ""editable installs"", Flask's scaffold (specifically `_find_package_path`) will error if the name passed to `Flask(...)` is the package name rather than a sub-module.

This affects cases where the name is the name of the package (and thus potentially not actually the `__name__`) though also happens when using `__name__` and the app is defined within a `__init__.py` in the root of the namespaced package.

Notably the issue only appears when importing the app elsewhere -- running from a python process launched at the parent of the namespace package tree hides this.

Example project:
```
‚îú‚îÄ‚îÄ flask-app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ setup.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ sr
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ comp
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ http
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ __init__.pyi
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ __init__.pyi
‚îî‚îÄ‚îÄ run.py
```
The `__init__.pyi` files are empty and shouldn't be needed, however are present in my original project as typing markers.

```python
# run.py
print("""")
print(""run.py"")
print("""")

from sr.comp.http import app

print("""")
print(""/run.py"")
print("""")
```
```python
# flask-app/sr/comp/http/__init__.py
from flask import Flask

print(""app = Flask(__name__)"")
app = Flask(__name__)  # reproduces when defined in __init__.py

print(""app = Flask('sr.comp.http')"")
app = Flask(""sr.comp.http"")  # reproduces when defined in e.g: server.py and `app` is re-exported via __init__.py
# this latter case was my original case

@app.route(""/"")
def hello():
    return ""Hello, World!""
```

<details>
<summary><code>flask-app/setup.py</code></summary>

``` python
# flask-app/setup.py
from setuptools import find_namespace_packages, setup

setup(
    name='sr.comp.http',
    packages=find_namespace_packages(include=['sr.*']),
    namespace_packages=['sr', 'sr.comp'],
    install_requires=[
        'Flask >=2.2',
    ],
)
```

</details>

The error is:
```
Traceback (most recent call last):
  File ""/home/peter/play/flask-play/run.py"", line 6, in <module>
    from sr.comp.http import app
  File ""/home/peter/play/flask-play/flask-app/sr/comp/http/__init__.py"", line 5, in <module>
    app = Flask(__name__)
          ^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/app.py"", line 239, in __init__
    super().__init__(
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 304, in __init__
    instance_path = self.auto_find_instance_path()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 518, in auto_find_instance_path
    prefix, package_path = find_package(self.import_name)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 783, in find_package
    package_path = _find_package_path(import_name)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 748, in _find_package_path
    search_location = next(
                      ^^^^^
StopIteration
```

I've been testing this by running the following to compare against a non-editable install:
``` shell
pip install flask-app/ && python run.py && pip install -e flask-app/ && python run.py
```

I've also made some modifications to `flask/sansio/scaffold.py` to debug, which provides some insight. It looks like the issue is to do with whether or not the `package_path` is found to be relative to the `package_spec.submodule_search_locations`.

<details>
<summary><code>scaffold.py</code> diff</summary>

```diff
@@ -708,7 +708,10 @@
 
 def _find_package_path(import_name: str) -> str:
     """"""Find the path that contains the package or module.""""""
+    print()
+    print(f""_find_package_path({import_name=})"")
     root_mod_name, _, _ = import_name.partition(""."")
+    print(f""_find_package_path: {root_mod_name=}"")
 
     try:
         root_spec = importlib.util.find_spec(root_mod_name)
@@ -721,18 +724,27 @@
         #    - the module name was invalid
         #    - the module name is __main__
         #    - we raised `ValueError` due to `root_spec` being `None`
+        print(""CWD"")
         return os.getcwd()
 
     if root_spec.submodule_search_locations:
         if root_spec.origin is None or root_spec.origin == ""namespace"":
             # namespace package
             package_spec = importlib.util.find_spec(import_name)
+            print(f""{package_spec=}"")
 
             if package_spec is not None and package_spec.submodule_search_locations:
                 # Pick the path in the namespace that contains the submodule.
                 package_path = pathlib.Path(
                     os.path.commonpath(package_spec.submodule_search_locations)
                 )
+                print(f""{package_path=}"")
+                search_locations=[
+                    location
+                    for location in root_spec.submodule_search_locations
+                    if package_path.is_relative_to(location)
+                ]
+                print(f""{search_locations=}"")
                 search_location = next(
                     location
                     for location in root_spec.submodule_search_locations
@@ -740,14 +752,18 @@
                 )
             else:
                 # Pick the first path.
+                print(""Picking the first path"")
                 search_location = root_spec.submodule_search_locations[0]
 
+            print(f""{os.path.dirname(search_location)=}"")
             return os.path.dirname(search_location)
         else:
             # package with __init__.py
+            print(f""package with __init__.py: {os.path.dirname(os.path.dirname(root_spec.origin))=}"")
             return os.path.dirname(os.path.dirname(root_spec.origin))
     else:
         # module
+        print(f""module: {os.path.dirname(root_spec.origin)=}"")
         return os.path.dirname(root_spec.origin)  # type: ignore[type-var, return-value]
 
 
```

</details>

<details>
<summary>Full output (with scaffold printing)</summary>

```
Processing ./flask-app
  Installing build dependencies ... done
  Getting requirements to build wheel ... done
  Preparing metadata (pyproject.toml) ... done
Requirement already satisfied: Flask>=2.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from sr.comp.http==0.0.0) (3.1.2)
Requirement already satisfied: blinker>=1.9.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (1.9.0)
Requirement already satisfied: click>=8.1.3 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (8.3.1)
Requirement already satisfied: itsdangerous>=2.2.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (2.2.0)
Requirement already satisfied: jinja2>=3.1.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.6)
Requirement already satisfied: markupsafe>=2.1.1 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.0.3)
Requirement already satisfied: werkzeug>=3.1.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.5)
Building wheels for collected packages: sr.comp.http
  Building wheel for sr.comp.http (pyproject.toml) ... done
  Created wheel for sr.comp.http: filename=sr_comp_http-0.0.0-py3-none-any.whl size=2244 sha256=3f8b9ef6c2be19dfe215b2c753e08eba17f1d351d8990a453ee57f25b6554bad
  Stored in directory: /home/peter/.cache/pip/wheels/cd/9c/02/1c78322e6692d753ef839820d853e11679311f30eec26b3432
Successfully built sr.comp.http
Installing collected packages: sr.comp.http
  Attempting uninstall: sr.comp.http
    Found existing installation: sr.comp.http 0.0.0
    Uninstalling sr.comp.http-0.0.0:
      Successfully uninstalled sr.comp.http-0.0.0
Successfully installed sr.comp.http-0.0.0

run.py

app = Flask(__name__)

_find_package_path(import_name='sr.comp.http')
_find_package_path: root_mod_name='sr'
package_spec=ModuleSpec(name='sr.comp.http', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7b2244ea6c50>, origin='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http/__init__.py', submodule_search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http'])
package_path=PosixPath('/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http')
search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr']
os.path.dirname(search_location)='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages'
app = Flask('sr.comp.http')

_find_package_path(import_name='sr.comp.http')
_find_package_path: root_mod_name='sr'
package_spec=ModuleSpec(name='sr.comp.http', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7b2244ea6c50>, origin='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http/__init__.py', submodule_search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http'])
package_path=PosixPath('/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr/comp/http')
search_locations=['/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/sr']
os.path.dirname(search_location)='/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages'

/run.py

Obtaining file:///home/peter/play/flask-play/flask-app
  Installing build dependencies ... done
  Checking if build backend supports build_editable ... done
  Getting requirements to build editable ... done
  Preparing editable metadata (pyproject.toml) ... done
Requirement already satisfied: Flask>=2.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from sr.comp.http==0.0.0) (3.1.2)
Requirement already satisfied: blinker>=1.9.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (1.9.0)
Requirement already satisfied: click>=8.1.3 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (8.3.1)
Requirement already satisfied: itsdangerous>=2.2.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (2.2.0)
Requirement already satisfied: jinja2>=3.1.2 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.6)
Requirement already satisfied: markupsafe>=2.1.1 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.0.3)
Requirement already satisfied: werkzeug>=3.1.0 in /home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages (from Flask>=2.2->sr.comp.http==0.0.0) (3.1.5)
Building wheels for collected packages: sr.comp.http
  Building editable for sr.comp.http (pyproject.toml) ... done
  Created wheel for sr.comp.http: filename=sr_comp_http-0.0.0-0.editable-py3-none-any.whl size=3459 sha256=a216bf634bddcae47327c746fe989a8a4115384810f305d565bb098311dbaeaa
  Stored in directory: /tmp/pip-ephem-wheel-cache-6dk2qx5_/wheels/cd/9c/02/1c78322e6692d753ef839820d853e11679311f30eec26b3432
Successfully built sr.comp.http
Installing collected packages: sr.comp.http
  Attempting uninstall: sr.comp.http
    Found existing installation: sr.comp.http 0.0.0
    Uninstalling sr.comp.http-0.0.0:
      Successfully uninstalled sr.comp.http-0.0.0
Successfully installed sr.comp.http-0.0.0

run.py

app = Flask(__name__)

_find_package_path(import_name='sr.comp.http')
_find_package_path: root_mod_name='sr'
package_spec=ModuleSpec(name='sr.comp.http', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7e0760a89f90>, origin='/home/peter/play/flask-play/flask-app/sr/comp/http/__init__.py', submodule_search_locations=['/home/peter/play/flask-play/flask-app/sr/comp/http'])
package_path=PosixPath('/home/peter/play/flask-play/flask-app/sr/comp/http')
search_locations=[]
Traceback (most recent call last):
  File ""/home/peter/play/flask-play/run.py"", line 6, in <module>
    from sr.comp.http import app
  File ""/home/peter/play/flask-play/flask-app/sr/comp/http/__init__.py"", line 5, in <module>
    app = Flask(__name__)
          ^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/app.py"", line 239, in __init__
    super().__init__(
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 304, in __init__
    instance_path = self.auto_find_instance_path()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/app.py"", line 518, in auto_find_instance_path
    prefix, package_path = find_package(self.import_name)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 783, in find_package
    package_path = _find_package_path(import_name)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/peter/.virtualenvs/flask-play/lib/python3.11/site-packages/flask/sansio/scaffold.py"", line 748, in _find_package_path
    search_location = next(
                      ^^^^^
StopIteration

```

</details>


Environment:

- Python version: 3.11 (and others)
- Flask version: 3.1.2, also 2.x
"
flask,5897,Issue,Comentario,"I can't reproduce this with the information provided. Thanks for providing a minimal example, but it's still a bit all over the place.

You're still using the old `setup.py` pattern, rather than using `pyproject.toml` with a `[build-system]` section. You're also using `namespace_packages`, which is the legacy pkg_resources pattern, and you're not calling the required legacy setup code in the init files, so installing your example gives an error `error in sr.comp.http setup command: Distribution contains no modules or packages for namespace package 'sr'`. You've also got an unsupported version of Flask listed, although it's just a lower bound, so the latest version gets installed.

Ignoring `namespace_packages` and just using `packages` (still with namespaces), both apps `__init__` and `server` work for me from `run.py` and with `flask run`. I think the problem is in your project configuration. Here's a modern update of your example that works:

<details>

```
example
‚îî‚îÄ‚îÄ run.py
‚îî‚îÄ‚îÄ app
    ‚îî‚îÄ‚îÄ pyproject.toml
    ‚îî‚îÄ‚îÄ src
        ‚îî‚îÄ‚îÄ sr
            ‚îî‚îÄ‚îÄ comp
                ‚îî‚îÄ‚îÄ http
                    ‚îî‚îÄ‚îÄ server.py
                    ‚îî‚îÄ‚îÄ __init__.py
```

`app/pyproject.toml`

```toml
[project]
name = ""sr.comp.http""
version = ""0.1.0""
description = """"
requires-python = "">=3.14""
dependencies = [
    ""flask"",
]

[build-system]
requires = [""uv_build>=0.9.26,<0.10.0""]
build-backend = ""uv_build""

[tool.uv.build-backend]
module-name = ""sr.comp.http""
```

`app/src/sr/comp/http/__init__.py`

```python
from flask import Flask

app = Flask(__name__)
```

`app/src/sr/comp/http/server.py`

```python
from flask import Flask

app = Flask(""sr.cmp.http"")
```

`run.py`

```python
from sr.comp.http import app

print(app.import_name)
```

```
uv venv
. ./.venv/bin/activate
uv pip install ./app
python run.py
```

You can examine `app/.venv/lib/python3.14/site-packages/sr` to confirm that it was installed as a namespace.

</details>"
flask,5897,Issue,Comentario,@davidism thanks for looking at this and apologies if the cut-down wasn't clear. Just to check -- does your example still not reproduce the issue if the package is installed in editable mode? (i.e: `pip install -e ./app`) For me the issue only reproduces when the package is installed in editable mode.
flask,5897,Issue,Comentario,Still works.
flask,5897,Issue,Comentario,"Hrm, it turns out my original case also required a ""flat layout"" (rather than a ""src layout"") though that doesn't change anything when using a `pyproject.toml` based install. I think the conclusion here is that something about the newer style editable install sets up the paths differently, which lets the code work.

I'm not sure why you were unable to reproduce the issue, though I'm happy to accept that I need to bite the bullet and change the build system in use. Thanks for investigating."
flask,5897,Issue,Comentario,"Without src works for me also. Your exact example works fine, minus the legacy config I mentioned. My example was just to show what I'd do now, since there were a lot of other legacy patterns being used. "
flask,5904,Pull Request,Titulo,Clarify data correctness explanation in quickstart
flask,5904,Pull Request,Descripcion,"Improved sentence clarity in the logging documentation without changing its meaning.
"
flask,5865,Pull Request,Titulo,Increase required flit_core version to 3.11
flask,5865,Pull Request,Descripcion,"Needed since Flask 3.1.1 after having set the ""license"" keyword to an SPDX license expression. Avoids this possible build error:

  flit_core.config.ConfigError: license field should be <class 'dict'>, not <class 'str'>

Fixes: 0109e496f (""use uv"").

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5427,Issue,Titulo,Keep code running after response has been sent. (To respond with HTTP requests to other servers) 
flask,5427,Issue,Descripcion,"Ability to send a response but continue execution.

An example of this problem is a backend Flask server which receives requests from another backend server, and returns one or more responses at different points in time. One such example is Telegram API.

https://core.telegram.org/bots/faq#how-can-i-make-requests-in-response-to-updates

While it is possible to simply send data back as an HTTP response, it is sometimes desirable to close the HTTP connection with a 200 to acknowledge the message has been received, and reopen a new connection for each response.

Here are some scenarios where this technique might be useful:

- Multiple messages are sent in a progressively more detailed nature, to ensure that errors in complex responses don't compromise simple responses. For example Response(""Hello"") Response (""Error"") Response(""Error 194:blablabla"")
- Separating messages carry a semantic meaning. For example: Response(""Ok so here's the plan\n We leave at 9 am \n ..."") != Response(""Ok so here's the plan"") Response(""We leave at 9 am"") Response(""..."")
- Responses may be scheduled for the future, well after the http connection closes by timeout.

Can we solve this without a builtin? Yeah sure, we can use threading or multiprocessing or libraries like celery. 

I think that the ideal solution is to integrate the multi threading into existing flask multithreading (Main server loop), and ideally integrating it into production one worker process per hardware core configurations to avoid both GIL issues and one process per request overheads.


"
flask,5427,Issue,Comentario,"That's now how HTTP works. There's one response (status code / headers). Of course you can send/stream whatever you want in the body, but it doesn't sound like you want to do that..."
flask,5427,Issue,Comentario,"Thanks for the response Adrian. 

I understand that each Request can only have one response. Not sure what would even happen if two responses are sent in response to one request, don't care.

What this thread is about is, recognizing that limitation, many server-to-server servers that need to send more than one response per request, effectively send nothing on the corresponding http response, but send new HTTP requests altogether, in all likelihood the responses of these second requests is ignored as well.

This image from the docs linked above should clarify

![image](https://github.com/pallets/flask/assets/153238260/fc0da526-2d31-4164-b2b3-f32b49306a28)

As you can see the traditional approach is diagrammed in 2. But the approach I'm referring to is diagrammed in 1. This allows multiple replies (Outgoing Request) per incoming request to the Flask server.
"
flask,5427,Issue,Comentario,"This may be out of scope for flask, I will take a look into using Werkzeug directly, which may have a more native approach towards this, that may not even need threading, in essence we just want to (send a response/do stuff) without closing the inbound-request-thread.

It's just that in Flask sending an HTTP response and closing the request-thread seem to be tightly coupled.  Perhaps there is a way and I'm just ignorant of it. I typically send an http response returning from a function marked as a route, maybe there's something like flask.respond(200,""Hello"")

If not, that would be the ideal API flask.respond(status_code,body), function may be called respondAndContinue if you want to avoid confusion."
flask,5427,Issue,Comentario,You're looking for a background task queue. https://flask.palletsprojects.com/en/3.0.x/patterns/celery/
flask,5427,Issue,Comentario,"I suppose one could import thousands of lines of code and add yet another layer of scheduling abstraction.

But I'd rather remove than add

"
flask,5427,Issue,Comentario,This is a good use case for Quart and the background tasks.
flask,5901,Issue,Titulo,Flask's blueprint's render templates rendering another blueprint's folder's html file !!!
flask,5901,Issue,Descripcion,"I was learning Flask & Web Application making.
I am getting the problem when i am return the render templates of a html file  in blueprint i am getting another blueprint's html file. 
I am sharing the screenshots here below and say what is the problem here.

<img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/1eeb056a-b53a-434b-ae46-e7e7712a448f"" />
See here in the render template at line 33, i wish it will render the `checking.html` file which is present in the `general_bp`'s folder.

<img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/f5e491bc-b5b0-43f5-aa9a-0517197f2e79"" />

<img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/1dd4ac18-26d5-4f9f-b587-a6f7256c60a1"" />

See here is the two `checking.html` file in different folder, but as i send the first image which should render the checking.html in the `general` folder it is rendering the `auth/checking.html` file.

<img width=""1366"" height=""768"" alt=""Image"" src=""https://github.com/user-attachments/assets/ad73f9b2-7e6e-4a9f-859d-6ead96b846eb"" />
As you see when i open the `/checking` route it is always giving the `auth>checking.html` file.

I am not understanding why this is happening. is this any problem or i make any mistake here which cause the problem. Or anything i am doing wrong when i am in the `routes.py` file

what the wrong, maybe in different blueprint's folder i have same file name so why it is taking another file üò¢

what you can see any problem here?

Please try to give a solution to this.


Environment:
Linux > Ubuntu(Xubuntu)

UV Python 3.14.0

<img width=""587"" height=""475"" alt=""Image"" src=""https://github.com/user-attachments/assets/17f49e54-707d-4c36-8616-b31e897a51ca"" />"
flask,5901,Issue,Comentario,"https://flask.palletsprojects.com/en/stable/blueprints/#templates

Duplicate of #3747 and others"
flask,5901,Issue,Comentario,"I am attaching the current source code of the my repo's which was i just learning here.

This is the commit when i am seeing this problem the exact repo at the moment is below:

Please try to solve this issue

https://github.com/RanaUniverse/wishlist_web_app/tree/96db2bdc2bba5daed23277095d9be21ce5272275"
flask,5817,Issue,Titulo,asyncio is not compatible with gevent
flask,5817,Issue,Descripcion,"See #5256

async-await: <https://flask.palletsprojects.com/en/stable/async-await/>

> Using async with greenlet
> When using gevent or eventlet to serve an application or patch the runtime, greenlet>=1.0 is required. When using PyPy, PyPy>=7.3.7 is required.

Flask uses asgiref, which is not compatible with gevent: <https://github.com/django/asgiref/issues/443>


BTW:
ASGI: <https://flask.palletsprojects.com/en/stable/deploying/asgi/>

> The asgiref [WsgiToAsgi](https://github.com/django/asgiref#wsgi-to-asgi-adapter) adapter is recommended as it integrates with the event loop used for Flask‚Äôs [Using async and await](https://flask.palletsprojects.com/en/stable/async-await/#async-await) support.

This makes it seem like the event loop integration means a single worker could process multiple requests concurently, which it can't, the worker will block on `await`.

---

I'm not the only one that found this the hard way: [Flask, Gunicorn, Gevent and Asyncio Don't Mix](https://github.com/moogah/flask-gunicorn-gevent-asyncio/blob/29be08051cd663fa68d982f27232d2a5215a399c/README.md)
"
flask,5817,Issue,Comentario,"~~Oh no, it actually works with uwsgi.~~
It doesn't work either with uwsgi
```
RuntimeError: You cannot use AsyncToSync in the same thread as an async event loop - just await the async function directly.
```"
flask,5817,Issue,Comentario,It would be helpful if you showed a minimal example of what you are using using that causes issues.
flask,5817,Issue,Comentario,"Look at the linked [flask-gunicorn-gevent-asyncio](https://github.com/moogah/flask-gunicorn-gevent-asyncio) repo.
Also check the attached reproducer in https://github.com/benoitc/gunicorn/issues/3070."
flask,5817,Issue,Comentario,"Please include the example and relevant details here. A whole Docker container is not a minimal example. I also can't tell if you're talking about gevent alone, or uwsgi, or gunicorn, or something else. Please be specific about the exact issue you are reporting."
flask,5817,Issue,Comentario,"> Please include the example [...] A whole Docker container is not a minimal example.

The dockerfile is completely optional, you just need python and pip to run the example in [flask-gunicorn-gevent-asyncio](https://github.com/moogah/flask-gunicorn-gevent-asyncio).

Here is the zip From the gunicorn issue: https://github.com/benoitc/gunicorn/files/12614245/reproduction.zip
It contains:
```
app.py
__init__.py
lots-of-curls.sh
requirements.txt
```

> I also can't tell if you're talking about gevent alone, or uwsgi, or gunicorn, or something else.

I'm talking about `gevent` + `asgiref` (`flask`'s async-await implementation).

`asgiref` does not support `gevent` ([ref](https://github.com/django/asgiref/issues/443)), so `flask[async]` cannot support `gevent`.
Which is fine, but then I have an issue with the docs having a ""Using async with greenlet"" section."
flask,5817,Issue,Comentario,@pgjones could you take a look at this if you have a chance?
flask,5817,Issue,Comentario,Continuing in #5881.
flask,5817,Issue,Comentario,https://flask.palletsprojects.com/en/stable/gevent/
flask,5881,Issue,Titulo,asgiref fails with gevent patching
flask,5881,Issue,Descripcion,"When `gevent.monkey.patch_all()` is used, `async def` functions fail when multiple concurrent requests are sent. asgiref gives the error `RuntimeError: You cannot use AsyncToSync in the same thread as an async event loop - just await the async function directly.`. This suggests that somehow, gevent is causing a running loop to be visible across threads.

`example.py`:

```python
# /// script
# requires-python = ""~=3.14.0""
# dependencies = [
#     ""flask[async]"",
#     ""gevent"",
# ]
#
# [tool.uv]
# exclude-newer = ""2026-01-05T00:00:00Z""
#
# [tool.uv.sources]
# flask = { path = ""."", editable = true }
# ///

import gevent.monkey
gevent.monkey.patch_all()

import asyncio

from flask import Flask

app = Flask(__name__)

@app.get(""/"")
async def hello_world():
    await asyncio.sleep(0.5)
    return f""Hello, World!""
```

```
uv run --with-requirements example.py flask -A example.py run
```

`load.py`:

```python
# /// script
# requires-python = ""~=3.14.0""
# dependencies = [
#     ""httpx"",
# ]
#
# [tool.uv]
# exclude-newer = ""2026-01-05""
# ///

import asyncio
import httpx

async def get(i, client: httpx.AsyncClient):
    r = await client.get(""http://127.0.0.1:5000"")
    print(i, await r.aread())

async def main():
    async with httpx.AsyncClient() as client, asyncio.TaskGroup() as group:
        for i in range(50):
            group.create_task(get(i, client))

asyncio.run(main())
```

```
uv run load.py
```

Continues #5817 with more details."
flask,5881,Issue,Comentario,asgiref uses `concurrent.futures.ThreadPoolExecutor` behind the scenes. Perhaps it's possible to override `Flask.async_to_sync` to spawn gevent threads or greenlets directly.
flask,5881,Issue,Comentario,"If you add an `after_request` callback, it doesn't cause issues, even though it's causing two threads to be spawned by `async_to_sync`. It only fails with concurrent requests, multiple threads for the same request isn't enough.

```python
@app.after_request
async def after(r):
    await asyncio.sleep(1)
    return r
```"
flask,5881,Issue,Comentario,"https://github.com/gfmio/asyncio-gevent/issues/12#issuecomment-3058277636 seems relevant:

> asyncio expects there to be a single loop (per OS thread!).
>
> Before patching, threading.Thread creates a new OS thread and all is fine.
> 
> After patching, threading.Thread will create a new green thread / greenlet running on the same OS thread. Since there is now only one OS thread, attempting to create a second loop will raise an exception."
flask,5881,Issue,Comentario,"Disclaimer, I do not have a solution to offer for this problem, but I wanted to share my understanding of the issue in case it helps.

The requirement for any gevent + asyncio solution to work well is that gevent runs in one thread, and asyncio runs in another thread. You can't have gevent and asyncio running on the same physical thread because then one loop would block the other.

What's happening when you run the example above is that the monkey patching prevents asgiref from launching a separate asyncio thread. It thinks it is launching a new thread, but due to the monkey patching it is launching a greenlet instead. So then the asyncio loop ends up running in the same physical thread as gevent, and this is bad even without the error messages.

I was actually able to get your example to run without errors only by commenting out the logic that raises the `RuntimeError` in asgiref. But this only masks the issue, it does not remove it. The correct solution would be for asgiref to somehow identify that it is running under a monkey patched gevent and figure out how to access the original unpatched threading module to launch a physical thread."
flask,5881,Issue,Comentario,"Yes that's what I was starting to figure out as well. I actually stripped asgiref out for a simple `threading.Thread` in `Flask.async_to_sync` to simplify things, and the problem still occurs. I was hoping to find some way to write `async_to_sync` using Gevent, but it doesn't seem possible with how asyncio and threads work. Tried asyncio-gevent `async_to_sync` as well, but it just freezes with concurrent requests. I also tried `gevent.monkey.patch_all(threading=False)`, but that fails as well."
flask,5881,Issue,Comentario,"The reason we ever documented that `async` views work with gevent is probably because all the tests pass, and we never tested multiple concurrent requests. Individual requests do work, but that defeats the whole purpose of both."
flask,5881,Issue,Comentario,"> Individual requests do work

In my opinion this needs to be investigated to be sure that it is true in all cases. A simple async view function that just sleeps works, but a view function that does real async work could have interference from monkey-patched stuff in the standard library. For example, will you be able to launch a subprocess or use the process executor from the async function? Probably not, because `subprocess` is monkey-patched by gevent. Same for anything dealing with sockets or anything else that gevent monkey-patches and asyncio expects to be unpatched.

As I said above, after I commented out the `RuntimeError` in asgiref, your example runs cleanly for me. Asgiref by default runs only one asyncio thread for all the calls to `async_to_sync`, so under monkey-patching I see it create a single async loop inside a single greenlet. So at a high-level, this is all good, if you ignore that you now have a gevent loop and an asyncio loop competing with each other inside the same thread."
flask,5881,Issue,Comentario,"After experimenting today, here's a working `Flask.async_to_sync` that uses gevent. The load script completes in a little over the 1 second sleep. It also seems to work fine making an httpx async request within the view.

```python
# /// script
# requires-python = "">=3.14""
# dependencies = [
#     ""flask"",
#     ""gevent"",
#     ""httpx"",
# ]
#
# [tool.uv]
# exclude-newer = ""2026-01-05T00:00:00Z""
#
# [tool.uv.sources]
# flask = { path = ""."", editable = true }
# ///
import asyncio

from flask import Flask, request
import gevent.monkey
import gevent.selectors

gevent.monkey.patch_all()
loop = asyncio.EventLoop(gevent.selectors.DefaultSelector())
gevent.spawn(loop.run_forever)

class MyFlask(Flask):
    def async_to_sync(self, func):
        def run(*args, **kwargs):
            coro = func(*args, **kwargs)
            future = asyncio.run_coroutine_threadsafe(coro, loop)
            return future.result()

        return run

app = MyFlask(__name__)

@app.get(""/"")
async def greet():
    await asyncio.sleep(1)
    return f""Hello, {request.args.get(""name"", ""World"")}!""
```"
flask,5881,Issue,Comentario,"And looking at `asyncio_gevent.EventLoop`, all it does is `asyncio.EventLoop(gevent.selectors.DefaultSelector())`, so that can be done directly, no need for the asyncio_gevent library for this. Updated the example above."
flask,5881,Issue,Comentario,"Okay, I thought it was going to be easy to change your example and make it break, but after trying a few things I could not.

I have an updated theory of why this appears to work well. Both loops are still running in the same physical thread, but the asyncio loop is using a monkey-patched selector in its scheduler, so that allows it to coexist with the gevent scheduler, with both working cooperatively, and both using greenlet-based non-blocking waits."
flask,5881,Issue,Comentario,"Correction. This does appear to work with standard asyncio, but it hangs with uvloop. Below is a short demo. If you comment out the monkey patching, then the coroutine runs fine and you can Ctrl-C it.

```python
import gevent.monkey
gevent.monkey.patch_all()

import asyncio
import threading
import uvloop

uvloop.install()
loop = uvloop.loop.Loop()

threading.Thread(target=loop.run_forever).start()

async def count():
    for i in range(5):
        await asyncio.sleep(1)
        print(i)

asyncio.run_coroutine_threadsafe(count(), loop)
```

I don't have a Windows machine at hand right now. You should test on that OS, which uses a loop that is not based on selectors."
flask,5881,Issue,Comentario,"Oh, and also, I think passing the default selector as an argument when creating the loop is only necessary when you are not monkey patching. If you are monkey patching, the default selector is already the gevent one."
flask,5881,Issue,Comentario,"I don't think I'm going to integrate this directly into Flask, as it requires setting up the event loop externally ahead of time. I'd also prefer to avoid gevent-specific code paths.

I was thinking a new documentation page about using gevent in general and explaining the method override pattern. This would also provide an example of why `Flask.async_to_sync` is intended to be overridden, for other cases such as trio as well. If we figure anything out with uvloop, that can be shown as well."
flask,5881,Issue,Comentario,"It looks like gevent can use a libuv event loop. Presumably, you'd enable libuv in gevent rather than asyncio, and use the same pattern above. https://www.gevent.org/loop_impls.html"
flask,5881,Issue,Comentario,"Yep, after testing, putting the following at the top works. I have no idea how to tell if it's actually more performant than the default though.

```python
import gevent
gevent.config.loop = ""libuv""
```"
flask,5881,Issue,Comentario,https://flask.palletsprojects.com/en/stable/gevent/
flask,5900,Pull Request,Titulo,document using gevent for async
flask,5900,Pull Request,Descripcion,"closes #5881 

Adds a separate page about gevent. Shows examples of using asyncio and libuv. Removes mentions of eventlet, since the maintainers have indicated it is no longer recommended."
flask,5896,Pull Request,Titulo,Cache compiled templates in render_template_string
flask,5896,Pull Request,Descripcion,"### Summary
`render_template_string` and `stream_template_string` now cache compiled templates, avoiding repeated compilation when the same source string is rendered multiple times.

The cache is stored per-app on the `Environment` instance with LRU eviction:
- `string_template_cache_size`: max 100 cached templates (configurable via class attribute)
- `string_template_cache_max_len`: templates longer than 100,000 characters are not cached

### Benchmark

The following script runs a server and computes how many requests can be received within 5 seconds.

```py
from threading import Thread
import requests, time, random
import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), ""src""))) # run this script within Flask's directory
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/template')
def t():
    return render_template_string('Hello, {{name}}',  name=request.args.get('q', ''))

def bench():
    time.sleep(1)  # wait for server
    n, end = 0, time.time() + 5
    s = requests.Session()
    while time.time() < end:
        s.get(f'http://127.0.0.1:6000/template?q={random.randint(0,10**6)}')
        n += 1
    print(f'\n{n} requests in 5s ({n/5:.0f} req/s)')
    import os; os._exit(0)

Thread(target=bench).start()
app.run(port=6000, threaded=True)
```

Without cache:
`5373 requests in 5s (1075 req/s)`

With cache:
`8603 requests in 5s (1721 req/s)`

8603/5373 = ~60% speed improvement

### Attribution
This optimization was initially generated using Optifiner AI, then cleaned up and validated manually by a human."
flask,5896,Pull Request,Comentario,"Hi @davidism!

Noticed you edited out the link, totally fair, the plug was probably too aggressive. Though I'm unsure of the reason this PR was closed. I believe the performance gain are quite significant and universal, but this is also my first Flask PR, could you lmk whether I missed something? Would be very grateful.

Thanks!"
flask,5896,Pull Request,Comentario,Stop using AI
flask,5804,Issue,Titulo,3.1.2 regression: `stream_with_context` triggers `teardown_request()` calls before response generation
flask,5804,Issue,Descripcion,"<!--
This issue tracker is a tool to address bugs in Flask itself. Please use
GitHub Discussions or the Pallets Discord for questions about your own code.

Replace this comment with a clear outline of what the bug is.
-->

<!--
Describe how to replicate the bug.

Include a minimal reproducible example that demonstrates the bug.
Include the full traceback if there was an exception.
-->

<!--
Describe the expected behavior that should have happened but didn't.
-->
Hello,

I believe the changes to `stream_with_context()` in https://github.com/pallets/flask/pull/5799/commits/9822a0351574790cb66c652fcc396ad7aa2b09d8 introduced a bug where the `teardown_request()` callables are invoked too early in the request/response lifecycle (and actually invoked twice, before generating the response and a second time after the end of the request). Take the following example:

```python
# flask_teardown_stream_with_context.py
from flask import Flask, g, stream_with_context


def _teardown_request(_):
    print(""do_teardown_request() called"")
    g.pop(""hello"")


app = Flask(__name__)

app.teardown_request(_teardown_request)


@app.get(""/stream"")
def streamed_response():
    g.hello = ""world""

    def generate():
        print(""Starting to generate response"")
        yield f""<p>Hello {g.hello} !</p>""

    return stream_with_context(generate())


app.run(debug=True)
```

In 3.1.1:

```
% /tmp/venv/bin/flask --version           
Python 3.13.7
Flask 3.1.1
Werkzeug 3.1.3
% /tmp/venv/bin/python flask_teardown_stream_with_context.py 
[‚Ä¶]
Starting to generate response
127.0.0.1 - - [01/Sep/2025 16:07:05] ""GET /stream HTTP/1.1"" 200 -
do_teardown_request() called
```

In 3.1.2:

```
% /tmp/venv/bin/flask --version                             
Python 3.13.7
Flask 3.1.2
Werkzeug 3.1.3
% /tmp/venv/bin/python flask_teardown_stream_with_context.py
do_teardown_request() called
Starting to generate response
do_teardown_request() called
Debugging middleware caught exception in streamed response at a point where response headers were already sent.
Traceback (most recent call last):
  File ""/tmp/venv/lib/python3.13/site-packages/flask/helpers.py"", line 132, in generator
    yield from gen
  File ""/tmp/flask_teardown_stream_with_context.py"", line 21, in generate
    yield f""<p>Hello {g.hello} !</p>""
                      ^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 56, in __getattr__
    raise AttributeError(name) from None
AttributeError: hello

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ""/tmp/venv/lib/python3.13/site-packages/werkzeug/wsgi.py"", line 256, in __next__
    return self._next()
           ~~~~~~~~~~^^
  File ""/tmp/venv/lib/python3.13/site-packages/werkzeug/wrappers/response.py"", line 32, in _iter_encoded
    for item in iterable:
                ^^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/helpers.py"", line 130, in generator
    with app_ctx, req_ctx:
                  ^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 443, in __exit__
    self.pop(exc_value)
    ~~~~~~~~^^^^^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 410, in pop
    self.app.do_teardown_request(exc)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/app.py"", line 1356, in do_teardown_request
    self.ensure_sync(func)(exc)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^
  File ""/tmp/flask_teardown_stream_with_context.py"", line 7, in _teardown_request
    g.pop(""hello"")
    ~~~~~^^^^^^^^^
  File ""/tmp/venv/lib/python3.13/site-packages/flask/ctx.py"", line 88, in pop
    return self.__dict__.pop(name)
           ~~~~~~~~~~~~~~~~~^^^^^^
KeyError: 'hello'
127.0.0.1 - - [01/Sep/2025 16:09:35] ""GET /stream HTTP/1.1"" 200 -
```

Specifically,

```
do_teardown_request() called
Starting to generate response
do_teardown_request() called
```

So `_teardown_request()` is called before flask start to iterate on the response generator.

This is a simplified version of our own code; I'm not sure we can actually expect `g` to still be available during response generators, but given it worked in 3.1.1 and the phrasing / intent of `teardown_request()`, I'd expect it not to be called before the response is actually generated. Note also that removing the code which causes the error, i.e. the `g` access, and keeping just the `print()` for debugging, will still show `_teardown_request()` being called twice.

It's not obvious to me where exactly the bug is triggered. Adding a `traceback.print_stack()` call to `_teardown_request()`:
* in 3.1.1, the only call, once the request is done, is triggered by https://github.com/pallets/flask/blob/7fff56f5172c48b6f3aedf17ee14ef5c2533dfd1/src/flask/helpers.py#L115 ‚áí https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/ctx.py#L443 
* in 3.1.2, the (new) first call before entering the response generator is triggered by https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/app.py#L1527 ; the second is similar to 3.1.1, i.e. https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/helpers.py#L130 ‚áí https://github.com/pallets/flask/blob/330123258e8c3dc391cbe55ab1ed94891ca83af3/src/flask/ctx.py#L443

Environment:

- Python version: 3.13
- Flask version: 3.1.2
"
flask,5804,Issue,Comentario,"This will be fixed as a side effect of #5812 in 3.2. I'm not sure how to fix it in the mean time, without reintroducing the other issue, but I'm open to reviewing a PR if you can figure it out sooner.

I do understand how this is an issue, but note that the docs already call out that you can't make assumptions about how many times teardown functions will run or what will have or have not run before them. That's something you should address regardless of this being fixed."
flask,5804,Issue,Comentario,"> This will be fixed as a side effect of https://github.com/pallets/flask/pull/5812 in 3.2. I'm not sure how to fix it in the mean time

Seems like it does the trick indeed, thanks. The fact that it won't be fixed until then is not really an issue for us, I've just pinned flask to <3.1.2 until we can upgrade.

> the docs already call out that you can't make assumptions about how many times teardown functions will run or what will have or have not run before them

https://flask.palletsprojects.com/en/stable/reqcontext/#teardown-callbacks here ? It's not immediately obvious to me that they could run more than once, but even then this isn't the original issue we encountered, because our teardown callbacks are indeed idempotent ‚Äî the `g.pop()` was used here to exhibit the issue.

My issue was more around *when* it can be called: in this specific case, even before entering the generator passed to `stream_with_context()`. I wouldn't expect a teardown callback to be called at this point, considering `do_teardown_request()` is ¬´ Called after the request is dispatched and the response is returned ¬ª."
flask,5804,Issue,Comentario,Is there an expected release date for 3.2.0? We also encountered this problem in OTEL.
flask,5804,Issue,Comentario,"Hi I tested the code of @noirbee and indeed it does give the same error
(venv-flask) ‚ûú  flask git:(fix-streaming-teardown) ‚úó flask --version
Python 3.13.5
Flask 3.2.0.dev0
Werkzeug 3.1.3
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 140-638-840
Starting to generate response
127.0.0.1 - - [29/Sep/2025 23:09:47] ""GET /stream HTTP/1.1"" 200 -
do_teardown_request() called
do_teardown_request() called
Debugging middleware caught exception in streamed response at a point where response headers were already sent.
Traceback (most recent call last):
  File ""/Users/anand/Desktop/oss/flask/src/flask/app.py"", line 1500, in __call__
    return self.wsgi_app(environ, start_response)
           ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/Users/anand/Desktop/oss/flask/src/flask/app.py"", line 1491, in wsgi_app
    ctx.pop(error)
    ~~~~~~~^^^^^^^
  File ""/Users/anand/Desktop/oss/flask/src/flask/ctx.py"", line 474, in pop
    self.app.do_teardown_request(exc)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^
  File ""/Users/anand/Desktop/oss/flask/src/flask/app.py"", line 1339, in do_teardown_request
    self.ensure_sync(func)(exc)
    ~~~~~~~~~~~~~~~~~~~~~~^^^^^
  File ""/Users/anand/Desktop/oss/flask/1.py"", line 7, in _teardown_request
    g.pop(""hello"")
    ~~~~~^^^^^^^^^
  File ""/Users/anand/Desktop/oss/flask/src/flask/ctx.py"", line 88, in pop
    return self.__dict__.pop(name)
           ~~~~~~~~~~~~~~~~~^^^^^^
KeyError: 'hello'


**But:** when I add decorator for streaming with context it works correctly

from flask import Flask, g, stream_with_context


def _teardown_request(_):
    print(""do_teardown_request() called"")
    g.pop(""hello"")

app = Flask(__name__)

app.teardown_request(_teardown_request)

@app.get(""/stream"")
def streamed_response():
    g.hello = ""world""

    @stream_with_context # change here
    def generate():
        print(""Starting to generate response"")
        yield f""<p>Hello {g.hello} !</p>""

    return stream_with_context(generate())

app.run(debug=True)

**Even** Replacing g.pop(""hello"") with g.pop(""hello"", None) works suggesting its being trying to popped multiple times and cant find hence error"
flask,5804,Issue,Comentario,"I think we should supress the error as a warning till the issue gets resolves as a side effect by wrapping the 
teardown call on the lines of:

from contextlib import suppress

def do_teardown_request(self, exc: BaseException | None = None) -> None:
    """"""Called after the request is dispatched and the response is finalized.""""""
    req = _cv_app.get().request

    for name in chain(req.blueprints, (None,)):
        if name in self.teardown_request_funcs:
            for func in reversed(self.teardown_request_funcs[name]):
                with suppress(KeyError):
                    self.ensure_sync(func)(exc)

    request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)
"
flask,5804,Issue,Comentario,"sorry I am new to open source contribution so please forgive if formatting issues,"
flask,5804,Issue,Comentario,"We are suffering the same issue with 3.1.2, and had to pin Flask to version < 3.1.2.
Did not quite get it: is this expected to be resolved in Flask 3.2.0? 
Thanks"
flask,5804,Issue,Comentario,"> is this expected to be resolved in Flask 3.2.0?

yes"
flask,5899,Pull Request,Titulo,deprecate `should_ignore_error`
flask,5899,Pull Request,Descripcion,closes #5816 
flask,5816,Issue,Titulo,deprecate `should_ignore_error`
flask,5816,Issue,Descripcion,"This was added in f1918093ac70d589a4d67af0d77140734c06c13d as part of the original code to keep the context around for use in the debugger, tests, etc. It was not part of a PR, and there's no linked issue or explanation on why it was added.

The intention seems to be to allow ignoring certain errors during debugging, so that cleanup is still run immediately. That's not how context preservation works anymore.  It also causes the exception to not be passed to teardown handlers, but there doesn't seem to be any reason to hide that, and handlers can already choose what to do if they're passed an error.

The method is only documented in the API, not in any other pages. There's no test for it. I have a feeling this isn't used. It results in an extra function call every single request, only to always return false. This can be deprecated then removed."
flask,5816,Issue,Comentario,"@davidism Would you assign this to me?
I am interested in contributing to this.
"
flask,5816,Issue,Comentario,"Thanks, however this type of task is not something for new contributors."
flask,5816,Issue,Comentario,"Hi @davidism,
I‚Äôve been going through the context preservation and teardown logic in Flask and would love to contribute to this issue.
I understand this task was marked as not suitable for new contributors, but I have experience with Python internals and would like to work carefully under your guidance.

I‚Äôve already explored how should_ignore_error interacts with teardown handlers and can open a draft PR showing a safe deprecation path (with tests).

Would you be open to me working on this?"
flask,5816,Issue,Comentario,"Hey, I can try and handle this issue. New to contribution, not software development lol. This issue has been open for over a month, I can definitely try and figure this one out. Currently unemployed with nothing better to do, and this one seems like it'll be a doozy and extremely fun for my brain to figure out."
flask,5844,Pull Request,Titulo,pre-commit: Add codespell
flask,5844,Pull Request,Descripcion,"* #5833 on the `stable` branch.

The `stable` branch contains no codespell discoverable typos, but the default branch contains:
```
./docs/appcontext.rst:122: requet ==> request
./docs/quickstart.rst:465: interanlly ==> internally
./docs/templating.rst:186: avaialble ==> available
```

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5825,Issue,Titulo,Document 415 on the receiving json section
flask,5825,Issue,Descripcion,"Documentation on ""json"" request throwing a 415 as well as 400.  

The problem text is on https://flask.palletsprojects.com/en/stable/patterns/javascript/#receiving-json-in-views

> Receiving JSON in Views
> 
> Use the [json](https://flask.palletsprojects.com/en/stable/api/#flask.Request.json) property of the [request](https://flask.palletsprojects.com/en/stable/api/#flask.request) object to decode the request‚Äôs body as JSON. If the body is not valid JSON, or the Content-Type header is not set to application/json, a 400 Bad Request error will be raised

I believe you want to indicate that it's a 415 instead of 400 when the Content-Type header doesn't match as it's done on https://flask.palletsprojects.com/en/stable/api/#flask.Request.json

400 is still valid for when the body isn't json (even though the content-type is json).

So maybe something like this ? 

> Receiving JSON in Views
>
> Use the [json](https://flask.palletsprojects.com/en/stable/api/#flask.Request.json) property of the [request](https://flask.palletsprojects.com/en/stable/api/#flask.request) object to decode the request‚Äôs body as JSON. If the body is not valid JSON, a 400 Bad Request error will be raised.  If the Content-Type header is not set to application/json, a 415 Unsupported Media Type error will be raised

Environment:

- Python version: N/A
- Flask version: latest doc



This is in no way a bug, but it's for being aligned everywhere in your doc :).  I'm just trying to make things better, I love the product ! thanks for the great work you've done ! "
flask,5825,Issue,Comentario,"Hi, I‚Äôd like to work on this documentation issue.I‚Äôll review the ‚Äúreceiving JSON‚Äù section and add clarification about when and why
a 415 (Unsupported Media Type) error occurs, along with an example if appropriate.

"
flask,5825,Issue,Comentario,"Hi üëã,
I'd like to work on improving this documentation section and submit a PR.
Please let me know if this issue is available or needs clarification.
"
flask,5825,Issue,Comentario,"Hii ! I'd like to work on this issue by updating the documentation to clarify the 415 Unsupported Media Type behaviour when the Content-Type is not application/json.
Please let me know if that sounds good. "
flask,5825,Issue,Comentario,"Hi, I looked into this issue and it appears to be related to how Flask handles
request.get_json() when the Content-Type header is missing or incorrect.

From reading the documentation, the 415 error can occur when a request does
not specify 'application/json' or sends invalid JSON, but this behavior is
not clearly explained for users.

Adding a short explanation and a simple example to the
request.get_json() documentation (in docs/reqcontext.rst) should help
users understand why this error occurs and how to resolve it.

Please let me know if this approach makes sense before I proceed.
"
flask,5827,Pull Request,Titulo,clarify 415 vs 400 errors for request.json
flask,5827,Pull Request,Descripcion,"## Description
Clarifies the distinction between 415 and 400 error codes when using `request.json`, aligning the JavaScript patterns documentation with the API reference.

## Changes
- Updated ""Receiving JSON in Views"" section to specify:
  - 400 Bad Request: for invalid JSON body
  - 415 Unsupported Media Type: for missing/incorrect Content-Type header
- Updated ""Making a Request with fetch"" section for consistency

## Fixes
Fixes #5825

## Checklist
- [x] Documentation updated
- [x] Changes align with existing API documentation"
flask,5827,Pull Request,Comentario,"Hey @adityasah104, I see you have edited the line quite a bit. Why not to keep it as it is and just edit the error message?

As example:
Use the [json](https://flask.palletsprojects.com/en/stable/api/#flask.Request.json) property of the [request](https://flask.palletsprojects.com/en/stable/api/#flask.request) object to decode the request‚Äôs body as JSON. If the body is not valid JSON, or the Content-Type header is not set to application/json, a ~400 Bad Request~ 415 Unsupported Media Type error will be raised.


How about changing it this way? üôÇ"
flask,5827,Pull Request,Comentario,"@lonelyH3b because that's not accurate, as described in the issue, in the PR description, and in the code."
flask,5827,Pull Request,Comentario,"Yes, got it ‚ù§Ô∏è"
flask,5827,Pull Request,Comentario,Thanks @davidism for clarifying! The PR is ready for review whenever you have time.
flask,5827,Pull Request,Comentario,@davidism Just wanted to gently follow up on this when you have a chance. Happy to make any additional changes if needed!
flask,5808,Pull Request,Titulo,fix annotation for select_jinja_autoescape
flask,5808,Pull Request,Descripcion,"Inside the code of the method the filename is checked against a None value and returns True, but the static annotated type is a str. I have changed the static annotation type to `str` to `str | None`."
flask,5808,Pull Request,Comentario,Is there anything required from my end to close this particular pull request
flask,5808,Pull Request,Comentario,"Hi Maintainers, is there anything I could do to get this PR resolved"
flask,5835,Pull Request,Titulo,Add Seenode deployment instructions to documentation
flask,5835,Pull Request,Descripcion,"Hey. Just wanted to add seenode to the listed providers, as we have [first class support for flask](https://seenode.com/docs/frameworks/python/flask/). Thanks!
<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5835,Pull Request,Comentario,"Thanks, it's always great to see services supporting Flask.

However, at this time we don't plan on adding more services to this list, as it is difficult to keep updated and fair. You'll notice that around that list, the docs say:

> The links below are for some of the most common platforms

> This list is not exhaustive, and you should evaluate these and other services based on your application‚Äôs needs.

I'll keep this in mind if I do change my mind."
flask,5845,Pull Request,Titulo,docs: Add explanation of reloader types and terminal output
flask,5845,Pull Request,Descripcion,"## Summary

This PR adds documentation explaining the different reloader types that Flask uses and the terminal output users see when running in debug mode.

## Problem

When running Flask with debug mode enabled, users see messages like:
- `* Restarting with stat`
- `* Restarting with watchdog (windowsapi)`
- `* Restarting with inotify`

These messages are never explained in the documentation, which can confuse users (especially beginners) who don't understand what they mean or why they appear.

## Changes

### `docs/server.rst`
- Added new ""Understanding the Reloader"" section explaining:
  - The two reloader backends (watchdog vs stat)
  - Why Flask chooses different backends automatically
  - What the platform-specific names mean (windowsapi, inotify, kqueue)
  - How to install watchdog for better performance
  - How to manually specify a reloader type if needed

### `docs/quickstart.rst`
- Added a note in the Debug Mode section that references the new server.rst section
- Helps users immediately understand the reloader output they see in the quickstart example

## Testing

- Verified reStructuredText syntax is correct
- Checked that internal documentation links work properly
- Confirmed the new content fits naturally with existing documentation structure

## Related

The installation docs already mention watchdog as an optional dependency, but don't explain what it does or when it's used. This PR bridges that gap.
"
flask,5898,Pull Request,Titulo,redirect defaults to 303
flask,5898,Pull Request,Descripcion,closes #5895 
flask,5895,Issue,Titulo,change default redirect code to 303
flask,5895,Issue,Descripcion,"Flask and Werkzeug `redirect` currently defaults to a [302](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/302). Routing uses [307](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/307) since that preserves method consistently. We didn't change the `redirect` default to 307, since that would break the common pattern of ""GET form, POST form, redirect to GET result"", ending up doing ""POST result"" instead. [303](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/303) seems designed exactly for this pattern, so that a redirect always results in a GET, instead of preserving the method or only rewriting it sometimes. [HTMX actually calls this out about Flask.](https://hypermedia.systems/htmx-patterns/#:~:text=cleaner%2E-,A,resource)

I don't _think_ there would actually be a problem switching to 303 as the default. It would still do the expected thing for basic page redirects and form submission redirects. I would be really surprised if anyone was relying on the 302 behavior of only converting POST and nothing else. I don't even remember that being the behavior when we were switching to 307, and I would have switched to 303 instead of leaving 302 then if I had known about it."
flask,5885,Pull Request,Titulo,clarify async view incompatibility with gevent monkey patching
flask,5885,Pull Request,Descripcion,"@davidism Please Check 

 Closes #5881 


This PR adds documentation clarifying the limitations and unsupported nature of using Flask async views together with gevent monkey patching.

While simple async views may appear to work for individual requests, concurrent requests can fail due to conflicts between asyncio‚Äôs event loop assumptions and gevent‚Äôs greenlet-based threading model. The documentation explains why this behavior occurs, highlights failure modes that typically only appear under concurrency, and outlines recommended alternatives and advanced override considerations.

This change is documentation-only and is based on the investigation and conclusions discussed in the linked issue.
"
flask,5878,Pull Request,Titulo,Add hello.py for testing
flask,5878,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5878,Pull Request,Comentario,Please stop abusing big public repos for random tests 
flask,5879,Pull Request,Titulo,Add GitHub Actions CI workflow
flask,5879,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5879,Pull Request,Comentario,"Please stop abusing other people's repos for random tests or learning how to use GitHub, this is not a playground."
flask,5824,Pull Request,Titulo,Clarify asyncio and gevent incompatibility in docs (#5817)
flask,5824,Pull Request,Descripcion,"Updated the _async_await.rst documentation to clarify that Flask's asynchronous support
(using asgiref) is **not compatible with gevent or eventlet**. 

Added a recommendation to use ASGI servers like `uvicorn` or `hypercorn` 
for proper async support, giving users a clear alternative until issue #5817 
is addressed.
"
flask,5877,Pull Request,Titulo,Minor documentation
flask,5877,Pull Request,Descripcion,"This PR  practicing open source contribution workflow.
"
flask,5877,Pull Request,Comentario,Do not use other's public repositories for practice. Also this change is in no way an improvement. 
flask,5876,Pull Request,Titulo,docs: Upgrade HTTP links to HTTPS
flask,5876,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.
Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->
This PR upgrades several HTTP links to HTTPS in the documentation to ensure best security practices and avoid redirection.
- `docs/patterns/mongoengine.rst`: Upgraded `mongoengine.org` link.
- `docs/web-security.rst`: Upgraded example URL in security context.
<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.
fixes #<issue number>
-->
N/A (Documentation fix)
<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:
- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->"
flask,5875,Pull Request,Titulo,docs: clarify 415 error when receiving JSON requests
flask,5875,Pull Request,Descripcion,"This PR adds a short clarification to the ""APIs with JSON"" section in the
Flask quickstart documentation explaining when a 415 Unsupported Media Type
error can occur while receiving JSON requests.

The change explains that the error may be raised when the Content-Type
header is missing or incorrect, or when invalid JSON is sent, and provides
guidance on how to avoid it.
"
flask,5873,Pull Request,Titulo,Clarify 415 Unsupported Media Type in JSON docs
flask,5873,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5874,Pull Request,Titulo,Clarify 415 Unsupported Media in JSON docs
flask,5874,Pull Request,Descripcion,"Update the ‚ÄúReceiving JSON in Views‚Äù documentation to clarify that Flask returns
a 415 Unsupported Media Type error when the Content-Type is not application/json,
and a 400 Bad Request error for invalid JSON, as discussed in #5825.
"
flask,5871,Pull Request,Titulo,init
flask,5871,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5870,Issue,Titulo,Teardown handler chain exception handling
flask,5870,Issue,Descripcion,"Flask executes registered teardown handlers (used for closing DB connections, releasing locks, etc.) in a chain. The do_teardown_request method which is supposed to make these teardown requests does not wrap individual handlers in a try/except block. If one handler raises an exception, the loop terminates immediately, and all subsequent handlers are skipped, this can lead to the application to skip critical cleanup routines if a non critical one fails.

Sample reproduction code
```python
import threading
import time
import requests
from flask import Flask

app = Flask(__name__)

#a simulation of a limited resource pool
mock_db_connections = 0

@app.route('/')
def index():
    global mock_db_connections
    mock_db_connections = mock_db_connections + 1
    return ""Request Processed""

#simulating a critical teardown handler which is supposed to free resources from the db
@app.teardown_request
def critical_db_close(exc):
    global mock_db_connections
    mock_db_connections = mock_db_connections - 1

#teardown handler which can crash
@app.teardown_request
def buggy_extension(exc):
    raise Exception(""Crash in buggy extension!"")

def run_server():
    #just for clearner output
    import logging
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.ERROR)
    app.logger.disabled = True
    
    app.run(port=5000, threaded=True)

def verify_bug():
    
    print(f""Initial DB Connections: {mock_db_connections}"")
    
    try:
        requests.get('http://127.0.0.1:5000/')
    except Exception:
        pass

    #wait time to ensure teardown has happened in the other thread
    time.sleep(1)
    
    print(f""Final DB Connections: {mock_db_connections}"")
    
    if mock_db_connections > 0:
        print(""Teardown Chain Broken"")
    else:
        print(""Failed to reproduce"")

server_thread = threading.Thread(target=run_server, daemon=True)
server_thread.start()
verify_bug()
```"
flask,5870,Issue,Comentario,"From the [docs](https://flask.palletsprojects.com/en/stable/reqcontext/#teardown-callbacks) about teardown callbacks:

> Be sure to write these functions in a way that does not depend on other callbacks and will not fail.

Teardown happens after the response has already started, so there's no way to indicate that there was a server error at that point except by crashing. If we silently ignored exceptions in these handlers, the app could end up in an unexpected state."
flask,5869,Pull Request,Titulo,Document 415 Unsupported Media Type for JSON requests
flask,5869,Pull Request,Descripcion,"This adds a short note to the Incoming Request Data documentation explaining
when Flask may return a 415 Unsupported Media Type error if JSON requests are
missing or have an incorrect Content-Type header.
"
flask,5868,Pull Request,Titulo,Improve exception handler in wsgi_app method
flask,5868,Pull Request,Descripcion,"This change replaces the bare except clause with an explicit BaseException 
handler for better code clarity and to avoid potential issues with 
sys.exc_info().

The previous code used a bare except: clause with sys.exc_info()[1] which 
is discouraged in Python. This change makes the exception handling more 
explicit by catching BaseException directly, which includes KeyboardInterrupt 
and SystemExit that should not be handled by the normal exception handler.

All existing tests pass successfully."
flask,5867,Pull Request,Titulo,Deprecate should_ignore_error method
flask,5867,Pull Request,Descripcion,"The `should_ignore_error()` method was added in f191809 to support context preservation for debugging, but it no longer serves its original purpose and adds unnecessary overhead.

Issues with the current implementation:
- Always returns False by default
- Called on every single request with no benefit
- The original intention for error ignoring during debugging is not how context preservation works anymore
- No documentation beyond API reference
- No tests for the functionality
- No evidence of real-world usage

Changes:
- Add deprecation warning to App.should_ignore_error() that will be removed in Flask 4.0
- Optimize call site to only invoke the method if it's been overridden by a subclass, eliminating the function call overhead for 99.9% of requests
- Add comprehensive tests for the deprecation behavior
- Update CHANGES.rst with deprecation notice

Teardown handlers should manage their own error handling instead of relying on this method.

Fixes #5816

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5867,Pull Request,Comentario,why do I have the feeling that you used an LLM to create this PR?
flask,5866,Pull Request,Titulo,Clarify JSON request errors: 400 vs 415
flask,5866,Pull Request,Descripcion,"This updates the ""Receiving JSON in Views"" section to correctly distinguish between:
- 400 Bad Request: raised when the body is not valid JSON
- 415 Unsupported Media Type: raised when the Content-Type header is not application/json

This aligns the documentation with Flask's actual behavior and makes it clearer for users."
flask,5872,Pull Request,Titulo,Fixed error code documentation for request.json
flask,5872,Pull Request,Descripcion,"Fix error code documentation for request.json

Clarify that a 415 error is raised when Content-Type is incorrect,
while a 400 error is raised when the body is not valid JSON.

This aligns the patterns documentation with the API reference at
https://flask.palletsprojects.com/en/stable/api/#flask.Request.json

Changes Made
Updated `docs/patterns/javascript.rst` in the ""Receiving JSON in Views""
section to correctly distinguish between:

400 Bad Request: Raised when the request body is not valid JSON
415 Unsupported Media Type: Raised when Content-Type header is not
set to application/json

Previously, the documentation incorrectly stated that both scenarios
would raise a 400 error.

fixes #5825"
flask,5872,Pull Request,Comentario,"Hi David, 

I wanted to verify whether the issue addressed in my PR has already been resolved somewhere else? I noticed the PR was closed and would appreciate any context or guidance on the reason."
flask,5872,Pull Request,Comentario,"There's already an open PR. You're approximately the 10th person not to notice that. You also asked an AI to do it for you, and it slopped out a huge unnecessary description. "
flask,5872,Pull Request,Comentario,"I just wanted to point that this is my first attempt to a contribution as an aspiring open source developer. My description was for the sole purpose of indicating the changes following the template that was given when creating the PR. I thoroughly reviewed the updated Flask API documentation before submitting my solution with the use of AI. 

Additionally, It seems like the issue was already resolved in an open PR (#5827). Closing it would help prevent others like ```myself``` from continuing to work on it unintentionally. "
flask,5872,Pull Request,Comentario,"From our [contributing guide](https://palletsprojects.com/contributing/#what-to-work-on):

> Before starting, check if anyone else is assigned to the issue, or if there are any linked open pull requests. Look through the issue for that information as well as discussion and other linked issues for context.

Also, this was a one sentence change, and _that sentence was already written_ in the issue. There was absolutely no reason to waste resources using an LLM to do a copy paste."
flask,5859,Pull Request,Titulo,Create test
flask,5859,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5859,Pull Request,Comentario,do not use other people's repos for testing.
flask,5860,Pull Request,Titulo,Fix documentation for JSON error codes
flask,5860,Pull Request,Descripcion,"## Description

This PR fixes the documentation for JSON error handling in the ""Receiving JSON in Views"" section to correctly distinguish between different HTTP error codes.

## Changes

- Updated `docs/patterns/javascript.rst`
- Changed documentation to show:
  - `400 Bad Request` for invalid JSON content
  - `415 Unsupported Media Type` for wrong Content-Type header

## Before
`If the body is not valid JSON, or the Content-Type header is not set to application/json, a 400 Bad Request error will be raised.`

## After
`If the body is not valid JSON, a 400 Bad Request error will be raised. If the Content-Type header is not set to application/json, a 415 Unsupported Media Type error will be raised.`

## Fixes 
#5825

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5858,Pull Request,Titulo,"Refactor __init__.py module to improve organization, readability and public API structure"
flask,5858,Pull Request,Descripcion,"### Description:

This Pull Request introduces a structured refactoring of the src/flask/__init__.py file, aiming to improve internal organization and clarify the definition of the framework‚Äôs public API.
The modifications do not change runtime behavior but make the module more consistent, cleaner and aligned with architecture and style best practices.

### Changes implemented:

- Fully reorganized imports, grouping them by source (standard library, third-party, internal modules).
- Removed redundant or unused imports.
- Improved __all__ export structure to clearly define the public API.
- Added comments explaining the module‚Äôs responsibility as a high-level interface aggregator.
- Reduced visual noise and increased cohesion.
- Formatting and style adjustments aligned with tools like Flake8 and Pylint.

### Motivation:

The __init__.py file acts as the main entry point for the Flask package, exposing the symbols developers interact with.
Before refactoring, the file contained inconsistencies in import ordering, export grouping and general structure.

### These improvements:

- increase the clarity of the public API;
- make the codebase easier to navigate and maintain;
- reduce style violations (E401, F401, E302, etc.);
- decrease cognitive coupling and prepare the ground for deeper refactoring in critical modules such as app.py.
- Expected impact on metrics:
- Readability: improved through organized imports and structural cleanup.
- Cohesion: increased by keeping the module focused on API aggregation.
- Cognitive coupling: reduced due to clearer responsibilities.
- Flake8 violations: expected reduction in F401 (unused imports) and E501 (line length issues).

"
flask,5858,Pull Request,Comentario,This is useless LLM junk. Do not waste maintainer time. 
flask,5858,Pull Request,Comentario,"Hey! Sorry for the inconvenience. I was studying ways to improve Flask for a university assignment. I apologize again ‚Äî it wasn‚Äôt my intention to disrupt your progress. Best regards, and once again, sorry¬†about¬†that."
flask,5858,Pull Request,Comentario,Then your professor failed you in not teaching you how to contribute. Please tell your professor that maintainers want them to stop assigning this.
flask,5863,Issue,Titulo,Modern CSRF Protection Using `Sec-Fetch-Site` Header
flask,5863,Issue,Descripcion,"Flask's documentation states that CSRF protection requires a form validation framework (which Flask doesn't provide), necessitating one-time tokens stored in cookies and transmitted with form data. However, modern browsers now support `Sec-Fetch-Site` headers, making token-based CSRF protection unnecessary. Rails just merged this approach in [rails/rails#56350](https://github.com/rails/rails/pull/56350). Flask should offer a similar modern solution‚Äîbut in a more Flask-like way: as a simple argument to `@app.route()`.

## Current State

From Flask's security documentation:

> ""Why does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask.""

This was written when CSRF tokens were the only viable protection mechanism. That's no longer true. And with header-based protection, no form validation framework is needed‚Äîjust a simple check before dispatching to the view.

## The Modern Approach

The `Sec-Fetch-Site` header is a [Fetch Metadata Request Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site) that modern browsers send automatically. It indicates the relationship between the request origin and the target origin:

- `same-origin`: Request from the same origin (same scheme, host, and port)
- `same-site`: Request from the same site but different origin
- `cross-site`: Request from a completely different site
- `none`: User-initiated navigation (typing URL, bookmark, etc.)

For state-changing requests (POST, PUT, DELETE, PATCH), we can simply reject requests where `Sec-Fetch-Site` is `cross-site`. No tokens needed.

**Browser Support:** All modern browsers (Chrome 76+, Firefox 90+, Safari 16.4+, Edge 79+) - [caniuse.com/mdn-http_headers_sec-fetch-site](https://caniuse.com/mdn-http_headers_sec-fetch-site)

## Why This Matters

Token-based CSRF has significant operational pain:

1. **Caching conflicts**: Cached pages contain stale tokens ‚Üí false positives
2. **Session expiry edge cases**: Token/session mismatch after timeout
3. **SPA complexity**: Managing token refresh in JavaScript applications
4. **Multi-tab issues**: Tokens invalidated when user opens multiple tabs

Header-based protection eliminates all of these.

## Proposed Flask Implementation

Rather than adding another extension, this should be a first-class citizen in Flask's routing. The implementation is simple enough that it belongs in core‚Äîjust an argument to `@app.route()`:

```python
from flask import Flask

app = Flask(__name__)
app.config['CSRF_TRUSTED_ORIGINS'] = ['https://accounts.google.com']

# Protected by default for state-changing methods
@app.route('/api/data', methods=['POST'])
def create_data():
    return {'status': 'ok'}

# Explicitly disable for webhooks that use signature verification
@app.route('/webhooks/stripe', methods=['POST'], csrf=False)
def stripe_webhook():
    return {'received': True}

# GET requests are never protected (no state change)
@app.route('/api/data', methods=['GET'])
def get_data():
    return {'data': []}
```

## Configuration

```python
# Default configuration in Flask
CSRF_ENABLED = True                    # Global kill switch
CSRF_TRUSTED_ORIGINS = []              # Allow cross-origin from these origins
CSRF_PROTECTED_METHODS = {'POST', 'PUT', 'PATCH', 'DELETE'}
```

Note: Unlike my earlier draft, `same-site` requests are **rejected by default**. This is intentional‚Äîdifferent subdomains often have different trust levels (e.g., `marketing.example.com` vs `admin.example.com`). If you need same-site requests, add the specific origin to `CSRF_TRUSTED_ORIGINS`.


## Questions for Maintainers

1. **Default On vs Off**: Should CSRF protection be on by default for state-changing methods (proposed), or require explicit `csrf=True`?

2. **Same-site Policy**: The algorithm rejects `same-site` requests by default (per Filippo Valsorda's guidance). Should there be a config option to relax this, or is explicit `CSRF_TRUSTED_ORIGINS` sufficient?

3. **Werkzeug Level**: Should the core check logic live in Werkzeug so other frameworks (Bottle, etc.) can use it?

## References

- [MDN: Sec-Fetch-Site](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site)
- [web.dev: Fetch Metadata](https://web.dev/articles/fetch-metadata)
- [Rails PR #56350](https://github.com/rails/rails/pull/56350) - Rails implementation (merged Dec 2025)
- [Rack Issue #2367](https://github.com/rack/rack/issues/2367) - Rack-level discussion
- [Go proposal: CrossOriginForgeryHandler](https://github.com/golang/go/issues/73626)
- [Blog from go author](https://words.filippo.io/csrf/)
- [OWASP Fetch Metadata positioning](https://github.com/OWASP/CheatSheetSeries/pull/1875)

## Willingness to Implement

I'm prepared to submit a PR implementing this. The change is small and self-contained.
"
flask,5863,Issue,Comentario,"> Handling Missing Headers: Current proposal allows requests with valid Origin header when Sec-Fetch-Site is missing. Should this be configurable or should we reject outright?

Requiring `Origin` seems like a massive breaking change for APIs (where CSRF is generally not an issue anyway since you need to provide a Bearer token for authentication, or for unauthenticated APIs that do not require CSRF protections).

So default-on would likely be a breaking change."
flask,5863,Issue,Comentario,"> > Handling Missing Headers: Current proposal allows requests with valid Origin header when Sec-Fetch-Site is missing. Should this be configurable or should we reject outright?
> 
> Requiring `Origin` seems like a massive breaking change for APIs (where CSRF is generally not an issue anyway since you need to provide a Bearer token for authentication, or for unauthenticated APIs that do not require CSRF protections).
> 
> So default-on would likely be a breaking change.

The algorithm I was hoping to implement was Filippo's recommended appraoch:

1. Allow safe methods (GET, HEAD, OPTIONS)
2. If Origin in trusted list ‚Üí allow
3. If Sec-Fetch-Site present:
   - same-origin or none ‚Üí allow
   - same-site or cross-site ‚Üí REJECT
4. If neither header present ‚Üí allow (not a browser)
5. If Origin host == Host ‚Üí allow, else reject

Based on this.

**What gets rejected:**

- Browser requests where Sec-Fetch-Site is cross-site or same-site
- Browser requests where Origin is present but doesn't match Host (old browsers)

**What gets allowed:**

- Sec-Fetch-Site: same-origin (browser, same origin)
- Sec-Fetch-Site: none (browser, user-initiated like bookmarks)
- No Sec-Fetch-Site + no Origin (not a browser ‚Äî API clients)
- No Sec-Fetch-Site + Origin matches Host (old browser, same origin)
- Any request to a trusted origin in CSRF_TRUSTED_ORIGINS 

So default-on should not break APIs at all. The protection only kicks in when browser-specific headers are present and indicate a cross-origin request.

Does this address your concern, or am I missing an edge case?
"
flask,5863,Issue,Comentario,"Yeah, I think ""neither header present ‚Üí allow (not a browser)"" addresses my concern."
flask,5863,Issue,Comentario,"This was already on my radar. I've experimented a bit with a middleware in Werkzeug or an implementation in Flask (or both). The difficulty comes from figuring out a nice way to manage allowed origins and exempt paths. Go's implementation reuses its routing implementation, but creating a separate map of exempt paths is a bit more expensive (and difficult to sync configurations) in Werkzeug/Flask. I'm also not sure if we could use `TRUSTED_HOSTS` as the allowed origins as well, but I'm pretty sure we can't as ""host"" is different from ""origin""."
flask,5863,Issue,Comentario,"@davidism Here's how I was thinking of implementing this.

**Option 1: Flask + Werkzeug implementation**

1. Accept csrf as a parameter to `@app.route | @blueprint.route` but will still be in `**options` kwargs
2. `werkzeug.routing.Rule` [class](https://github.com/pallets/werkzeug/blob/a9f6b3c7924912e62ea74f39f10fb611d6e7725e/src/werkzeug/routing/rules.py#L459-L473) to have the argument `csrf` and attribute `csrf` 
3. In `flask.App.full_dispatch_request`, call `self.check_csrf(ctx.request)` after `request_started.send` and before `self.preprocess_request` 

https://github.com/pallets/flask/blob/2579ce9f18e67ec3213c6eceb5240310ccd46af8/src/flask/app.py#L1001-L1002

**Option 2: Flask only implementation**

1. Same as above
2. Instead of adding argument to `werkzeug.routing.Rule`, just set `rule_obj.csrf = options.get(""csrf"")` similar to how `provide_automatic_options` is set.
3. Same as above 

https://github.com/pallets/flask/blob/2579ce9f18e67ec3213c6eceb5240310ccd46af8/src/flask/sansio/app.py#L647-L648

---

**On exempt paths:** This approach avoids the ""separate map of exempt paths"" problem entirely. Since `csrf` is stored on the `Rule` object itself, we just check `request.url_rule.csrf` at dispatch time requiring no separate data structure to sync.

**On `TRUSTED_HOSTS` vs origins:** You're right, they're different. So I'd keep them separate:

- `TRUSTED_HOSTS`: existing, for [Host header validation](https://flask.palletsprojects.com/en/stable/api/#flask.Request.trusted_hosts)
- `CSRF_TRUSTED_ORIGINS`: new, full origins for cross-origin allowlist (OAuth callbacks, etc.)

**On Werkzeug vs Flask:** I lean toward Option 2 (Flask only) since:
- The check logic references Flask's `app.config` for `CSRF_TRUSTED_ORIGINS`
- It follows the `provide_automatic_options` precedent
- Werkzeug stays transport-layer focused

The core check logic (~40 lines) could still live in Werkzeug as a utility function that Flask calls, if you want other frameworks to benefit. But the routing integration feels Flask-specific.

Want me to put together a draft PR for Option 2?"
flask,5863,Issue,Comentario,"You're using an LLM tool to write for you. If I wanted to chat about and idea and design with an LLM, I could do so directly at any time, I don't need you as an intermediary. Closing, I'll work on this myself at some point."
flask,5864,Pull Request,Titulo,Add built-in CSRF protection using Sec-Fetch-Site header
flask,5864,Pull Request,Descripcion,"Implements Option 2 from #5863.

Adds built-in CSRF protection using the Sec-Fetch-Site header that modern browsers send
 automatically, with an Origin header fallback for older browsers.

**Changes**

- Add CSRF_PROTECTION, CSRF_TRUSTED_ORIGINS, and CSRF_PROTECTED_METHODS config options
- Add csrf_protection parameter to @app.route() and add_url_rule()
- Add csrf_protection attribute support for class-based views
- Check CSRF in full_dispatch_request() before preprocess_request()

**Algorithm**

1. Allow safe methods (GET, HEAD, OPTIONS)
2. Allow if origin is in CSRF_TRUSTED_ORIGINS
3. If Sec-Fetch-Site header present: allow same-origin/none, reject
same-site/cross-site
4. If no browser headers present: allow (non-browser clients)
5. If Origin present: allow if it matches Host, otherwise reject

**Usage**

```python
# Enable globally
app.config['CSRF_PROTECTION'] = True

# Enable per-route
@app.route('/api', methods=['POST'], csrf_protection=True)
def api():
    ...

# Exempt a route when enabled globally
@app.route('/webhook', methods=['POST'], csrf_protection=False)
def webhook():
    ...
```

fixes #5863
"
flask,5864,Pull Request,Comentario,Are you using an LLM tool to substantially generate your writing or code?
flask,5864,Pull Request,Comentario,"> Are you using an LLM tool to substantially generate your writing or code?

Used claude code with opus 4.5 (substantially for the test cases)."
flask,5864,Pull Request,Comentario,"@ThiefMaster apologies if I've missed any contribution guidelines around tooling or process; happy to correct anything that's not aligned.

@davidism and @ThiefMaster If you have concerns about the implementation or approach itself, I'd genuinely like to hear them."
flask,5864,Pull Request,Comentario,"You didn't have time to understand or implement the feature, but you expect the maintainers to have that time to carefully review everything you asked an LLM to generate. That's not acceptable for anything, but especially for a security-related feature. 

If I did want to use an AI, I have access to the same tools you do, so you saved me essentially no time at all in that case."
flask,5857,Pull Request,Titulo,Add documentation and fix type safety bugs
flask,5857,Pull Request,Descripcion,"# Bug report

**Describe the bug**

The recent refactor introduced a missing type safety and potential runtime error:
- `remove_ctx` and `add_ctx` lacked documentation, making their purpose unclear.
- `get_send_file_max_age` returned a value without proper type casting, triggering `type: ignore` comments.
- The static file route used a lambda referencing a weakref; if the app was garbage‚Äëcollected it could raise an obscure error.
- `raise_routing_exception` raised `request.routing_exception` without guaranteeing it was not `None`, leading to a possible `TypeError`.

These issues manifested as type‚Äëchecking failures and potential crashes when serving static files or handling routing exceptions.

**Steps to reproduce**

1. Run the test suite (`pytest`).
2. Observe `type: ignore` warnings and potential failures in `test_regression.py` when static files are accessed.
3. Manually trigger a routing exception (e.g., abort with a redirect) and notice that `raise_routing_exception` may raise `None`.
4. Access a static file after the app has been garbage‚Äëcollected (unlikely in normal use but possible in long‚Äërunning processes).

**Expected behavior**

- Functions should have clear docstrings.
- `get_send_file_max_age` should return an `int` or `None` with proper type casting.
- The static file view should raise a clear `RuntimeError` if the app is unavailable.
- `raise_routing_exception` should assert the exception exists before raising.

**Environment**

- Python version: 3.12
- Flask version: 3.2.0.dev
"
flask,5857,Pull Request,Comentario,"This kind of smells like AI-generated slop considering the `ISSUE.md` file you ended up committing...

Mixing unrelated changes in a single PR is also not a good idea."
flask,5854,Pull Request,Titulo,Deprecate should_ignore_error method and add unit tests
flask,5854,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
This pull request deprecates the Flask.should_ignore_error method according to the current context preservation design. 
It now always returns False and is no longer meaningful. Unit tests have been added to verify its behavior, including:
- parameterized test for multiple exception types
- return value always False
- repeated calls trigger DeprecationWarning
"
flask,5855,Pull Request,Titulo,kimi-v1
flask,5855,Pull Request,Descripcion,"Âú®ÂΩìÂâçÈ°πÁõÆ‰∏≠Â¢ûÂä† flask/scheduler Êâ©Â±ïÔºöÂê´Ë∞ÉÂ∫¶Âô®„ÄÅ‰ªªÂä°Ë£ÖÈ•∞Âô®(interval/delay/cron)„ÄÅcron Ëß£Êûê„ÄÅÁä∂ÊÄÅÂ≠òÂÇ®„ÄÅÊåáÊ†á‰∏éÁÆ°ÁêÜËìùÂõæ(/_internal/metrics, POST /_internal/tasks//run, /reload)Ôºå‰ªªÂä°Áä∂ÊÄÅÂ≠óÊÆµ‰∏éÂºÇÂ∏∏ËÆ∞ÂΩïÔºåÈÖçÁΩÆÈ°π SCHEDULER_ENABLED/AUTOSTART/TICK_INTERVALÔºåÁ§∫‰æã 3 ‰∏™‰ªªÂä°ÔºåÊØè 10 Áßí„ÄÅÂª∂Ëøü 5 Áßí„ÄÅcron */2 * *„ÄÇ"
flask,5856,Pull Request,Titulo,Refactor Blueprint.register to reduce cyclomatic complexity
flask,5856,Pull Request,Descripcion,"Refactored Blueprint.register method in src/flask/sansio/blueprints.py.

- Extracted helper methods:
  _ensure_unique_name,
  _register_static,
  _merge_blueprint_funcs_if_needed,
  _run_deferred_functions,
  _register_cli,
  _register_nested_blueprints,
  _compute_nested_blueprint_options.

- Reduced cyclomatic complexity from D (23) to A (2).
- All tests pass: 485 passed, 5 skipped."
flask,5861,Issue,Titulo,Proposal: CLI command to validate API endpoints by making test requests
flask,5861,Issue,Descripcion,"### Motivation

When working on Flask applications with many API endpoints, it is sometimes
useful to quickly check whether all registered routes can be accessed without
raising unexpected errors (e.g. unhandled exceptions, 500 errors).

At the moment, developers typically need to write custom scripts or tests to
perform this kind of basic validation. Providing an opt-in CLI command could
help improve developer experience, especially during local development.

### Proposal

Introduce an optional Flask CLI command (for example, `flask check-endpoints`)
that iterates over registered routes and makes test requests using Flask‚Äôs
test client.

The goal would not be full correctness testing, but a lightweight sanity check
to detect obvious runtime errors.

Possible initial scope:
- Only routes with simple methods (e.g. GET by default)
- Skip routes with required path parameters
- Report endpoints that raise exceptions or return 5xx responses
- Development-only usage

### Design considerations

- The command should be fully opt-in and not affect existing behavior.
- No network requests; use Flask‚Äôs built-in test client.
- Keep output simple and readable (similar to `flask routes`).
- Advanced features (custom payloads, auth, etc.) could be out of scope initially.

### Open questions

- Should this live as a core CLI command or as an optional extension?
- How should endpoints with required parameters or authentication be handled?
- Should the command fail on the first error or report all failures?

Feedback on the general direction and scope would be appreciated before
starting an implementation.
"
flask,5861,Issue,Comentario,I think you could easily create that as a standalone package that integrates in the flask-cli via an entrypoint.
flask,5861,Issue,Comentario,"@ThiefMaster 
Yes, so I've already created it, and I'd like to discuss here what features would be useful."
flask,5861,Issue,Comentario,"ah ok, to me it sounded like something you'd like to have in the flask core. I'll move this to discussions"
flask,5853,Pull Request,Titulo,Added rate limiting functionality to Flask app
flask,5853,Pull Request,Descripcion,"- Introduced MemoryRateLimiter for managing request limits.
- Added configuration options for enabling rate limiting and setting request limits and time windows.
- Implemented methods to enforce rate limits and build rate limit keys based on request context.
- Integrated rate limiting checks into the request handling process.
"
flask,5853,Pull Request,Comentario,there are already extensions like flask-limiter for this...
flask,5853,Pull Request,Comentario,Looking at the name of your branch: Is this some kind of university/school project where you were asked to make a contribution to a project on GitHub?
flask,5853,Pull Request,Comentario,"> Looking at the name of your branch: Is this some kind of university/school project where you were asked to make a contribution to a project on GitHub?

Yes, and we were asked to contribute to a big library but I don't think any of us really know how to or what contributions to make. "
flask,5853,Pull Request,Comentario,"Please convey to your teacher that this is not an acceptable way to promote open source contribution. They need to properly set you up for success, rather than hoping you figure it out. This was not a good use of maintainer time."
flask,5853,Pull Request,Comentario,"> Please convey to your teacher that this is not an acceptable way to promote open source contribution. They need to properly set you up for success, rather than hoping you figure it out. This was not a good use of maintainer time.

Yes I will do that, my sincere apologies."
flask,5852,Pull Request,Titulo,Docs: Add WSGI documentation note to README
flask,5852,Pull Request,Descripcion,Added a helpful documentation note to the README explaining what WSGI stands for (Web Server Gateway Interface) and its purpose. This clarifies the acronym for newcomers to the Flask framework.
flask,5852,Pull Request,Comentario,thanks but this isn't really an improvement...
flask,5851,Issue,Titulo,Add Copy-to-Clipboard button for code examples in documentation
flask,5851,Issue,Descripcion,"### Feature Request: Add copy button to code blocks in documentation

#### Problem

Many pages in the Flask documentation contain multi-line code snippets, but there is no built-in way to copy the entire block with one click. Users currently need to manually select text, which is slower and error-prone.

#### Proposed Solution

Add a small ""Copy"" button to each `div.highlight` element using a small JavaScript file included via Sphinx.

- Implemented using the native Clipboard API (no external library)
- Minimal UI impact
- Applied only to docs frontend, not core package

#### Motivation & Benefits

- Easier copy-paste for beginners following tutorials
- Consistent with other frameworks (FastAPI, Django, Click docs, etc.)
- Improves developer experience without affecting core Flask code

#### Status

I have already implemented a working version locally and can submit a PR once approved.

Let me know if this is useful and if I should proceed with a pull request.
"
flask,5849,Pull Request,Titulo,Add copy-to-clipboard button for code blocks in Flask documentation.
flask,5850,Pull Request,Titulo,Add copy-to-clipboard button for code blocks in Flask documentation.
flask,5850,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

This pull request adds a **‚Äúcopy to clipboard‚Äù button** for all code blocks in the Flask documentation.  
This feature improves usability by allowing users to quickly copy code snippets with a single click, enhancing the overall documentation experience.

The implementation includes:
- A copy button added to each code block.
- JavaScript logic to handle clipboard copying.
- Styling to ensure visibility while matching the existing documentation theme.

Below are screenshots demonstrating the new UI changes:

<img width=""972"" height=""278"" alt=""Copy Button Preview"" src=""https://github.com/user-attachments/assets/4cbd52d2-bf76-4961-9d8c-c3cee960b450"" />

<img width=""990"" height=""309"" alt=""Copy Button Functionality"" src=""https://github.com/user-attachments/assets/ea744dd5-5a1f-4385-a01e-db430531407d"" />

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

fixes **#5848**

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->

I have followed all the steps in `CONTRIBUTING.rst`:

- Added/updated relevant documentation in the `docs` folder.  
- Added an entry in `CHANGES.rst` summarizing the change and linking to the issue.  
- Included `.. versionchanged::` entries in appropriate documentation code strings.  
- (Tests are not required for this documentation UI feature.)
"
flask,5848,Issue,Titulo,Add copy-to-clipboard button for code blocks in Flask documentation.
flask,5848,Issue,Descripcion,"### Description

I propose to add a ""copy to clipboard"" button next to all code blocks in the Flask documentation. This will allow users to easily copy example code or command-line snippets with a single click instead of manually selecting the text. This feature greatly improves usability and convenience, especially on mobile devices.

Flask documentation uses Sphinx for static site generation, and there is an existing Sphinx extension called [sphinx-copybutton](https://sphinx-copybutton.readthedocs.io/en/latest/) that provides this functionality out of the box. It can be enabled by simply adding it to the `extensions` list in the Sphinx `conf.py` file.


This extension also supports stripping common prompts (like `>>>`, `$`) from copied content, making the copied snippets cleaner.

### Problem this resolves

Currently, users have to manually select and copy code blocks, which can be error-prone and inconvenient. Adding a copy button makes the process faster and less error-prone.

### Additional notes

- The change is additive and does not affect existing documentation content or structure.
- This enhancement aligns Flask docs with modern documentation practices seen in many popular projects.

I am happy to implement this feature and create a pull request once the issue is approved.

"
flask,5831,Pull Request,Titulo,Update installation instructions for Windows PowerShell
flask,5831,Pull Request,Descripcion,Added instructions for enabling PowerShell script execution on Windows.
flask,5831,Pull Request,Comentario,Just checked my build and the link is broken...
flask,5831,Pull Request,Comentario,Fixed! Silly missing underscores.
flask,5831,Pull Request,Comentario,"I don't think we need to go into this detail here. In fact, I really want to _reduce_ this page, and point people at official docs for uv, virtualenv, etc instead."
flask,5831,Pull Request,Comentario,"I‚Äôm not really sure how to link to that note in the docs as you have to scroll halfway down that page to actually find that note - it would probably be easier for a user to just read it straight from the flask docs, unless you can find a better link that I could use."
flask,5818,Pull Request,Titulo,pass context through dispatch methods
flask,5818,Pull Request,Descripcion,"The current `AppContext` object is passed through the various request dispatch methods, rather than each method accessing the proxies. closes #5815 

@pgjones first proposed this in #5229 as a way to speed up dispatch especially for Quart and async views. This PR applies to more methods, and also implements compatibility during a deprecation period.

Dispatch methods now take `ctx: AppContext` as the first parameter. The following `Flask` methods were changed:

- `update_template_context`
- `handle_http_exception`
- `handle_user_exception`
- `handle_exception`
- `log_exception`
- `dispatch_request`
- `full_dispatch_request`
- `finalize_request`
- `make_default_options_response`
- `preprocess_request`
- `process_response`
- `do_teardown_request`
- `do_teardown_appcontext`

`url_for` and `make_response` were not changed, as it's much more likely that these are called from user code that only has access to the proxy.

An `__init_subclass__` class method is added to detect old signatures on subclasses of `Flask`. The second parameter is inspected (first is self). If it is not annotated, it must be named `ctx`. If it is annotated, it must either be the string or class `AppContext`. If an old signature is detected, the method is wrapped to remove the argument when other `Flask` methods call it during dispatch. The base method is also wrapped to inject the argument so that `super().base_method` from the overridden method will continue to work.

I did not apply the compat wrapper to every base `Flask` method, only the ones that a subclass overrides. Therefore, if user code is directly calling these internal dispatch methods, they will get a `TypeError`. This is only likely (and unlikely at that) to happen during testing. I did this over concern that the wrapper would be unnecessary and a performance hit for most applications. If we get bug reports we can consider adding the wrapper."
flask,5815,Issue,Titulo,pass context internally instead of using contextvars
flask,5815,Issue,Descripcion,"Currently, there are a bunch of different methods on the `Flask` class that run to dispatch each request. Many of these access `request` and other context proxies. We should update them to pass the `AppContext` everywhere instead. This is more convenient after #5812 with only one context object instead of two. As @pgjones pointed out in #5229, not having to access the contextvar is a significant speedup to ASGI Quart, although it doesn't appear to affect WSGI Flask as much. Perhaps if we were serving with greenlets and so contexts were switching more, it would be more noticeable in Flask too.

The obvious problem is that it is a breaking change to the signatures of all these methods. I'm unsure how many methods are affected, but I'm also unsure how many projects are even subclassing `Flask` to override any of the methods. The fact that the methods are public seems unintentional, compared to the much more common ways of configuring and customizing an app.

We could continue to support both signatures, showing a deprecation warning for the old one, by adding some detection to `Flask.__init__`. This would add some amount of time during app setup, but wouldn't affect runtime performance of the app.

---

Another idea I had for the future was to have `@route` and other decorators inspect the signature of the decorated function, to allow injecting `request`, `app`, etc. if users would rather use that pattern than import the proxies. Having the request object directly available in all the dispatch methods would make this more straightforward. User code would be able to choose what pattern they want, the current proxy pattern would never be deprecated for user code.
"
flask,5815,Issue,Comentario,"Not a fan of deprecating it, for 99% of all apps the performance difference is unnecessary so the convenience wins IMHO.

I think nobody wants to update their application to a change like this, also because it would imply having to propagate the vars deeper into application code, util functions, etc. that currently use the profies."
flask,5815,Issue,Comentario,"This would _only_ be for methods on `Flask` (`Scaffold`, etc), it would not require passing them throughout your own code. #5229 gives an idea of the scope of that.

I've been playing around with the injector a bit, it could be used to re-add the arguments from the proxies further down the chain if some code wanted to use that pattern but other didn't.

The deprecation can be unversioned for a bit, just to see if anyone brings it up. If we do this internally, I don't want to support signature inspection and wrappers forever."
flask,5815,Issue,Comentario,"ah, internals only. not such a big deal then, as it would just affect people subclassing..."
flask,5815,Issue,Comentario,"It may be very difficult to do this in a way that existing overridden code will not fail and will show a deprecation warning.

We want to upgrade an overridden method that does not take the new `ctx: AppContext` parameter. We can detect this in `__init_subclass__` with `inspect.signature`, and wrap the function to take the correct signature, so that other parts of the dispatch code will call it correctly. But that's the ""simple"" part.

What if other user code is still calling the method, overridden or not, without the new argument? The most obvious way this happens is with `super().method` within the overridden method. The wrapper could perhaps be clever enough to check the type of the first argument, and decide to make a new or old signature call. The wrapper would have to be applied to every base method to handle the `super` call case.

I haven't tried to write this more complex wrapper yet. I have a feeling it will be difficult to write. I know it will add overhead to every request, since multiple methods will now have to do detection on the arguments passed to them. This overhead will mostly be waste, as the vast majority of code will not be overridden.

Perhaps we can just say this is a breaking change in 4.0? I still think the result is worth it. We could still show a better error message by doing some detection in `__init_subclass__`, but showing an error instead of applying a wrapper and showing a warning."
flask,5815,Issue,Comentario,"The following method signatures would change to add `ctx: AppContext` as the first parameter:

- `update_template_context`
- `handle_http_exception`
- `handle_user_exception`
- `handle_exception`
- `log_exception`
- `dispatch_request`
- `full_dispatch_request`
- `finalize_request`
- `make_default_options_response`
- `preprocess_request`
- `process_response`
- `do_teardown_request`
- `do_teardown_appcontext`

I'd be somewhat surprised to find any of these overridden. They're either really internal, or they're the machinery that calls registered callback functions."
flask,5815,Issue,Comentario,"I've managed to write some code that can detect overridden methods with the old signature, and wrap them and the corresponding base method so they'll continue to work during the deprecation period."
flask,5847,Pull Request,Titulo,docs: Improve Quickstart example clarity for beginners
flask,5847,Pull Request,Descripcion,"## Description
   This PR improves the Quickstart documentation to help beginners understand:
   - Where to save their first Flask application
   - How to structure the basic example
   - Common patterns like `if __name__ == '__main__'`
   
   ## Changes Made
   - Added explicit file naming instructions
   - Enhanced code comments
   - Included complete working example
   - Clarified common beginner confusion points
   
   ## Testing
   - Built documentation locally and verified changes render correctly
   - Tested example code to ensure it works
   
   ## Related Issues
   Addresses common beginner confusion mentioned in #[issue-number if applicable]"
flask,5847,Pull Request,Comentario,"I don't think this is a useful change. For example, `flask run` is a thing and thus the part of running the file directly isn't even needed in the code."
flask,5836,Issue,Titulo,Test failures with click 8.3.1
flask,5836,Issue,Descripcion,"Click 8.3.1 was [tagged](https://github.com/pallets/click/releases/tag/8.3.1) but not released on PyPI. Running flask's test suite with that version results in
```
============================= test session starts ==============================
platform linux -- Python 3.13.8, pytest-8.4.2, pluggy-1.6.0
rootdir: /build/flask-3.1.2
configfile: pyproject.toml
testpaths: tests
collected 490 items                                                            

tests/test_appctx.py ..............                                      [  2%]
tests/test_async.py ........                                             [  4%]
tests/test_basic.py .................................................... [ 15%]
........................................................................ [ 29%]
......                                                                   [ 31%]
tests/test_blueprints.py ............................................... [ 40%]
.............                                                            [ 43%]
tests/test_cli.py ...................................................F.. [ 54%]
...F                                                                     [ 55%]
tests/test_config.py ...................                                 [ 58%]
tests/test_converters.py ..                                              [ 59%]
tests/test_helpers.py ...................................                [ 66%]
tests/test_instance_config.py .......                                    [ 67%]
tests/test_json.py ...............................                       [ 74%]
tests/test_json_tag.py ..............                                    [ 77%]
tests/test_logging.py ......                                             [ 78%]
tests/test_regression.py .                                               [ 78%]
tests/test_reqctx.py .......ss.....                                      [ 81%]
tests/test_request.py ...                                                [ 82%]
tests/test_session_interface.py .                                        [ 82%]
tests/test_signals.py .......                                            [ 83%]
tests/test_subclassing.py .                                              [ 83%]
tests/test_templating.py ................................                [ 90%]
tests/test_testing.py .........................                          [ 95%]
tests/test_user_error_handler.py .........                               [ 97%]
tests/test_views.py .............                                        [100%]

=================================== FAILURES ===================================
______________________________ test_run_cert_path ______________________________

    def test_run_cert_path():
        # no key
        with pytest.raises(click.BadParameter):
            run_command.make_context(""run"", [""--cert"", __file__])
    
        # no cert
>       with pytest.raises(click.BadParameter):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'click.exceptions.BadParameter'>


tests/test_cli.py:590: Failed
__________________________ test_run_exclude_patterns ___________________________

    def test_run_exclude_patterns():
>       ctx = run_command.make_context(""run"", [""--exclude-patterns"", __file__])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


tests/test_cli.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:1216: in make_context
    self.parse_args(ctx, args)
        args       = []
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        extra      = {}
        info_name  = 'run'
        parent     = None
        self       = <Command run>
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:1227: in parse_args
    _, args = param.handle_parse_result(ctx, opts, args)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        _          = 5000
        args       = []
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        opts       = {'exclude_patterns': '/build/flask-3.1.2/tests/test_cli.py'}
        param      = <Option key>
        param_order = [<Option exclude_patterns>]
        parser     = <click.parser._OptionParser object at 0x7ffff4b08bd0>
        self       = <Command run>
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:2548: in handle_parse_result
    value = self.process_value(ctx, value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        args       = []
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        opts       = {'exclude_patterns': '/build/flask-3.1.2/tests/test_cli.py'}
        self       = <Option key>
        source     = <ParameterSource.DEFAULT: 3>
        value      = Sentinel.UNSET
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:3283: in process_value
    return super().process_value(ctx, value)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        __class__  = <class 'click.core.Option'>
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        self       = <Option key>
        value      = Sentinel.UNSET
/nix/store/53y968aagcaaq46hq3rg2a3mmxwmzvm1-python3.13-click-8.3.1/lib/python3.13/site-packages/click/core.py:2443: in process_value
    value = self.callback(ctx, self, value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ctx        = <click.core.Context object at 0x7ffff4c02b10>
        self       = <Option key>
        value      = None
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ctx = <click.core.Context object at 0x7ffff4c02b10>, param = <Option key>
value = None

    def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:
        """"""The ``--key`` option must be specified when ``--cert`` is a file.
        Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
        """"""
        cert = ctx.params.get(""cert"")
        is_adhoc = cert == ""adhoc""
    
        try:
            import ssl
        except ImportError:
            is_context = False
        else:
            is_context = isinstance(cert, ssl.SSLContext)
    
        if value is not None:
            if is_adhoc:
                raise click.BadParameter(
                    'When ""--cert"" is ""adhoc"", ""--key"" is not used.', ctx, param
                )
    
            if is_context:
                raise click.BadParameter(
                    'When ""--cert"" is an SSLContext object, ""--key"" is not used.',
                    ctx,
                    param,
                )
    
            if not cert:
                raise click.BadParameter('""--cert"" must also be specified.', ctx, param)
    
            ctx.params[""cert""] = cert, value
    
        else:
            if cert and not (is_adhoc or is_context):
>               raise click.BadParameter('Required when using ""--cert"".', ctx, param)
E               click.exceptions.BadParameter: Required when using ""--cert"".

cert       = Sentinel.UNSET
ctx        = <click.core.Context object at 0x7ffff4c02b10>
is_adhoc   = False
is_context = False
param      = <Option key>
ssl        = <module 'ssl' from '/nix/store/cfapjd2rvqrpry4grb0kljnp8bvnvfxz-python3-3.13.8/lib/python3.13/ssl.py'>
value      = None

/nix/store/12gfdjrf93rixvjrkj9pbfy5349q3j4m-python3.13-flask-3.1.2/lib/python3.13/site-packages/flask/cli.py:870: BadParameter
=========================== short test summary info ============================
FAILED tests/test_cli.py::test_run_cert_path - Failed: DID NOT RAISE <class 'click.exceptions.BadParameter'>
FAILED tests/test_cli.py::test_run_exclude_patterns - click.exceptions.BadParameter: Required when using ""--cert"".
================== 2 failed, 486 passed, 2 skipped in 13.73s ===================
```"
flask,5836,Issue,Comentario,"`test_run_exclude_patterns` can be fixed by replacing
https://github.com/pallets/flask/blob/88a65bb374e87a18816a780dbd4ae69d307aa85c/src/flask/cli.py#L861
with
```python
if cert is not None and cert != click._utils.UNSET and not (is_adhoc or is_context):
```
but this is probably an upstream bug
cc @rowlando13"
flask,5836,Issue,Comentario,"Sentinel is an implementation detail that is not intentionally exposed. However, it is in the context params during a callback: sentinel_in_callback.py

```
import click

def _validate(ctx, param, value):

    you_sentinel = ctx.params.get(""you"")
    you_too_sentinel = ctx.params.get(""you_too"")
    print(f""you: {you_sentinel}"")
    print(f""you_too: {you_too_sentinel}"")
    print(f""param: {param}"")
    print(f""value: {value}"")
    return value

@click.group()
def basic():
    pass

@basic.command()
@click.argument('you', required=False)
@click.option('--you-too', )
@click.option('--yall', callback=_validate)
@click.pass_context
def hello(ctx, you, you_too, yall):
    click.echo('Hello World!')

if __name__ == '__main__':
    basic()
    # python -m sentinel_in_callback hello
``` 

``` 
> python -m sentinel_in_callback hello
you: Sentinel.UNSET
you_too: Sentinel.UNSET
param: <Option yall>
value: None
Hello World!
```"
flask,5836,Issue,Comentario,Minimal reproduction for flask failures. 
flask,5836,Issue,Comentario,`_validate_key` is used as a callback for an option. The test is invoking the command directly with `Command.make_context()`. 
flask,5836,Issue,Comentario,"@davidism I am on the fence, should this bug hold up releasing click 8.3.1? "
flask,5836,Issue,Comentario,"I'd prefer this held up 8.3.1, as it's an indicator that there is still a problem with Click's new default implementation."
flask,5836,Issue,Comentario,Closing because this is an issue that will be addressed in Click.
flask,5836,Issue,Comentario,"FYI, I just proposed a fix at: https://github.com/pallets/click/pull/3137"
flask,5846,Pull Request,Titulo,Fix _validate_key to handle click 8.3.1 Sentinel values
flask,5846,Pull Request,Descripcion,"Fixes #5836

Updates the condition in _validate_key to properly check for click._utils.UNSET sentinel value, which is now present in ctx.params during callbacks in click 8.3.1.

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5846,Pull Request,Comentario,"The fix will be in Click, not here. UNSET is an internal symbol."
flask,5689,Issue,Titulo,Is flask still being maintained?
flask,5689,Issue,Descripcion,"Is flask still being maintained, I see the git was updated 2 month back, can I still use flask for my new project?"
flask,5689,Issue,Comentario,Flask is stable mature software with most issues resolved it's unrealistic to expect the same activity as a project under exploration/shift 
flask,5689,Issue,Comentario,Thanks for clarification
flask,5833,Pull Request,Titulo,fix typos discovered by  codespell
flask,5833,Pull Request,Descripcion,"Fix typos discovered by codespell - https://pypi.org/project/codespell

% `codespell --ignore-words-list=te`
```
./docs/appcontext.rst:122: requet ==> request
./docs/quickstart.rst:465: interanlly ==> internally
./docs/templating.rst:186: avaialble ==> available
```
% `codespell -ignore-words-list=te --write-changes` "
flask,5833,Pull Request,Comentario,"See our contributing guide about docs https://palletsprojects.com/contributing/docs, in particular

> If you are fixing or improving existing docs, or writing about existing features, you want to branch off of the stable branch, as well as target the stable branch in the PR."
flask,5833,Pull Request,Comentario,"Unfortunately, the three typos above are not on the `stable` branch, so let's get `codespell` in place to catch future typos.
* #5844 "
flask,5834,Pull Request,Titulo,`pre-commit autoupdate --freeze` 2025-10-23
flask,5834,Pull Request,Descripcion,"% `pre-commit autoupdate --freeze`
```
[https://github.com/astral-sh/ruff-pre-commit] updating v0.12.9 -> v0.14.1 (frozen)
[https://github.com/astral-sh/uv-pre-commit] updating 0.8.12 -> 0.9.5 (frozen)
```
% `pre-commit run --all-files`
```
```
* https://github.com/astral-sh/ruff/releases
* https://github.com/astral-sh/uv/releases -- Fixes [CVE-2025-62518](https://github.com/advisories/GHSA-j5gw-2vrg-8fgx) a high-severity vulnerability.

It is unclear to me how modifying `.pre-commit-config.yaml` would break `Tests / Development Versions`."
flask,5832,Pull Request,Titulo,GitHub Actions: Add Python 3.14 and 3.14t to the testing
flask,5832,Pull Request,Descripcion,"On branch ___stable___.

https://www.python.org/downloads/release/python-3140/

https://py-free-threading.github.io/porting
"
flask,5840,Pull Request,Titulo,docs: enhance README with comprehensive examples and troubleshooting
flask,5840,Pull Request,Descripcion,"This PR significantly improves the Flask README by:

- Adding comprehensive quick start guide with step-by-step instructions
- Including multiple practical examples covering common use cases
- Adding advanced features section with blueprints and database integration
- Creating detailed troubleshooting section for common beginner issues
- Providing project structure guidance and installation options
- Enhancing organization with clear sections and better formatting

These enhancements make the README much more beginner-friendly and practical for real-world Flask development."
flask,5837,Pull Request,Titulo,Create jenkinsfile
flask,5837,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5838,Pull Request,Titulo,Update app.py
flask,5838,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5838,Pull Request,Comentario,This is not your playground. Stop sending garbage PRs to other people's repos to learn how to use GitHub.
flask,5839,Issue,Titulo,"Really, I can't close connection???"
flask,5839,Issue,Descripcion,"Jesus Christ, what kind of library doesn‚Äôt allow forcefully closing a connection? Even after returning or using abort, it still continues to process data in the background. This is disappointing, there‚Äôs no way, for example, to forcefully stop a file upload after checking its header. It will still continue to process the remaining 100 GB of the file.

```
@app.route('/upload', methods=['POST'])
def upload_file():
    print(1)
    return ""wtf"", 400 # still continues to process data
```"
flask,5839,Issue,Comentario,"Now try again without being passive aggressive. This is not appreciated anywhere, but in particular not by open source maintainers."
flask,5839,Issue,Comentario,"Also, your webserver should typically be configured with sane limits. In fact, the code in your function won't even run until the file has been uploaded."
flask,5839,Issue,Comentario,"Yeah, I set the limit to 2 GB, but I don‚Äôt want it to keep uploading the full 2 GB. It does start immediately tho. I can then get the stream with `request.files.get('file')`, but reading the header takes quite some time `header = file.stream.read(1024)`. So I decided to check if I could just abort the connection immediately, like in the example, and no, I can‚Äôt.

FIX: Actually, I think it‚Äôs a Chrome problem now. I‚Äôve never experienced anything like that because it works fine when using curl."
flask,5839,Issue,Comentario,"Regardless of frustration you may be feeling, your approach to reporting this issue and asking for help was not acceptable. Please reflect on how you'd like people to interact with you, then apply that to future interactions with others."
flask,5829,Pull Request,Titulo,Docs typo/markup fixes
flask,5829,Pull Request,Descripcion,Just two typos I've run into.
flask,5828,Pull Request,Titulo,docs: fix missing quote in flashing example
flask,5828,Pull Request,Descripcion,"### Change

Fix missing quotation mark in ‚ÄúFlashing with categories‚Äù example.

### Description

* Add missing quotation mark in `<ul class=flashes>` -> `<ul class=""flashes"">`."
flask,5828,Pull Request,Comentario,It's valid as is
flask,5828,Pull Request,Comentario,"Sorry about that, I didn't know single class names without quotations were valid in HTML5. 

Thank you so much for the review!"
flask,5826,Pull Request,Titulo,docs: clarify JSON parsing error conditions in Flask views
flask,5826,Pull Request,Descripcion,"## Update Documentation: JSON Parsing Behavior

Update the documentation to specify that JSON parsing fails for any reason, including a missing or incorrect `Content-Type` header, not just invalid JSON or an unset header. This improves accuracy and clarity for developers.

issue #5825 "
flask,5826,Pull Request,Comentario,"This doesn't address the linked issue, which talks about a specific error code, whereas this only rewords the existing sentence. The linked issue even has the suggested wording. It only required copying a sentence from one place to another, no writing required, no reason to reach for AI."
flask,5821,Pull Request,Titulo,Add type hints to tutorial and Javascript examples
flask,5821,Pull Request,Descripcion,"- Add return type annotations and parameter types
 - Import necessary typing modules (Optional, Union, Flask, Response)
 - Improve code readability and IDE support for examples
 - All existing tests continue to pass

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5821,Pull Request,Comentario,"LGTM, follows other areas of the source in style, thanks for adding the type hints!"
flask,5821,Pull Request,Comentario,Thanks!! I'll do it 
flask,5821,Pull Request,Comentario,@davidism This PR got closed but I don't see it merged back into main.  I'm still learning so was just wondering what that means.  The code changes have been deemed unnecessary or they will be merged back into main at som point?
flask,5821,Pull Request,Comentario,"IMHO the changes are not particularly useful and just make otherwise simple examples harder to understand, especially for beginners. Having type hints on view functions in an application do not add any rael benefit, unlike type hints on library code, utils, etc."
flask,5821,Pull Request,Comentario,"Well said, an opinion hahaha"
flask,5819,Issue,Titulo,Enrich Flask‚Äôs public API type hints using typing.Annotated with Doc metadata
flask,5819,Issue,Descripcion,"## Feature Request

### Summary

Enhance selected public Flask APIs (for example `add_url_rule` and `route`) by adding
`typing.Annotated` with `Doc` metadata **and `Literal` types for HTTP methods** to provide
richer IDE assistance and stronger static type checking.

### Example

```python
from typing import Annotated, Literal
from typing_extensions import Doc

# Strict HTTP method type for auto-complete and validation
Method = Literal[""GET"", ""POST"", ""PUT"", ""DELETE"", ""PATCH"", ""OPTIONS"", ""HEAD""]

def add_url_rule(
    rule: Annotated[str, Doc(""URL path such as '/home' or '/api/items/<int:id>'"")],
    *,
    methods: Annotated[list[Method], Doc(""Allowed HTTP methods, e.g. ['GET', 'POST']"")],
    ...
) -> None:
    ...
```

### Benefits

* **Better editor/IDE hints and documentation** for route paths and HTTP methods.
* **Static validation of HTTP verbs** so type checkers catch typos like `""GEET""`.
* **Backward compatible** with existing type checkers and runtime behavior (`typing_extensions.Annotated` and `Literal` are supported across Python versions Flask supports).

### Questions for Maintainers

* Would you accept `Annotated` + `Doc` and `Literal` types in public API signatures?
* If yes, should I begin with a small pilot (e.g., only `add_url_rule`) before expanding to other decorators such as `route`?
"
flask,5229,Pull Request,Titulo,Pass the request ctx rather than use the globals in the app
flask,5229,Pull Request,Descripcion,"The globals have a performance penalty which can be justified for the convinience in user code. In the app however the ctx can easily be passed through the method calls thereby reducing the performance penalty.

This may affect extensions if they have subclassed the app and overridden these methods.

Checklist:

- [x] Add tests that demonstrate the correct behavior of the change. Tests should fail without the change.
- [x] Add or update relevant docs, in the docs folder and in code.
- [x] Add an entry in `CHANGES.rst` summarizing the change and linking to the issue.
- [x] Add `.. versionchanged::` entries in any relevant code docs.
- [x] Run `pre-commit` hooks and fix any issues.
- [x] Run `pytest` and `tox`, no tests failed.
"
flask,5229,Pull Request,Comentario,"I've done something similar for Quart after finding it had a significant impact on micro benchmarks.

Edit: The quart study was done a few years ago before the switch to ContextVars which seem significantly quicker. I still think this is a useful change, but seems less performance motivated now."
flask,5229,Pull Request,Comentario,"My initial reaction is that while this makes sense, I'm uncomfortable with making the change. I'll have to think about this for a little bit. "
flask,5229,Pull Request,Comentario,"Could you give more information about the benchmarks? How micro are we talking; how fast does the complexity of the app overshadow any speed gains?

Is the speed loss in the use of the proxy, or is the gain in the use of the local variable? Perhaps using `_cv_req.get()` directly and avoiding the proxy could have a similar improvement?"
flask,5229,Pull Request,Comentario,"This is an interesting one, with Quart the equivalent to this makes around a 1.5 times improvement, whereas for Flask it doesn't seem to have any affect (maybe a minor positive one). I don't think I can therefore remove it from Quart, but I'd like the APIs to match. 

(I tried `_cv_request` in Quart and it made little difference.)

Also I don't think this makes it more complex - without knowledge of Flask's globals it would be expected to be passed via the call chain."
flask,5229,Pull Request,Comentario,This will be deferred to allow further discussion.
flask,5229,Pull Request,Comentario,continued in #5818
flask,5812,Pull Request,Titulo,merge app and request context
flask,5812,Pull Request,Descripcion,"Merges the `RequestContext` class into the `AppContext` class. closes #5639

A lot of the size of this PR is rewriting or cleaning up docs related to the contexts. See `ctx.py` for the bulk of the work, and even there it's pretty much no new code, mostly deduplication. The ""request context"" still exists, but what data is available on the context object is what distinguishes it from an ""app context"" now.

How the user works with the context is pretty much unchanged. For example, `teardown_request` and `teardown_appcontext` still both exist, `app.app_context` and `app.test_request_context`, etc. All the same global proxies, `current_app`, `g`, `request`, and `session` still exist and are still available. in the same situations they were before.

The difference is that we no longer have to track whether an app context is already pushed when pushing a request context. This was already sort of an artificial behavior, it was not something that would ever happen under intended/documented request or testing scenarios. Now, every request always sets the app, and the request if request data is given. This greatly simplifies the internal data, as we simply need to record the previous value of the context var to restore on pop.

Some code in app internals was changed to use the contextvar directly, which code was already doing. This probably gains some tiny bit of performance rather than going through the proxies. When we go ahead with #5229 and beyond, we'll be passing around the context objects directly and won't even need to use the contextvar.

---

There are a few implications for testing that may have used `with app.app_context()` around a test client request. I've already highly discouraged this practice in issues over the years because it was already causing other issues. None of these patterns were in our docs.

With the old behavior, an app context was not pushed if one was already pushed when pushing a request context. Therefore,  `teardown_app` functions would only run once the `with` block exited rather than when the request exited. Along with using `with client` around everything, this was already the source of occasional bug reports and questions. The docs also say that no assumptions should be made about how many times a teardown function will be called or what data will be set for them.

Also, `g` was part of the app context, not the request context. Data could be set on `g` ahead of the request, because a new app context wouldn't be pushed. This was never documented, I don't know where I saw it.

```python
# do not do this, for example only
with app.app_context():
    g.user = test_user
    r = client.get(""/secret"")
```

It's not in Flask's docs or tests. The docs show making a request to login before making the request being tested, relying on the session to persist across requests. If you _really_ wanted to set up `g` beforehand, the signal docs show using the `appcontext_pushed` signal to modify the current context's `g` once it's created.

A project may run into some failed tests when upgrading, if they were relying on this. However, the failure would indicate patterns that were already unsound and should be fixed, so I don't see this as a blocker.

Interestingly, `copy_current_request_context` was already not copying `g`. I thought about changing this, but concluded that it was a good thing, because `g` is often used to store connections/caches that are not concurrent safe, such as Flask-SQLAlchemy's `db.session`."
flask,5812,Pull Request,Comentario,Would be great if some people could test their apps with this branch. I'll plan to merge it a week from now.
flask,5812,Pull Request,Comentario,"after `uv pip install 'git+https://github.com/pallets/flask@merge-contexts'` on [indico `master`](https://github.com/indico/indico):

- no errors at import time
- no errors when running the repl w/ all the indico stuff imported (`indico shell`)
- no errors accessing it via web (custom wrapper running the flask dev server)
- all tests still passing"
flask,5812,Pull Request,Comentario,Thanks to those who tested and left a üöÄ or commented on Mastodon. Having a big app like Indico pass unchanged is a good sign as well. Time to merge this.
flask,5639,Issue,Titulo,merge app and request contexts into a single context
flask,5639,Issue,Descripcion,"Right now we have two separate contexts managed separately, the app and request contexts. This makes the implementation pretty complicated, as we need to maintain two context var stacks, and do a bunch of checks in the request context to make sure we're managing the correct app context. It makes an already confusing topic more complicated to explain: app context is active for requests and cli commands, don't push an app context before making a request, etc.

I think merging the two contexts could be possible. The single context (`ExecutionContext`?) would have the `g`, `request`, and `session` attributes, but accessing `request` or `session` when not in a request would raise an error."
flask,5639,Issue,Comentario,"I was never clear on why, but the contexts support being pushed multiple times. If the same context is pushed multiple times, the teardown functions are only run once it's fully popped. I don't think I've ever seen this used, and I can't think of a use case. There is a test, but it just demonstrates that the system works, it doesn't demonstrate any intended use of it. There's no docs about it. Perhaps it's a holdover from how things were tracked as a stack on top of thread locals, before things were refactored?

Having to keep track of a stack of how many times a context has been pushed complicates the implementation, especially when the request context also has to track whether it had to push an app context as well or if one was already present. It would be much easier (and probably faster and less memory) to error if the context is currently pushed.

This is not the same as being able to push _different_ contexts on top of each other."
flask,5639,Issue,Comentario,"Tentatively marking this for 3.2. I think I can do the merge and have uses of the old contexts issue deprecation warnings and redirect to the new context. Then it can be fully removed in a later release, maybe 4.0."
flask,5639,Issue,Comentario,"So far I've still been using the ""app context"" name for the new merged context. Couldn't think of a better term.

`teardown_appcontext` and `teardown_request` need to be combined, but they currently run at different times. `teardown_appcontext` runs in a `finally` block after `teardown_request` was attempted, and after `request` is no longer bound. The signals `appcontext_tearing_down` and `request_tearing_down` share the same timing.

I'd prefer to move away from the squished word ""appcontext"" to `teardown_context` and `context_tearing_down`. It's not clear whether `teardown_appcontext` or `teardown_request` is more commonly used right now, so it would probably be equally disruptive either way, since one of them is also getting removed."
flask,5639,Issue,Comentario,"Perhaps steal some ideas from dishka 

For example request context could only be entered from a active app context 

Also a siebling to request context for usage in background workers might be nice to have 


To draw a pytest analogy app context is a bit like session scope and request context is a bit like function scope "
flask,5639,Issue,Comentario,"I might not have the full picture, however I don't see much value in merging them **from user's perspective**. I fully acknowledge that it might be a bit of a hell from developer's perspective :)

Logically, application and request contexts separate makes sense, maybe out of habit if nothing else."
flask,5639,Issue,Comentario,"> I was never clear on why, but the contexts support being pushed multiple times.

Far enough along now that I've run into why this was done. As far as I've found this is the only scenario where it's needed, only during testing. When using `stream_with_context` to re-push the context once reading the streaming response starts, along with `with context` to preserve the context after the request is over. These two both try to push the same context, first to keep the preserved context active, then to keep the context active during the stream.

Using a single reference to the previous context is indeed much simpler than two contexts each with a stack of references. With only one context, using a stack would be more straightforward than currently, but seems like unnecessary (but very minor) runtime overhead just to support this test scenario.  Need to experiment more."
flask,5639,Issue,Comentario,"Keeping a simple integer count of how many times the context has been pushed/popped, and returning early if this is not the first push or last pop, fixes the issue."
flask,5814,Pull Request,Titulo,this is issue here
flask,5814,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5814,Pull Request,Comentario,this new changing
flask,5814,Pull Request,Comentario,Do not use public projects as your learning area. 
flask,5813,Pull Request,Titulo,Create codeql-analysis.yml
flask,5813,Pull Request,Descripcion,"add this request on teacher

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5813,Pull Request,Comentario,here this add yam; file
flask,5813,Pull Request,Comentario,"Please share what exactly your teacher told you. it's either a misunderstanding on your side, or if he really asks students to open random PRs that are just noise in real projects, it's highly inappropriate and disrespectful towards maintainers on his side."
flask,5810,Pull Request,Titulo,Add various bugs for BugBot demo
flask,5810,Pull Request,Descripcion,"- Fix missing None check in get_debug_flag() that could cause AttributeError
- Fix assertion logic in MethodView.dispatch_request() for HEAD requests
- Fix missing return statement in get_send_file_max_age() method
- Fix typo in Config.__init__() - root_paths instead of root_path
- Fix incorrect test assertion in test_options_work()

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5811,Pull Request,Titulo,Add various bugs for BugBot demo
flask,5811,Pull Request,Descripcion,"- Fix missing None check in get_debug_flag() that could cause AttributeError
- Fix assertion logic in MethodView.dispatch_request() for HEAD requests
- Fix missing return statement in get_send_file_max_age() method
- Fix typo in Config.__init__() - root_paths instead of root_path
- Fix incorrect test assertion in test_options_work()

<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5811,Pull Request,Comentario,"Sorry, I'm new to github and I create these two PRs by accident."
flask,5809,Pull Request,Titulo,Added a line for first contributionme
flask,5809,Pull Request,Descripcion,This is my first PR to practice open source contribution
flask,5809,Pull Request,Comentario,This is not a playground.
flask,5807,Pull Request,Titulo,Changed the static annotated type of select_jinja_autoescape method in src/flask/sansio/app.py
flask,5807,Pull Request,Descripcion,"Inside the code of the method the filename is checked against a None value and returns True, but the static annotated type is a str. I have changed the static annotation type to `str` to `str | None`."
flask,5807,Pull Request,Comentario,Closing the pull request
flask,5806,Pull Request,Titulo,Changed the static annotated type of select_jinja_autoescape method in src/flask/sansio/app.py
flask,5806,Pull Request,Descripcion,"Inside the code of the method the filename is checked against a None value and returns True, but the static annotated type is a str. I have changed the static annotation type to `str` to `str | None`."
flask,5806,Pull Request,Comentario,Please target this type of change at the stable branch. 
flask,5806,Pull Request,Comentario,"Closing this pull request as a corresponding pull request is raised in the stable branch
https://github.com/pallets/flask/pull/5808"
flask,5805,Pull Request,Titulo,feat(example/blog): Add flash messages for user feedback
flask,5805,Pull Request,Descripcion,"### Description
This PR adds flash messages (`created`, `updated`, `deleted`) to the blog example application in order to provide better user feedback after a post is modified. This improves the overall user experience.

### How This Was Tested
1. Ran the blog example application locally.
2. Created, updated, and deleted a post.
3. Verified that the appropriate success message was displayed at the top of the page after each action."
flask,5805,Pull Request,Comentario,Thank you for the review and I understand the goal of keeping the examples minimal. I appreciate you taking the time to look at my contribution!
flask,5803,Issue,Titulo,`flask.testing` misleadingly appears to import `TestResponse`
flask,5803,Issue,Descripcion,"`testing.py` contains the following:
```python
if t.TYPE_CHECKING:  # pragma: no cover
    from werkzeug.test import TestResponse
```
As such, any IDE or static checker will consider this to be valid code:
```python
import flask.testing as _flask_test

def my_test_helper(flask_test_client: _flask_test.FlaskClient) -> _flask_test.TestResponse:
    ...
```

However, at runtime, this code will fail, because `TestResponse` is not actually imported into the `flask.testing` namespace.

Possible solutions:
- Move `from werkzeug.test import TestResponse` outside the `if t.TYPE_CHECKING` block; you're already importing `werkzeug.test` in that file anyway
- Remove `from werkzeug.test import TestResponse` entirely and replace `TestResponse` with `werkzeug.test.TestResponse` in type-hints
- Change `from werkzeug.test import TestResponse` to `from werkzeug.test import TestResponse as _TestResponse`; the leading underscore signals marks the import as private, at which point it doesn't matter if its really imported or not because nobody should be using it from outside the file
"
flask,5803,Issue,Comentario,"That's a bug to report to the IDE that is saying it's valid. Importing names but not exporting them is a normal and valid pattern in pretty much all code, not just flask. "
flask,5803,Issue,Comentario,"> That's a bug to report to the IDE that is saying it's valid. Importing names but not exporting them is a normal and valid pattern in pretty much all code, not just flask.

No, it's a standard part of Python. If you import a module, you import all the items in that module, unless they are marked as private via the convention of a leading underscore on the name. Indeed, many modules import many objects with the explicit intent that users will access them via that module. Most often, but not exclusively, that happens in `__init__.py`, but it can and does happen anywhere."
flask,5802,Pull Request,Titulo,Add CodeQL scan workflow
flask,5802,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5802,Pull Request,Comentario,"This pull request sets up GitHub code scanning for this repository. Once the scans have completed and the checks have passed, the analysis results for this pull request branch will appear on [this overview](/pallets/flask/security/code-scanning?query=pr%3A5802+is%3Aopen). Once you merge this pull request, the 'Security' tab will show more code scanning analysis results (for example, for the default branch). Depending on your configuration and choice of analysis tool, future pull requests will be annotated with code scanning analysis results. For more information about GitHub code scanning, check out [the documentation](https://docs.github.com/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning). "
flask,5802,Pull Request,Comentario,"Do not make unsolicited changes to our project configuration.

Also FYI, the analysis it produced is complete junk."
flask,5801,Pull Request,Titulo,Add DEVOPS_NOTES.txt for practice
flask,5801,Pull Request,Descripcion,"<!--
Before opening a PR, open a ticket describing the issue or feature the
PR will address. An issue is not required for fixing typos in
documentation, or other simple non-code changes.

Replace this comment with a description of the change. Describe how it
addresses the linked ticket.
-->

<!--
Link to relevant issues or previous PRs, one per line. Use ""fixes"" to
automatically close an issue.

fixes #<issue number>
-->

<!--
Ensure each step in CONTRIBUTING.rst is complete, especially the following:

- Add tests that demonstrate the correct behavior of the change. Tests
  should fail without the change.
- Add or update relevant docs, in the docs folder and in code.
- Add an entry in CHANGES.rst summarizing the change and linking to the issue.
- Add `.. versionchanged::` entries in any relevant code docs.
-->
"
flask,5801,Pull Request,Comentario,Do not use other people's repositories for learning how to use Git or GitHub. Create your own repo which is NOT a fork of someone else's repo to test PRs.
flask,5774,Issue,Titulo,`stream_with_context` does not work with async routes
flask,5774,Issue,Descripcion,"Consider this trivial route + test in `app.py`:

```python
import flask
from flask import Flask
from flask import Response

import pytest

app = Flask(__name__)


@app.route(""/foo"")
async def foo():
    def gen():
        yield ""bar""

    return Response(flask.stream_with_context(gen()))


def test_foo():
    with app.test_client() as client:
        client.get(""/foo"")
```

With the following `requirements.txt`:

```
flask[async]==3.1.1
pytest==8.4.1
werkzeug==3.1.3
```

Running `pytest app.py` results in:

```
============================= test session starts ==============================
platform darwin -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0
rootdir: /private/tmp/stream_with_context
collected 1 item

app.py F                                                                 [100%]

=================================== FAILURES ===================================
___________________________________ test_foo ___________________________________

    def test_foo():
        with app.test_client() as client:
>           client.get(""/foo"")

app.py:20:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv/lib/python3.12/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/flask/testing.py:235: in open
    response = super().open(
venv/lib/python3.12/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/flask/app.py:1527: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <RequestContext 'http://localhost/foo' [GET] of app>, exc = None

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """"""Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.

        .. versionchanged:: 0.9
           Added the `exc` argument.
        """"""
        clear_request = len(self._cv_tokens) == 1

        try:
            if clear_request:
                if exc is _sentinel:
                    exc = sys.exc_info()[1]
                self.app.do_teardown_request(exc)

                request_close = getattr(self.request, ""close"", None)
                if request_close is not None:
                    request_close()
        finally:
            ctx = _cv_request.get()
            token, app_ctx = self._cv_tokens.pop()
>           _cv_request.reset(token)
E           ValueError: <Token var=<ContextVar name='flask.request_ctx' at 0x103cd9a30> at 0x104b23a40> was created in a different Context

venv/lib/python3.12/site-packages/flask/ctx.py:418: ValueError
=========================== short test summary info ============================
FAILED app.py::test_foo - ValueError: <Token var=<ContextVar name='flask.request_ctx' at 0x103cd9a30>...
============================== 1 failed in 0.11s ===============================
```

Similarly, `python -m flask run` and then `curl http://127.0.0.1:5000/foo` results in:

```
127.0.0.1 - - [15/Jul/2025 13:40:14] ""GET /foo HTTP/1.1"" 500 -
Error on request:
Traceback (most recent call last):
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/werkzeug/serving.py"", line 370, in run_wsgi
    execute(self.server.app)
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/werkzeug/serving.py"", line 331, in execute
    application_iter = app(environ, start_response)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/flask/app.py"", line 1536, in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/flask/app.py"", line 1527, in wsgi_app
    ctx.pop(error)
  File ""/private/tmp/stream_with_context/venv/lib/python3.12/site-packages/flask/ctx.py"", line 418, in pop
    _cv_request.reset(token)
ValueError: <Token var=<ContextVar name='flask.request_ctx' at 0x1029ccea0> at 0x1049e1980> was created in a different Context
```

If the route is defined `def foo():` without `async`, then this works without issue.

Or if we remove `stream_with_context` and just `return Response(gen())`, also works.

But the combination of `async` + `stream_with_context` fails.

There's also no issue with e.g. flask 2.1.0; I believe this was introduced in flask 2.2.0, specifically by #4682.

Environment:

- Python version: 3.12.11
- Flask version: 3.1.1"
flask,5774,Issue,Comentario,"I don't think this can be supported. `Response`, which comes from Werkzeug, expects a sync iterable, not an async one. I'm pretty sure it is possible to stream async responses with context, but just not by using the `Response(stream(gen))` pattern. Maybe @pgjones can point you to the exact pattern."
flask,5774,Issue,Comentario,"Never mind, this is a specific fixable issue with `stream_with_context`, not an issue with async views. Thanks for finding the PR that affected it, when I took another look at this it put me on the right path.

The problem is related to how we automatically push an app context when pushing a request context. If an app context is not already pushed, we create one and push it, recording that we should pop it when the request context is popped. We store this using `ContextVars`, which are sensitive to the async loop/thread they were modified from. The order that pushes and pops happens in is important, and is pretty complex when dealing with the request/response, stream with context, and test client context preservation all at once.

The immediate issue you reported is because of when `stream_with_context` was pushing the request. It would push it as soon as the generator started, and in the case of an async view it is running in a temporary async loop context only for that view function. Therefore, when we went to pop it later during cleanup and test client, the context it was pushed in no longer matched the current context.

That can be fixed by adjusting when the context is pushed to when the streaming response starts, rather than when the generator starts. But this resulted in another error, because at that point the app context had already been cleaned up, but recorded for client preservation. So the generator would automatically push a new app context, then things would get cleaned up in the wrong order.

That can be fixed by pushing the app and request contexts separately in `stream_with_context`, so that the request context will not automatically add or clean up the app context.

There's a comment in `stream_with_context` saying that pushing at the point it was is intentional and required for correct operation. But as far as I can tell with further test scenarios, everything works correctly with the change. Perhaps it was required before that PR changed how things worked.

Phew üòÆ‚Äçüí®"
flask,5774,Issue,Comentario,thank you for fixing!
flask,5799,Pull Request,Titulo,refactor stream_with_context for async views
flask,5799,Pull Request,Descripcion,"Store the app context as well as the request context when creating the generator. This prevents the request context from automatically creating and pushing a different app context. Then push the app context first, and push them only when iteration starts, not during setup. This prevents the request context from automatically popping the app context, and avoids associating the internal ContextVar with the temporary event loop in async views.

fixes #5774"
